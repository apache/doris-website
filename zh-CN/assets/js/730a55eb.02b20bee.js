"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["448973"],{659228:function(e,t,i){i.r(t),i.d(t,{assets:function(){return l},contentTitle:function(){return o},default:function(){return h},frontMatter:function(){return r},metadata:function(){return a},toc:function(){return c}});var a=i(850046),n=i(785893),s=i(250065);let r={title:"Data analysis for live streaming: what happens in real time is analyzed in real time",description:"As live streaming emerges as a way of doing business, the need for data analysis follows up. This post is about how a live streaming service provider with 800 million end users found the right database to support its analytic solution.",date:"2023-10-30",author:"velodb.io \xb7 He Gong",tags:["Best Practice"],externalLink:"https://www.velodb.io/blog/139",image:"/images/live-streaming.png"},o=void 0,l={authorsImageUrls:[void 0]},c=[{value:"What&#39;s different about data analytics in live streaming?",id:"whats-different-about-data-analytics-in-live-streaming",level:2},{value:"Simplify the Components",id:"simplify-the-components",level:2},{value:"Disaster Recovery",id:"disaster-recovery",level:2},{value:"Data Visualization",id:"data-visualization",level:2},{value:"Bitmap Index to Accelerate Tag Queries",id:"bitmap-index-to-accelerate-tag-queries",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){let t={a:"a",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"whats-different-about-data-analytics-in-live-streaming",children:"What's different about data analytics in live streaming?"}),"\n",(0,n.jsx)(t.p,{children:"Live streaming is one typical use case for real-time data analysis, because it stresses speed. Livestream organizers need to keep abreast of the latest data to see what is happening and maximize effectiveness. To realize that requires high efficiency in every step of data processing:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Data writing"}),": A live event churns out huge amounts of data every second, so the database should be able to ingest such high throughput stably."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Data update"}),": As life itself, live streaming entails a lot of data changes, so there should be a quick and reliable data updating mechanism to absorb the changes."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Data queries"}),": Data should be ready and accessible as soon as analysts want it. Mostly that means real-time visibility."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Maintenance"}),": What's special about live streaming is that the data stream has prominent highs and lows. The analytic system should be able to ensure stability during peak times, and allow scaling down in off-peak times in order to improve resource utilization. If possible, it should also provide disaster recovery services to guarantee system availability, since the worst case in live streaming is interruption."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The rest of this post is about how a live streaming service provider with 800 million end users found the right database to support its analytic solution."}),"\n",(0,n.jsx)(t.h2,{id:"simplify-the-components",children:"Simplify the Components"}),"\n",(0,n.jsx)(t.p,{children:"In this case, the live streaming data analytic platform adopts the Lambda architecture, which consists of a batch processing pipeline and a streaming pipeline, the former for user profile information and the latter for real-time generated data, including metrics like real-time subscription, visitor count, comments and responses."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Batching processing"}),": The user basic information stored in HDFS is written into HBase to form a table."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Streaming"}),": Real-time generated data from MySQL, collected via Flink CDC, goes into Apache Kafka. Flink works as the computation engine and then the data is stored in Redis."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"database-for-live-shopping-Elasticsearch-HBase",src:i(302890).Z+"",width:"1898",height:"966"})}),"\n",(0,n.jsx)(t.p,{children:"The real-time metrics will be combined with the user profile information to form a flat table, and Elasticsearch will work as the query engine."}),"\n",(0,n.jsx)(t.p,{children:"As their business burgeons, the expanding data size becomes unbearable for this platform, with problems like:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Delayed data writing"}),": The multiple components result in multiple steps in data writing, and inevitably lead to prolonged data writing, especially during peak times."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Complicated updating mechanism"}),": Every time there is a data change, such as that in user subscription information, it must be updated into the main tables and dimensional tables, and then the tables are correlated to generate a new flat table. And don't forget that this long process has to be executed across multiple components. So just imagine the complexity."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Slow queries"}),": As the query engine, Elasticsearch struggles with concurrent query requests and data accesses. It is also not flexible enough to deal with the join queries."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Time-consuming maintenance"}),": All engineers developing or maintaining this platform need to master all the components. That's a lot of training. And adding new metrics to the data pool is labor-intensive."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["So to sum up, the main problem for this architecture is its complexity. To reduce the components means to find a database that is not only capable of most workloads, but also performant in data writing and queries. After 6 months of testing, they finally upgraded their live streaming analytic platform with ",(0,n.jsx)(t.a,{href:"https://doris.apache.org/",children:"Apache Doris"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"They converge the streaming and the batch processing pipelines at Apache Doris. It can undertake analytic workloads and also provides a storage layer so data doesn't have to shuffle back to Elasticsearch and HBase as it did in the old architecture."}),"\n",(0,n.jsx)(t.p,{children:"With Apache Doris as the data warehouse, the platform architecture becomes neater."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"database-for-live-shopping-Apache-Doris",src:i(771394).Z+"",width:"1908",height:"936"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Smooth data writing"}),": Raw data is processed by Flink and written into Apache Doris in real time. The Doris community provides a ",(0,n.jsx)(t.a,{href:"https://github.com/apache/doris-flink-connector",children:"Flink-Doris-Connector"})," with built-in Flink CDC."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Flexible data update"}),": For data changes, Apache Doris implements ",(0,n.jsx)(t.a,{href:"https://doris.apache.org/docs/data-table/data-model/#merge-on-write",children:"Merge-on-Write"}),". This is especially useful in small-batch real-time writing because you don't have to renew the entire flat table. It also supports partial update of columns, which is another way to make data updates more lightweight. In this case, Apache Doris is able to finish Upsert or Insert Overwrite operations for ",(0,n.jsx)(t.strong,{children:"200,000 rows per second"}),", and these are all done in large tables with the biggest ones reaching billions of rows."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Faster queries"}),": For join queries, Apache Doris can easily join multiple large tables (10 billion rows). It can respond to a rich variety of queries within seconds or even milliseconds, including tag retrievals, fuzzy queries, ranking, and paginated queries."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Easier maintenance"}),": As for Apache Doris itself, the frontend and backend nodes are both flexibly scalable. It is compatible with MySQL protocol. What took the developers a month now can be finished within a week, which allows for more agile iteration of metrics."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The above shows how Apache Doris speeds up the entire data processing pipeline with its all-in-one capabilities. Beyond that, it has some delightful features that can increase query efficiency and ensure service reliability in the case of live streaming."}),"\n",(0,n.jsx)(t.h2,{id:"disaster-recovery",children:"Disaster Recovery"}),"\n",(0,n.jsx)(t.p,{children:"The last thing you want in live streaming is service breakdown, so disaster recovery is necessary."}),"\n",(0,n.jsx)(t.p,{children:"Before the live streaming platform had Apache Doris in place, they only backed up their data to object storage. It took an hour from when a failure was reported to when it was fixed. That one-hour window is fatal for live commerce because viewers will leave immediately. Thus, disaster recovery must be quick."}),"\n",(0,n.jsx)(t.p,{children:"Now, with Apache Doris, they have a dual-cluster solution: a primary cluster and a backup cluster. This is for hot backup. Besides that, they have a cold backup plan, which is the same as what they did: backing up their everyday data to object storage via Backup and Freeze policies."}),"\n",(0,n.jsxs)(t.p,{children:["This is how they do hot backup before ",(0,n.jsx)(t.a,{href:"https://doris.apache.org/zh-CN/blog/release-note-2.0.0",children:"Apache Doris 2.0"}),":"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Data dual-write"}),": Write data to both the primary cluster and backup cluster."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Load balancing"}),": In case there is something wrong with one cluster, query requests can be directed to the other cluster via reverse proxy."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Monitoring"}),": Regularly check the data consistency between the two clusters."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Apache Doris 2.0 supports ",(0,n.jsx)(t.a,{href:"https://doris.apache.org/zh-CN/blog/release-note-2.0.0#support-for-cross-cluster-replication-ccr",children:"Cross Cluster Replication (CCR)"}),", which can automate the above processes to reduce maintenance costs and inconsistency risks due to human factors."]}),"\n",(0,n.jsx)(t.h2,{id:"data-visualization",children:"Data Visualization"}),"\n",(0,n.jsx)(t.p,{children:"In addition to reporting, dashboarding, and ad-hoc queries, the platform also allows analysts to configure various data sources to produce their own visualized data lists."}),"\n",(0,n.jsx)(t.p,{children:"Apache Doris is compatible with most BI tools on the market, so the platform developers can tap on that and provide a broader set of functionalities for live streamers."}),"\n",(0,n.jsx)(t.p,{children:"Also, built on the real-time capabilities and quick computation of Apache Doris, live streams can view data and see what happens in real time, instead of waiting for a day for data analysis."}),"\n",(0,n.jsx)(t.h2,{id:"bitmap-index-to-accelerate-tag-queries",children:"Bitmap Index to Accelerate Tag Queries"}),"\n",(0,n.jsx)(t.p,{children:'A big part of data analysis in live streaming is viewer profiling. Viewers are divided into groups based on their online footprint. They are given tags like "watched for over one minute" and "visited during the past minute". As the show goes on, viewers are constantly tagged and untagged. In the data warehouse, it means frequent data insertion and deletion. Plus, one viewer is given multiple tags. To gain an overall understanding of users entail join queries, which is why the join performance of the data warehouse is important.'}),"\n",(0,n.jsx)(t.p,{children:"The following snippets give you a general idea of how to tag users and conduct tag queries in Apache Doris."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Create a Tag Table"})}),"\n",(0,n.jsx)(t.p,{children:"A tag table lists all the tags that are given to the viewers, and maps the tags to the corresponding viewer ID."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-SQL",children:"create table db.tags (  \nu_id string,  \nversion string,  \ntags string\n) with (  \n'connector' = 'doris',  \n'fenodes' = '',  \n'table.identifier' = 'tags',  \n'username' = '',  \n'password' = '',  \n'sink.properties.format' = 'json',  \n'sink.properties.strip_outer_array' = 'true',  \n'sink.properties.fuzzy_parse' = 'true',  \n'sink.properties.columns' = 'id,u_id,version,a_tags,m_tags,a_tags=bitmap_from_string(a_tags),m_tags=bitmap_from_string(m_tags)',  \n'sink.batch.interval' = '10s',  \n'sink.batch.size' = '100000' \n);\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Create a Tag Version Table"})}),"\n",(0,n.jsx)(t.p,{children:"The tag table is constantly changing, so there are different versions of it as time goes by."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-SQL",children:"create table db.tags_version (  \nid string,  \nu_id string,  \nversion string  \n) with (  \n'connector' = 'doris',  \n'fenodes' = '',  \n'table.identifier' = 'db.tags_version',  \n'username' = '',  \n'password' = '',  \n'sink.properties.format' = 'json',  \n'sink.properties.strip_outer_array' = 'true',  \n'sink.properties.fuzzy_parse' = 'true',  \n'sink.properties.columns' = 'id,u_id,version',  \n'sink.batch.interval' = '10s',  \n'sink.batch.size' = '100000'  \n);\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Write Data into Tag Table and Tag Version Table"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-SQL",children:"insert into db.tags\nselect\nu_id,  \nlast_timestamp as version,\ntags\nfrom db.source;  \n  \ninsert into rtime_db.tags_version\nselect \nu_id,  \nlast_timestamp as version\nfrom db.source;\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Tag Queries Accelerated by Bitmap Index"})}),"\n",(0,n.jsx)(t.p,{children:'For example, analysts need to find out the latest tags related to a certain viewer with the last name Thomas. Apache Doris will run the LIKE operator in the user information table to find all "Thomas". Then it creates bitmap indexes for the tags. Lastly, it relates all user information table, tag table, and tag version table to return the result.'}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Of almost a billion viewers and each of them has over a thousand tags, the bitmap index can help reduce the query response time to less than one second."})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-SQL",children:"with t_user as (\n    select \n           u_id,\n           name\n    from db.user\n    where partition_id = 1\n    and name like '%Thomas%'\n),\n\n t_tags as (\n         select \n                 u_id, \n                 version\n         from db.tags\n         where (\n                   bitmap_and_count(a_tags, bitmap_from_string(\"123,124,125,126,333\")) > 0 \n           )\n ),\n \n t_tag_version as (\n         select id, u_id, version\n         from db.tags_version\n )\n\nselect \n    t1.u_id\n    t1.name\nfrom t_user t1\njoin t_tags t2 on t1.u_id = t2.u_id\njoin t_tag_version t3 on t2.u_id = t3.u_id and t2.version = t3.version\norder by t1.u_id desc\nlimit 1,10;\n"})}),"\n",(0,n.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsxs)(t.p,{children:["Data analysis in live streaming is challenging for the underlying database, but it is also where the key competitiveness of Apache Doris comes to play. First of all, Apache Doris can handle most data processing workloads, so platform builders don't have to worry about putting many components together and consequential maintenance issues. Secondly, it has a lot of query-accelerating features, including but not limited to indexes. After tackling the speed issues, the ",(0,n.jsx)(t.a,{href:"https://join.slack.com/t/apachedoriscommunity/shared_invite/zt-2unfw3a3q-MtjGX4pAd8bCGC1UV0sKcw",children:"Apache Doris developer community"})," has been exploring its boundaries, such as introducing a more efficient cost-based query optimizer in version 2.0 and inverted index for text searches, fuzzy queries, and range queries. These features are embraced by the live streaming service provider as they are actively testing them and planning to transfer their log analytic workloads to Apache Doris, too."]})]})}function h(e={}){let{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},302890:function(e,t,i){i.d(t,{Z:function(){return a}});let a=i.p+"assets/images/xiaoe-tech-1-85a1ce0c20ef5cee50ca0b3c908f9ee0.png"},771394:function(e,t,i){i.d(t,{Z:function(){return a}});let a=i.p+"assets/images/xiaoe-tech-2-53446135cfc264b66e055259af6ff08b.png"},250065:function(e,t,i){i.d(t,{Z:function(){return o},a:function(){return r}});var a=i(667294);let n={},s=a.createContext(n);function r(e){let t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(s.Provider,{value:t},e.children)}},850046:function(e){e.exports=JSON.parse('{"permalink":"/zh-CN/blog/data-analysis-for-live-streaming-what-happens-in-real-time-is-analyzed-in-real-time","source":"@site/blog/data-analysis-for-live-streaming-what-happens-in-real-time-is-analyzed-in-real-time.md","title":"Data analysis for live streaming: what happens in real time is analyzed in real time","description":"As live streaming emerges as a way of doing business, the need for data analysis follows up. This post is about how a live streaming service provider with 800 million end users found the right database to support its analytic solution.","date":"2023-10-30T00:00:00.000Z","tags":[{"inline":true,"label":"Best Practice","permalink":"/zh-CN/blog/tags/best-practice"}],"hasTruncateMarker":false,"authors":[{"name":"velodb.io \xb7 He Gong","key":null,"page":null}],"frontMatter":{"title":"Data analysis for live streaming: what happens in real time is analyzed in real time","description":"As live streaming emerges as a way of doing business, the need for data analysis follows up. This post is about how a live streaming service provider with 800 million end users found the right database to support its analytic solution.","date":"2023-10-30","author":"velodb.io \xb7 He Gong","tags":["Best Practice"],"externalLink":"https://www.velodb.io/blog/139","image":"/images/live-streaming.png"},"unlisted":false,"prevItem":{"title":"Apache Doris Summit Asia 2023: what can you expect from apache doris as a data warehouse?","permalink":"/zh-CN/blog/apache-doris-summit-asia-2023-what-can-you-expect-from-apache-doris-as-a-data-warehouse"},"nextItem":{"title":"Apache Doris announced the official release of version 2.0.2","permalink":"/zh-CN/blog/release-2.0.2"}}')}}]);