"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["997898"],{502022:function(e,n,i){i.r(n),i.d(n,{default:()=>u,frontMatter:()=>a,metadata:()=>t,assets:()=>c,toc:()=>l,contentTitle:()=>o});var t=JSON.parse('{"id":"query-acceleration/tuning/tuning-plan/optimizing-table-index","title":"Optimizing Table Index Design","description":"Doris currently supports two types of indexes:","source":"@site/versioned_docs/version-4.x/query-acceleration/tuning/tuning-plan/optimizing-table-index.md","sourceDirName":"query-acceleration/tuning/tuning-plan","slug":"/query-acceleration/tuning/tuning-plan/optimizing-table-index","permalink":"/docs/4.x/query-acceleration/tuning/tuning-plan/optimizing-table-index","draft":false,"unlisted":false,"tags":[],"version":"4.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Optimizing Table Index Design","language":"en","description":"Doris currently supports two types of indexes:"},"sidebar":"docs","previous":{"title":"Optimizing Table Schema Design","permalink":"/docs/4.x/query-acceleration/tuning/tuning-plan/optimizing-table-schema"},"next":{"title":"Optimizing Table Scanning","permalink":"/docs/4.x/query-acceleration/tuning/tuning-plan/optimizing-table-scanning"}}'),s=i("785893"),r=i("250065");let a={title:"Optimizing Table Index Design",language:"en",description:"Doris currently supports two types of indexes:"},o=void 0,c={},l=[{value:"Overview",id:"overview",level:2},{value:"Case 1: Optimizing the Order of Key Columns to Leverage Prefix Indexes for Accelerated Queries",id:"case-1-optimizing-the-order-of-key-columns-to-leverage-prefix-indexes-for-accelerated-queries",level:2},{value:"Case 2: Using Inverted Indexes to Accelerate Queries",id:"case-2-using-inverted-indexes-to-accelerate-queries",level:2},{value:"Summary",id:"summary",level:2}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Doris currently supports two types of indexes:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Built-in Indexes: These include prefix indexes, ZoneMap indexes, etc."}),"\n",(0,s.jsx)(n.li,{children:"Secondary Indexes: These include inverted indexes, Bloom filter indexes, N-Gram Bloom filter indexes, and Bitmap indexes, etc."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In the process of business optimization, fully analyzing business characteristics and make effective use of indexes can greatly enhance the effectiveness of queries and analyses, thereby achieving the purpose of performance tuning."}),"\n",(0,s.jsxs)(n.p,{children:["For a detailed introduction to various indexes, please refer to the ",(0,s.jsx)(n.a,{href:"/docs/4.x/table-design/index/index-overview",children:"Table Index"})," section. This chapter will demonstrate index usage techniques in several typical scenarios from the perspective of actual cases and summarize optimization suggestions for reference in business tuning."]}),"\n",(0,s.jsx)(n.h2,{id:"case-1-optimizing-the-order-of-key-columns-to-leverage-prefix-indexes-for-accelerated-queries",children:"Case 1: Optimizing the Order of Key Columns to Leverage Prefix Indexes for Accelerated Queries"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.a,{href:"/docs/4.x/query-acceleration/tuning/tuning-plan/optimizing-table-schema",children:"optimizing table schema design"}),", we have introduced how to select appropriate fields as key fields and utilize Doris's key column sorting feature to accelerate queries. This case will further expand on this scenario."]}),"\n",(0,s.jsx)(n.p,{children:"Due to Doris's built-in prefix index function, it automatically takes the first 36 bytes of the table's Key as a prefix index when creating the table. When query conditions match the prefix of the prefix index, it can significantly speed up the query. Below is an example of a table definition:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE `t1` (\n  `c1` VARCHAR(10) NULL,\n  `c2` VARCHAR(10) NULL\n) ENGINE=OLAP\nDUPLICATE KEY(`c1`)\nDISTRIBUTED BY HASH(`c2`) BUCKETS 10\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 1"\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:"The corresponding business SQL pattern is as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"select * from t1 where t1.c2 = '1';\nselect * from t1 where t1.c2 in ('1', '2', '3');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the above schema definition, ",(0,s.jsx)(n.code,{children:"c1"})," comes before ",(0,s.jsx)(n.code,{children:"c2"}),". However, the queries use the ",(0,s.jsx)(n.code,{children:"c2"})," field for filtering. In this case, the acceleration function of the prefix index cannot be utilized. To optimize, we can adjust the definition order of ",(0,s.jsx)(n.code,{children:"c1"})," and ",(0,s.jsx)(n.code,{children:"c2"}),", placing the ",(0,s.jsx)(n.code,{children:"c2"})," column in the first field position to leverage the acceleration function of the prefix index."]}),"\n",(0,s.jsx)(n.p,{children:"The adjusted schema is as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE `t1` (\n  `c2` VARCHAR(10) NULL,\n  `c1` VARCHAR(10) NULL\n) ENGINE=OLAP\nDUPLICATE KEY(`c2`)\nDISTRIBUTED BY HASH(`c1`) BUCKETS 10\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 1"\n);\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"When defining the schema column order, reference the high-frequency and high-priority columns in business query filtering to fully leverage Doris's prefix index acceleration function."})}),"\n",(0,s.jsx)(n.h2,{id:"case-2-using-inverted-indexes-to-accelerate-queries",children:"Case 2: Using Inverted Indexes to Accelerate Queries"}),"\n",(0,s.jsx)(n.p,{children:"Doris supports inverted indexes as secondary indexes to accelerate business scenarios such as equal value, range, and full-text search of text types. The creation and management of inverted indexes are independent, allowing for convenient business performance optimization without affecting the original table schema and without the need to re-import table data."}),"\n",(0,s.jsxs)(n.p,{children:["For typical usage scenarios, syntax, and cases, please refer to the ",(0,s.jsx)(n.a,{href:"../../../table-design/index/inverted-index",children:"Table Index - Inverted Index"})," section for a detailed introduction, so this chapter will not repeat the explanation."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"For full-text searches of text types and equal value or range queries on string, numeric, and datetime type fields, inverted indexes can be utilized to accelerate queries. Especially in certain situations, such as when the original table structure and key definition are not convenient to optimize, or the cost of re-importing table data is high, inverted indexes provide a flexible acceleration solution to optimize business execution performance."})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"In schema tuning, apart from table-level schema optimization, index optimization also occupies an important position. Doris provides multiple index types, including built-in indexes such as prefix index, as well as secondary indexes such as inverted indexes, which provide strong support for performance acceleration. By reasonably utilizing these indexes, we can significantly improve the speed of business queries and analyses in multiple scenarios, which is of great significance for multi-scenario business queries and analyses."})]})}function u(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return o},a:function(){return a}});var t=i(667294);let s={},r=t.createContext(s);function a(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);