"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["458434"],{574255:function(e,n,i){i.r(n),i.d(n,{default:()=>u,frontMatter:()=>o,metadata:()=>t,assets:()=>a,toc:()=>c,contentTitle:()=>l});var t=JSON.parse('{"id":"sql-manual/sql-functions/window-functions/overview","title":"OVERVIEW","description":"Window functions (also known as analytic functions) are special built-in functions that perform calculations while preserving the original rows.","source":"@site/docs/sql-manual/sql-functions/window-functions/overview.md","sourceDirName":"sql-manual/sql-functions/window-functions","slug":"/sql-manual/sql-functions/window-functions/overview","permalink":"/docs/dev/sql-manual/sql-functions/window-functions/overview","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770477659000,"frontMatter":{"title":"OVERVIEW","language":"en","description":"Window functions (also known as analytic functions) are special built-in functions that perform calculations while preserving the original rows."},"sidebar":"docs","previous":{"title":"UNION","permalink":"/docs/dev/sql-manual/sql-functions/combinators/union"},"next":{"title":"CUME_DIST","permalink":"/docs/dev/sql-manual/sql-functions/window-functions/cume-dist"}}'),s=i("785893"),r=i("250065");let o={title:"OVERVIEW",language:"en",description:"Window functions (also known as analytic functions) are special built-in functions that perform calculations while preserving the original rows."},l=void 0,a={},c=[{value:"Description",id:"description",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"Unique Ordering for Analytic Function Data",id:"unique-ordering-for-analytic-function-data",level:2}];function d(e){let n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"../../../query-data/window-function",children:"Window functions"})," (also known as analytic functions) are special built-in functions that perform calculations while preserving the original rows. Unlike aggregate functions, window functions:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Process data within a specific window range rather than by GROUP BY grouping"}),"\n",(0,s.jsx)(n.li,{children:"Calculate a value for each row in the result set"}),"\n",(0,s.jsx)(n.li,{children:"Can add additional columns in the SELECT list"}),"\n",(0,s.jsx)(n.li,{children:"Execute last in query processing (after JOIN, WHERE, GROUP BY)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Window functions are commonly used in financial and scientific computing for trend analysis, outlier calculation, and data bucketing."}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"<FUNCTION> ( [ <ARGUMENTS> ] ) OVER ( [ <windowDefinition> ] )\n"})}),"\n",(0,s.jsx)(n.p,{children:"And:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"windowDefinition ::=\n\n[ PARTITION BY <expr1> [, ...] ]\n[ ORDER BY <expr2> [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ <windowFrameClause> ]\n"})}),"\n",(0,s.jsx)(n.p,{children:"And:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"windowFrameClause ::=\n{\n  | { ROWS } <n> PRECEDING\n  | { ROWS } CURRENT ROW\n  | { ROWS } BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING\n  | { ROWS | RANGE } UNBOUNDED PRECEDING\n  | { ROWS | RANGE } BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n  | { ROWS | RANGE } BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  | { ROWS } BETWEEN <n> { PRECEDING | FOLLOWING } AND <n> { PRECEDING | FOLLOWING }\n  | { ROWS } BETWEEN UNBOUNDED PRECEDING AND <n> { PRECEDING | FOLLOWING }\n  | { ROWS } BETWEEN <n> { PRECEDING | FOLLOWING } AND UNBOUNDED FOLLOWING\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"<FUNCTION>"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"The name of the window function. Includes all aggregate functions plus special window functions: DENSE_RANK(), FIRST_VALUE(), LAG(), LAST_VALUE(), LEAD(), RANK(), ROW_NUMBER(), NTH_VALUE(), PERCENT_RANK(), CUME_DIST(), NTILE()."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"<ARGUMENTS>"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Optional. The input arguments for the window function. The argument types and quantity depend on the specific function being used."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"<PARTITION_BY>"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Optional. Similar to GROUP BY, it groups data by specified columns, then performs calculations within each partition."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"<ORDER_BY>"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Optional. Used to sort data within each partition. If no partition is specified, it will sort the entire dataset. However, this ",(0,s.jsx)(n.code,{children:"ORDER BY"})," is different from the common ",(0,s.jsx)(n.code,{children:"ORDER BY"})," that appears at the end of an SQL statement. The sorting specified in the ",(0,s.jsx)(n.code,{children:"OVER"})," clause only applies to the data within that partition, whereas the ",(0,s.jsx)(n.code,{children:"ORDER BY"})," at the end of an SQL statement controls the order of all rows in the final query results. These two can coexist.\nAdditionally, if ",(0,s.jsx)(n.code,{children:"ORDER BY"})," is not explicitly specified in the ",(0,s.jsx)(n.code,{children:"OVER"})," clause, the data within the partition may be random, potentially leading to unpredictable final results. If sorting columns are explicitly provided but contain duplicate values, the results may still be unstable. For specific examples, refer to the ",(0,s.jsx)(n.a,{href:"#section1",children:"case study"})," below."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"<windowFrameClause>"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Optional. Used to define the window frame. Currently, two types are supported: ",(0,s.jsx)(n.code,{children:"RANGE"})," and ",(0,s.jsx)(n.code,{children:"ROWS"}),".\nFor ",(0,s.jsx)(n.code,{children:"N PRECEDING/FOLLOWING"}),", where ",(0,s.jsx)(n.code,{children:"N"})," is a positive integer, it represents the sliding window range relative to the current row. Currently, this is only supported in ",(0,s.jsx)(n.code,{children:"ROWS"})," windows, so it indicates a physical offset relative to the current row. The ",(0,s.jsx)(n.code,{children:"RANGE"})," type currently has some limitations: it must be either ",(0,s.jsx)(n.code,{children:"BOTH UNBOUNDED BOUNDARY"})," or ",(0,s.jsx)(n.code,{children:"ONE UNBOUNDED BOUNDARY AND ONE CURRENT ROW"}),". If no frame is specified, the default implicit frame is ",(0,s.jsx)(n.code,{children:"RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,s.jsx)(n.p,{children:"Returns the same data type as the input expression."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{id:"section1"})}),"\n",(0,s.jsx)(n.h2,{id:"unique-ordering-for-analytic-function-data",children:"Unique Ordering for Analytic Function Data"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Issue of Inconsistent Return Results"})}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.code,{children:"ORDER BY"})," clause of a window function fails to produce a unique ordering of the data, such as when the ",(0,s.jsx)(n.code,{children:"ORDER BY"})," expression results in duplicate values, the order of the rows becomes indeterminate. This means that the return order of these rows may vary across multiple query executions, leading to inconsistent results from the window function."]}),"\n",(0,s.jsxs)(n.p,{children:["The following example illustrates how the query returns different results on successive runs. The inconsistency arises primarily because ",(0,s.jsx)(n.code,{children:"ORDER BY dateid"})," does not provide a unique ordering for the ",(0,s.jsx)(n.code,{children:"SUM"})," window function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE test_window_order \n    (item_id int,\n    date_time date,\n    sales double)\ndistributed BY hash(item_id)\nproperties(\"replication_num\" = 1);\n\nINSERT INTO test_window_order VALUES\n(1, '2024-07-01', 100),\n(2, '2024-07-01', 100),\n(3, '2024-07-01', 140);\n\nSELECT\n    item_id, date_time, sales,\n    sum(sales) OVER (ORDER BY date_time ROWS BETWEEN \n        UNBOUNDED PRECEDING AND CURRENT ROW) sum\nFROM\n    test_window_order;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Due to duplicate values in the sorting column ",(0,s.jsx)(n.code,{children:"date_time"}),", the following two query results may be observed:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"+---------+------------+-------+------+\n| item_id | date_time  | sales | sum  |\n+---------+------------+-------+------+\n|       1 | 2024-07-01 |   100 |  100 |\n|       3 | 2024-07-01 |   140 |  240 |\n|       2 | 2024-07-01 |   100 |  340 |\n+---------+------------+-------+------+\n3 rows in set (0.03 sec)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Solution"})}),"\n",(0,s.jsxs)(n.p,{children:["To address this issue, you can add a unique value column, such as ",(0,s.jsx)(n.code,{children:"item_id"}),", to the ",(0,s.jsx)(n.code,{children:"ORDER BY"})," clause to ensure the uniqueness of the ordering."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT\n        item_id,\n        date_time,\n        sales,\n        sum(sales) OVER (\n        ORDER BY item_id,\n        date_time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) sum\nFROM\n        test_window_order;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This results in a consistent query output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"+---------+------------+-------+------+\n| item_id | date_time  | sales | sum  |\n+---------+------------+-------+------+\n|       1 | 2024-07-01 |   100 |  100 |\n|       2 | 2024-07-01 |   100 |  200 |\n|       3 | 2024-07-01 |   140 |  340 |\n+---------+------------+-------+------+\n3 rows in set (0.03 sec)\n"})})]})}function u(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return l},a:function(){return o}});var t=i(667294);let s={},r=t.createContext(s);function o(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);