"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["77568"],{413762:function(e,t,n){n.r(t),n.d(t,{default:()=>h,frontMatter:()=>o,metadata:()=>s,assets:()=>r,toc:()=>c,contentTitle:()=>l});var s=JSON.parse('{"id":"data-operate/transaction","title":"Transaction","description":"A transaction is an operation that contains one or more SQL statements. The execution of these statements must either be completely successful or completely fail. It is an indivisible work unit.","source":"@site/versioned_docs/version-2.1/data-operate/transaction.md","sourceDirName":"data-operate","slug":"/data-operate/transaction","permalink":"/docs/2.1/data-operate/transaction","draft":false,"unlisted":false,"tags":[],"version":"2.1","frontMatter":{"title":"Transaction","language":"en"},"sidebar":"docs","previous":{"title":"Temporary Partition","permalink":"/docs/2.1/data-operate/delete/table-temp-partition"},"next":{"title":"Export Overview","permalink":"/docs/2.1/data-operate/export/export-overview"}}'),a=n("785893"),i=n("250065");let o={title:"Transaction",language:"en"},l=void 0,r={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Explicit and Implicit Transactions",id:"explicit-and-implicit-transactions",level:2},{value:"Explicit Transactions",id:"explicit-transactions",level:3},{value:"Implicit Transactions",id:"implicit-transactions",level:3},{value:"Isolation Level",id:"isolation-level",level:3},{value:"No Duplicates, No Loss",id:"no-duplicates-no-loss",level:3},{value:"Label Mechanism",id:"label-mechanism",level:4},{value:"StreamLoad 2PC",id:"streamload-2pc",level:4},{value:"Transaction Operations",id:"transaction-operations",level:2},{value:"Start a Transaction",id:"start-a-transaction",level:3},{value:"Commit a Transaction",id:"commit-a-transaction",level:3},{value:"Transaction with multiple sql statements",id:"transaction-with-multiple-sql-statements",level:2},{value:"Multiple <code>INSERT INTO VALUES</code> for one table",id:"multiple-insert-into-values-for-one-table",level:3},{value:"QA",id:"qa",level:4},{value:"Stream Load 2PC",id:"stream-load-2pc",level:2},{value:"Broker Load into muti tables with a transaction",id:"broker-load-into-muti-tables-with-a-transaction",level:2}];function d(e){let t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"A transaction is an operation that contains one or more SQL statements. The execution of these statements must either be completely successful or completely fail. It is an indivisible work unit."}),"\n",(0,a.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(t.p,{children:"Queries and DDL single statements are implicit transactions and are not supported within multi-statement transactions. Each individual write is an implicit transaction by default, and multiple writes can form an explicit transaction. Currently, Doris does not support nested transactions."}),"\n",(0,a.jsx)(t.h2,{id:"explicit-and-implicit-transactions",children:"Explicit and Implicit Transactions"}),"\n",(0,a.jsx)(t.h3,{id:"explicit-transactions",children:"Explicit Transactions"}),"\n",(0,a.jsx)(t.p,{children:"Explicit transactions require users to actively start, commit transactions. Only insert into values statement is supported in 2.1."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"BEGIN;\n[INSERT INTO VALUES]\nCOMMIT;\n"})}),"\n",(0,a.jsx)(t.p,{children:"Rollback is not supported in 2.1."}),"\n",(0,a.jsx)(t.h3,{id:"implicit-transactions",children:"Implicit Transactions"}),"\n",(0,a.jsx)(t.p,{children:"Implicit transactions refer to SQL statements that are executed without explicitly adding statements to start and commit transactions before and after the statements."}),"\n",(0,a.jsxs)(t.p,{children:["In Doris, except for ",(0,a.jsx)(t.a,{href:"../data-operate/import/group-commit-manual",children:"Group Commit"}),", each import statement opens a transaction when it starts executing. The transaction is automatically committed after the statement is executed, or automatically rolled back if the statement fails. Each query or DDL statement is also an implicit transaction."]}),"\n",(0,a.jsx)(t.h3,{id:"isolation-level",children:"Isolation Level"}),"\n",(0,a.jsx)(t.p,{children:"The only isolation level currently supported by Doris is READ COMMITTED. Under the READ COMMITTED isolation level, a statement sees only data that was committed before the statement began execution. It does not see uncommitted data."}),"\n",(0,a.jsx)(t.p,{children:"When a single statement is executed, it captures a snapshot of the tables involved at the start of the statement, meaning that a single statement can only see commits from other transactions made before it began execution. Other transactions' commits are not visible during the execution of a single statement."}),"\n",(0,a.jsx)(t.p,{children:"When a statement is executed inside a multi-statement transaction:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"It sees only data that was committed before the statement began execution. If another transaction commits between the execution of the first and the second statements, two successive statements in the same transaction may see different data."}),"\n",(0,a.jsx)(t.li,{children:"Currently, it cannot see changes made by previous statements within the same transaction."}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"no-duplicates-no-loss",children:"No Duplicates, No Loss"}),"\n",(0,a.jsx)(t.p,{children:"Doris supports mechanisms to ensure no duplicates and no loss during data writes. The Label mechanism ensures no duplicates within a single transaction, while two-phase commit coordinates to prevent duplicates across multiple transactions."}),"\n",(0,a.jsx)(t.h4,{id:"label-mechanism",children:"Label Mechanism"}),"\n",(0,a.jsx)(t.p,{children:"Transactions or writes in Doris can be assigned a Label. This Label is typically a user-defined string with some business logic attributes. If not set, a UUID string will be generated internally. The main purpose of a Label is to uniquely identify a transaction or import task and ensure that a transaction or import with the same Label will only execute successfully once. The Label mechanism ensures that data imports are neither lost nor duplicated. If the upstream data source guarantees at-least-once semantics, combined with Doris's Label mechanism, exactly-once semantics can be achieved. Labels are unique within a database."}),"\n",(0,a.jsx)(t.p,{children:"Doris will clean up Labels based on time and number. By default, if the number of Labels exceeds 2000, cleanup will be triggered. Labels older than three days will also be cleaned up by default. Once a Label is cleaned up, a Label with the same name can execute successfully again, meaning it no longer has deduplication semantics."}),"\n",(0,a.jsxs)(t.p,{children:["Labels are usually set in the format of ",(0,a.jsx)(t.code,{children:"business_logic+timestamp"}),", such as ",(0,a.jsx)(t.code,{children:"my_business1_20220330_125000"}),". This Label typically represents a batch of data generated by the business ",(0,a.jsx)(t.code,{children:"my_business1"})," at ",(0,a.jsx)(t.code,{children:"2022-03-30 12:50:00"}),". By setting Labels this way, the business can query the import task status using the Label to clearly determine whether the batch of data at that time has been successfully imported. If not, the import can be retried using the same Label."]}),"\n",(0,a.jsx)(t.h4,{id:"streamload-2pc",children:"StreamLoad 2PC"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"#stream-load",children:"StreamLoad 2PC"})," is mainly used to support exactly-once semantics (EOS) when writing to Doris with Flink."]}),"\n",(0,a.jsx)(t.h2,{id:"transaction-operations",children:"Transaction Operations"}),"\n",(0,a.jsx)(t.h3,{id:"start-a-transaction",children:"Start a Transaction"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"BEGIN;\n\nBEGIN WITH LABEL {user_label}; \n"})}),"\n",(0,a.jsx)(t.p,{children:"If this statement is executed while the current session is in the middle of a transaction, Doris will ignore the statement, which can also be understood as transactions cannot be nested."}),"\n",(0,a.jsx)(t.h3,{id:"commit-a-transaction",children:"Commit a Transaction"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"COMMIT;\n"})}),"\n",(0,a.jsx)(t.p,{children:"Used to commit all modifications made in the current transaction."}),"\n",(0,a.jsx)(t.h2,{id:"transaction-with-multiple-sql-statements",children:"Transaction with multiple sql statements"}),"\n",(0,a.jsx)(t.p,{children:"Currently, Doris supports only one way of transaction loading."}),"\n",(0,a.jsxs)(t.h3,{id:"multiple-insert-into-values-for-one-table",children:["Multiple ",(0,a.jsx)(t.code,{children:"INSERT INTO VALUES"})," for one table"]}),"\n",(0,a.jsx)(t.p,{children:"Suppose the table schema is:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'CREATE TABLE `dt` (\n    `id` INT(11) NOT NULL,\n    `name` VARCHAR(50) NULL,\n    `score` INT(11) NULL\n) ENGINE=OLAP\nUNIQUE KEY(`id`)\nDISTRIBUTED BY HASH(`id`) BUCKETS 1\nPROPERTIES (\n    "replication_num" = "1"\n);\n'})}),"\n",(0,a.jsx)(t.p,{children:"Do transaction load:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"mysql> BEGIN;\nQuery OK, 0 rows affected (0.01 sec)\n{'label':'txn_insert_b55db21aad7451b-b5b6c339704920c5', 'status':'PREPARE', 'txnId':''}\n\nmysql> INSERT INTO dt (id, name, score) VALUES (1, \"Emily\", 25), (2, \"Benjamin\", 35), (3, \"Olivia\", 28), (4, \"Alexander\", 60), (5, \"Ava\", 17);\nQuery OK, 5 rows affected (0.08 sec)\n{'label':'txn_insert_b55db21aad7451b-b5b6c339704920c5', 'status':'PREPARE', 'txnId':'10013'}\n\nmysql> INSERT INTO dt VALUES (6, \"William\", 69), (7, \"Sophia\", 32), (8, \"James\", 64), (9, \"Emma\", 37), (10, \"Liam\", 64);\nQuery OK, 5 rows affected (0.00 sec)\n{'label':'txn_insert_b55db21aad7451b-b5b6c339704920c5', 'status':'PREPARE', 'txnId':'10013'}\n\nmysql> COMMIT;\nQuery OK, 0 rows affected (1.02 sec)\n{'label':'txn_insert_b55db21aad7451b-b5b6c339704920c5', 'status':'VISIBLE', 'txnId':'10013'}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This method not only achieves atomicity, but also in Doris, it enhances the writing performance of ",(0,a.jsx)(t.code,{children:"INSERT INTO VALUES"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["If user enables ",(0,a.jsx)(t.code,{children:"Group Commit"})," and transaction insert at the same time, the transaction insert will work."]}),"\n",(0,a.jsx)(t.h4,{id:"qa",children:"QA"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Writing to multiple tables must belong to the same Database; otherwise, you will encounter the error ",(0,a.jsx)(t.code,{children:"Transaction insert must be in the same database"})]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["If the time-consuming from ",(0,a.jsx)(t.code,{children:"BEGIN"})," statement exceeds the timeout configured in Doris, the transaction will be rolled back. Currently, the timeout uses the maximum value of session variables ",(0,a.jsx)(t.code,{children:"insert_timeout"})," and ",(0,a.jsx)(t.code,{children:"query_timeout"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["When using JDBC to connect to Doris for transaction operations, please add ",(0,a.jsx)(t.code,{children:"useLocalSessionState=true"})," in the JDBC URL; otherwise, you may encounter the error ",(0,a.jsx)(t.code,{children:"This is in a transaction, only insert, update, delete, commit, rollback is acceptable"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"stream-load-2pc",children:"Stream Load 2PC"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["1. Enable two-phase commit by setting ",(0,a.jsx)(t.code,{children:"two_phase_commit:true"})," in the HTTP Header."]})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl --location-trusted -u user:passwd -H "two_phase_commit:true" -T test.txt http://fe_host:http_port/api/{db}/{table}/_stream_load\n{\n    "TxnId": 18036,\n    "Label": "55c8ffc9-1c40-4d51-b75e-f2265b3602ef",\n    "TwoPhaseCommit": "true",\n    "Status": "Success",\n    "Message": "OK",\n    "NumberTotalRows": 100,\n    "NumberLoadedRows": 100,\n    "NumberFilteredRows": 0,\n    "NumberUnselectedRows": 0,\n    "LoadBytes": 1031,\n    "LoadTimeMs": 77,\n    "BeginTxnTimeMs": 1,\n    "StreamLoadPutTimeMs": 1,\n    "ReadDataTimeMs": 0,\n    "WriteDataTimeMs": 58,\n    "CommitAndPublishTimeMs": 0\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"2. Trigger the commit operation for a transaction (can be sent to FE or BE)."})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Specify the transaction using the Transaction ID:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl -X PUT --location-trusted -u user:passwd -H "txn_id:18036" -H "txn_operation:commit" http://fe_host:http_port/api/{db}/{table}/_stream_load_2pc\n{\n    "status": "Success",\n    "msg": "transaction [18036] commit successfully."\n}\n'})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Specify the transaction using the label:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl -X PUT --location-trusted -u user:passwd -H "label:55c8ffc9-1c40-4d51-b75e-f2265b3602ef" -H "txn_operation:commit"  http://fe_host:http_port/api/{db}/{table}/_stream_load_2pc\n{\n    "status": "Success",\n    "msg": "label [55c8ffc9-1c40-4d51-b75e-f2265b3602ef] commit successfully."\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"3. Trigger the abort operation for a transaction (can be sent to FE or BE)."})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Specify the transaction using the Transaction ID:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl -X PUT --location-trusted -u user:passwd -H "txn_id:18037" -H "txn_operation:abort"  http://fe_host:http_port/api/{db}/{table}/_stream_load_2pc\n{\n    "status": "Success",\n    "msg": "transaction [18037] abort successfully."\n}\n'})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Specify the transaction using the label:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:'curl -X PUT --location-trusted -u user:passwd -H "label:55c8ffc9-1c40-4d51-b75e-f2265b3602ef" -H "txn_operation:abort"  http://fe_host:http_port/api/{db}/{table}/_stream_load_2pc\n{\n    "status": "Success",\n    "msg": "label [55c8ffc9-1c40-4d51-b75e-f2265b3602ef] abort successfully."\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"broker-load-into-muti-tables-with-a-transaction",children:"Broker Load into muti tables with a transaction"}),"\n",(0,a.jsx)(t.p,{children:"All Broker Load tasks are atomic and ensure atomicity even when loading multiple tables within the same task. The Label mechanism can be used to ensure data load without loss or duplication."}),"\n",(0,a.jsx)(t.p,{children:"The following example demonstrates loading data from HDFS by using wildcard patterns to match two sets of files and load them into two different tables."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'LOAD LABEL example_db.label2\n(\n    DATA INFILE("hdfs://hdfs_host:hdfs_port/input/file-10*")\n    INTO TABLE `my_table1`\n    PARTITION (p1)\n    COLUMNS TERMINATED BY ","\n    (k1, tmp_k2, tmp_k3)\n    SET (\n        k2 = tmp_k2 + 1,\n        k3 = tmp_k3 + 1\n    )\n    DATA INFILE("hdfs://hdfs_host:hdfs_port/input/file-20*")\n    INTO TABLE `my_table2`\n    COLUMNS TERMINATED BY ","\n    (k1, k2, k3)\n)\nWITH BROKER hdfs\n(\n    "username"="hdfs_user",\n    "password"="hdfs_password"\n);\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The wildcard pattern is used to match and load two sets of files, ",(0,a.jsx)(t.code,{children:"file-10*"})," and ",(0,a.jsx)(t.code,{children:"file-20*"}),", into ",(0,a.jsx)(t.code,{children:"my_table1"})," and ",(0,a.jsx)(t.code,{children:"my_table2"})," respectively. In the case of ",(0,a.jsx)(t.code,{children:"my_table1"}),", the load is specified to the ",(0,a.jsx)(t.code,{children:"p1"})," partition, and the values of thesecond and third columns in the source file are incremented by 1 before being loaded."]})]})}function h(e={}){let{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return l},a:function(){return o}});var s=n(667294);let a={},i=s.createContext(a);function o(e){let t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);