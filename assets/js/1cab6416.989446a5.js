"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["148095"],{606235:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>l,metadata:()=>a,assets:()=>d,toc:()=>r,contentTitle:()=>o});var a=JSON.parse('{"id":"data-operate/delete/batch-delete-manual","title":"Batch Deletion","description":"Why do we need to introduce import-based Batch Delete when we have the Delete operation?","source":"@site/versioned_docs/version-2.0/data-operate/delete/batch-delete-manual.md","sourceDirName":"data-operate/delete","slug":"/data-operate/delete/batch-delete-manual","permalink":"/docs/2.0/data-operate/delete/batch-delete-manual","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Batch Deletion","language":"en"},"sidebar":"docs","previous":{"title":"Deleting Data with DELETE Command","permalink":"/docs/2.0/data-operate/delete/delete-manual"},"next":{"title":"Deleting Data with TRUNCATE Command","permalink":"/docs/2.0/data-operate/delete/truncate-manual"}}'),s=t("785893"),i=t("250065");let l={title:"Batch Deletion",language:"en"},o=void 0,d={},r=[{value:"Fundamental",id:"fundamental",level:2},{value:"Enable Batch Delete Support",id:"enable-batch-delete-support",level:2},{value:"Syntax Description",id:"syntax-description",level:2},{value:"Stream Load",id:"stream-load",level:3},{value:"Broker Load",id:"broker-load",level:3},{value:"Routine Load",id:"routine-load",level:3},{value:"Note",id:"note",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Check if Batch Delete Support is Enabled",id:"check-if-batch-delete-support-is-enabled",level:3},{value:"Stream Load Usage Examples",id:"stream-load-usage-examples",level:3}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Why do we need to introduce import-based Batch Delete when we have the Delete operation?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Limitations of Delete operation"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When you delete by Delete statement, each execution of Delete generates an empty rowset to record the deletion conditions and a new version of the data. Each time you read, you have to filter the deletion conditions. If you delete too often or have too many deletion conditions, it will seriously affect the query performance."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Insert data interspersed with Delete data"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For scenarios like importing data from a transactional database via CDC, Insert and Delete are usually interspersed in the data. In this case, the current Delete operation cannot be implemented."}),"\n",(0,s.jsx)(n.p,{children:"When importing data, there are several ways to merge it:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"APPEND: Append all data to existing data."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["DELETE: Delete all rows that have the same value as the key column of the imported data (when a ",(0,s.jsx)(n.code,{children:"sequence"})," column exists in the table, it is necessary to satisfy the logic of having the same primary key as well as the size of the sequence column in order to delete it correctly, see Use Case 4 below for details)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"MERGE: APPEND or DELETE according to DELETE ON decision"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Warning",type:"caution",children:(0,s.jsx)(n.p,{children:"Batch Delete only works on Unique models."})}),"\n",(0,s.jsx)(n.h2,{id:"fundamental",children:"Fundamental"}),"\n",(0,s.jsxs)(n.p,{children:["This is achieved by adding a hidden column ",(0,s.jsx)(n.code,{children:"__DORIS_DELETE_SIGN__"})," to the Unique table."]}),"\n",(0,s.jsxs)(n.p,{children:["When FE parses the query, ",(0,s.jsx)(n.code,{children:"__DORIS_DELETE_SIGN__"})," is removed when it encounters * and so on, and ",(0,s.jsx)(n.code,{children:"__DORIS_DELETE_SIGN__ !"})," ",(0,s.jsx)(n.code,{children:"= true"}),", BE will add a column for judgement when reading, and determine whether to delete by the condition."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Import"}),"\n",(0,s.jsxs)(n.p,{children:["On import, the value of the hidden column is set to the value of the ",(0,s.jsx)(n.code,{children:"DELETE ON"})," expression during the FE parsing stage."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Read"}),"\n",(0,s.jsxs)(n.p,{children:["The read adds ",(0,s.jsx)(n.code,{children:"__DORIS_DELETE_SIGN__ !"})," ",(0,s.jsx)(n.code,{children:"= true"})," condition, BE does not sense this process and executes normally."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Cumulative Compaction"}),"\n",(0,s.jsx)(n.p,{children:"In Cumulative Compaction, hidden columns are treated as normal columns and the Compaction logic remains unchanged."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Base Compaction"}),"\n",(0,s.jsx)(n.p,{children:"When Base Compaction is performed, the rows marked for deletion are deleted to reduce the space occupied by the data."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"enable-batch-delete-support",children:"Enable Batch Delete Support"}),"\n",(0,s.jsx)(n.p,{children:"There are two forms of enabling Batch Delete support:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Batch Delete is supported by adding ",(0,s.jsx)(n.code,{children:"enable_batch_delete_by_default=true"})," in the FE configuration file for all new tables created after restarting FE;"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["For tables that do not have the above FE configuration changed or for existing tables that do not support Batch Delete, the following statement can be used: ",(0,s.jsx)(n.code,{children:'ALTER TABLE tablename ENABLE FEATURE "BATCH_DELETE"'})," to enable Batch Delete. This is essentially a schema change operation, which returns immediately and can be confirmed by ",(0,s.jsx)(n.code,{children:"showing alter table column"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Then how to determine whether a table supports Batch Delete, you can set a session variable to show hidden columns ",(0,s.jsx)(n.code,{children:"SET show_hidden_columns=true"}),", and after that use ",(0,s.jsx)(n.code,{children:"desc tablename"}),", if there is a ",(0,s.jsx)(n.code,{children:"__DORIS_DELETE_SIGN__"})," column in the output then it is supported, if there is not then it is not supported."]}),"\n",(0,s.jsx)(n.h2,{id:"syntax-description",children:"Syntax Description"}),"\n",(0,s.jsx)(n.p,{children:"The syntax design of the import is mainly to add a column mapping that specifies the field of the delete marker column, and it is necessary to add a column to the imported data. The syntax of various import methods is as follows:"}),"\n",(0,s.jsx)(n.h3,{id:"stream-load",children:"Stream Load"}),"\n",(0,s.jsxs)(n.p,{children:["The writing method of ",(0,s.jsx)(n.code,{children:"Stream Load"})," adds a field to set the delete label column in the columns field in the header. Example: ",(0,s.jsx)(n.code,{children:'-H "columns: k1, k2, label_c3" -H "merge_type: [MERGE|APPEND|DELETE]" -H "delete: label_c3=1"'})]}),"\n",(0,s.jsx)(n.h3,{id:"broker-load",children:"Broker Load"}),"\n",(0,s.jsxs)(n.p,{children:["The writing method of ",(0,s.jsx)(n.code,{children:"Broker Load"})," sets the field of the delete marker column at ",(0,s.jsx)(n.code,{children:"PROPERTIES"}),". The syntax is as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL db1.label1\n(\n    [MERGE|APPEND|DELETE] DATA INFILE("hdfs://abc.com:8888/user/palo/test/ml/file1")\n    INTO TABLE tbl1\n    COLUMNS TERMINATED BY ","\n    (tmp_c1,tmp_c2, label_c3)\n    SET\n    (\n        id=tmp_c2,\n        name=tmp_c1,\n    )\n    [DELETE ON label_c3=true]\n)\nWITH BROKER \'broker\'\n(\n    "username"="user",\n    "password"="pass"\n)\nPROPERTIES\n(\n    "timeout" = "3600"\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"routine-load",children:"Routine Load"}),"\n",(0,s.jsxs)(n.p,{children:["The writing method of ",(0,s.jsx)(n.code,{children:"Routine Load"})," adds a mapping to the ",(0,s.jsx)(n.code,{children:"columns"})," field. The mapping method is the same as above. The syntax is as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test1 ON example_tbl \n [WITH MERGE|APPEND|DELETE]\n COLUMNS(k1, k2, k3, v1, v2, label),\n WHERE k1  100 and k2 like "%doris%"\n [DELETE ON label=true]\n PROPERTIES\n (\n     "desired_concurrent_number"="3",\n     "max_batch_interval" = "20",\n     "max_batch_rows" = "300000",\n     "max_batch_size" = "209715200",\n     "strict_mode" = "false"\n )\n FROM KAFKA\n (\n     "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n     "kafka_topic" = "my_topic",\n     "kafka_partitions" = "0,1,2,3",\n     "kafka_offsets" = "101,0,0,200"\n );\n'})}),"\n",(0,s.jsx)(n.h2,{id:"note",children:"Note"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Since import operations other than stream load may be executed out of order inside doris, if it is not stream load when importing using the ",(0,s.jsx)(n.code,{children:"MERGE"})," method, it needs to be used with load sequence. For the specific syntax, please refer to the ",(0,s.jsx)(n.code,{children:"sequence"})," column related documents"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"DELETE ON"})," condition can only be used with MERGE."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Tip",type:"tip",children:(0,s.jsxs)(n.p,{children:["if session variable ",(0,s.jsx)(n.code,{children:"SET show_hidden_columns = true"})," was executed before running import task to show whether table support batch delete feature, then execute ",(0,s.jsx)(n.code,{children:"select count(*) from xxx"})," statement in the same session after finishing ",(0,s.jsx)(n.code,{children:"DELETE/MERGE"})," import task, it will result in a unexpected result that the statement result set will include the deleted results. To avoid this problem, you should execute ",(0,s.jsx)(n.code,{children:"SET show_hidden_columns = false"})," before selecting statement or open a new session to run the select statement."]})}),"\n",(0,s.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,s.jsx)(n.h3,{id:"check-if-batch-delete-support-is-enabled",children:"Check if Batch Delete Support is Enabled"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'mysql> CREATE TABLE IF NOT EXISTS table1 (\n    ->     siteid INT,\n    ->     citycode INT,\n    ->     username VARCHAR(64),\n    ->     pv BIGINT\n    -> ) UNIQUE KEY (siteid, citycode, username)\n    -> DISTRIBUTED BY HASH(siteid) BUCKETS 10\n    -> PROPERTIES (\n    ->     "replication_num" = "3"\n    -> );\nQuery OK, 0 rows affected (0.34 sec)\n\nmysql> SET show_hidden_columns=true;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> DESC table1;\n+-----------------------+-------------+------+-------+---------+-------+\n| Field                 | Type        | Null | Key   | Default | Extra |\n+-----------------------+-------------+------+-------+---------+-------+\n| siteid                | int         | Yes  | true  | NULL    |       |\n| citycode              | int         | Yes  | true  | NULL    |       |\n| username              | varchar(64) | Yes  | true  | NULL    |       |\n| pv                    | bigint      | Yes  | false | NULL    | NONE  |\n| __DORIS_DELETE_SIGN__ | tinyint     | No   | false | 0       | NONE  |\n| __DORIS_VERSION_COL__ | bigint      | No   | false | 0       | NONE  |\n+-----------------------+-------------+------+-------+---------+-------+\n6 rows in set (0.01 sec)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"stream-load-usage-examples",children:"Stream Load Usage Examples"}),"\n",(0,s.jsxs)(n.p,{children:['Please refer to the sections "Specifying merge_type for DELETE operations" and "Specifying merge_type for MERGE operations" in the ',(0,s.jsx)(n.a,{href:"../import/import-way/stream-load-manual.md",children:"Stream Load Manual"})]})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return l}});var a=t(667294);let s={},i=a.createContext(s);function l(e){let n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);