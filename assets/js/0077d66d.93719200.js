"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["800990"],{459388:function(e,n,s){s.r(n),s.d(n,{default:()=>h,frontMatter:()=>a,metadata:()=>i,assets:()=>d,toc:()=>c,contentTitle:()=>l});var i=JSON.parse('{"id":"sql-manual/basic-element/sql-data-types/semi-structured/VARIANT","title":"VARIANT","description":"The VARIANT type stores semi-structured JSON data. It can contain different primitive types (integers, strings, booleans, etc.), one-dimensional arrays, and nested objects. On write, Doris infers the structure and type of sub-paths based on JSON paths and materializes frequent paths as independent subcolumns, leveraging columnar storage and vectorized execution for both flexibility and performance.","source":"@site/docs/sql-manual/basic-element/sql-data-types/semi-structured/VARIANT.md","sourceDirName":"sql-manual/basic-element/sql-data-types/semi-structured","slug":"/sql-manual/basic-element/sql-data-types/semi-structured/VARIANT","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/semi-structured/VARIANT","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770477659000,"frontMatter":{"title":"VARIANT","language":"en-US","description":"The VARIANT type stores semi-structured JSON data. It can contain different primitive types (integers, strings, booleans, etc.), one-dimensional arrays, and nested objects. On write, Doris infers the structure and type of sub-paths based on JSON paths and materializes frequent paths as independent subcolumns, leveraging columnar storage and vectorized execution for both flexibility and performance."},"sidebar":"docs","previous":{"title":"JSON","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/semi-structured/JSON"},"next":{"title":"HLL (HyperLogLog)","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/aggregate/HLL"}}'),t=s("785893"),r=s("250065");let a={title:"VARIANT",language:"en-US",description:"The VARIANT type stores semi-structured JSON data. It can contain different primitive types (integers, strings, booleans, etc.), one-dimensional arrays, and nested objects. On write, Doris infers the structure and type of sub-paths based on JSON paths and materializes frequent paths as independent subcolumns, leveraging columnar storage and vectorized execution for both flexibility and performance."},l=void 0,d={},c=[{value:"VARIANT",id:"variant",level:2},{value:"Overview",id:"overview",level:2},{value:"Using VARIANT",id:"using-variant",level:2},{value:"Create table syntax",id:"create-table-syntax",level:3},{value:"Query syntax",id:"query-syntax",level:3},{value:"Primitive types",id:"primitive-types",level:2},{value:"Extended types (Schema Template)",id:"extended-types-schema-template",level:2},{value:"Type conflicts and promotion rules",id:"type-conflicts-and-promotion-rules",level:2},{value:"Variant indexes",id:"variant-indexes",level:2},{value:"Choosing indexes",id:"choosing-indexes",level:3},{value:"Index by subpath",id:"index-by-subpath",level:3},{value:"When indexes don\u2019t work",id:"when-indexes-dont-work",level:3},{value:"INSERT and load",id:"insert-and-load",level:2},{value:"INSERT INTO VALUES",id:"insert-into-values",level:3},{value:"Load (Stream Load)",id:"load-stream-load",level:3},{value:"Supported operations and CAST rules",id:"supported-operations-and-cast-rules",level:2},{value:"Wide columns",id:"wide-columns",level:2},{value:"Sparse columns",id:"sparse-columns",level:3},{value:"DOC encoding (DOC mode)",id:"doc-encoding-doc-mode",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Inspect number of columns and types",id:"inspect-number-of-columns-and-types",level:2},{value:"Compared with JSON type",id:"compared-with-json-type",level:2},{value:"FAQ",id:"faq",level:2}];function o(e){let n={br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"variant",children:"VARIANT"}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The VARIANT type stores semi-structured JSON data. It can contain different primitive types (integers, strings, booleans, etc.), one-dimensional arrays, and nested objects. On write, Doris infers the structure and type of sub-paths based on JSON paths and materializes frequent paths as independent subcolumns, leveraging columnar storage and vectorized execution for both flexibility and performance."}),"\n",(0,t.jsx)(n.h2,{id:"using-variant",children:"Using VARIANT"}),"\n",(0,t.jsx)(n.h3,{id:"create-table-syntax",children:"Create table syntax"}),"\n",(0,t.jsx)(n.p,{children:"Declare a VARIANT column when creating a table:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS ${table_name} (\n    k BIGINT,\n    v VARIANT\n)\nPROPERTIES("replication_num" = "1");\n'})}),"\n",(0,t.jsx)(n.p,{children:"Constrain certain paths with a Schema Template (see \u201CExtended types\u201D):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS ${table_name} (\n    k BIGINT,\n    v VARIANT <\n        'id' : INT,            -- restrict path id to INT\n        'message*' : STRING,   -- restrict message* prefix to STRING\n        'tags*' : ARRAY<TEXT>  -- restrict tags* prefix to ARRAY<TEXT>\n    >\n)\nPROPERTIES(\"replication_num\" = \"1\");\n"})}),"\n",(0,t.jsx)(n.h3,{id:"query-syntax",children:"Query syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"-- Access nested fields (returns VARIANT; explicit or implicit CAST is required for aggregation/comparison)\nSELECT v['properties']['title'] FROM ${table_name};\n\n-- CAST to a concrete type before aggregation\nSELECT CAST(v['properties']['title'] AS STRING) AS title\nFROM ${table_name}\nGROUP BY title;\n\n-- Query arrays\nSELECT *\nFROM ${table_name}\nWHERE ARRAY_CONTAINS(CAST(v['tags'] AS ARRAY<TEXT>), 'Doris');\n"})}),"\n",(0,t.jsx)(n.h2,{id:"primitive-types",children:"Primitive types"}),"\n",(0,t.jsx)(n.p,{children:"VARIANT infers subcolumn types automatically. Supported types include:"}),"\n",(0,t.jsx)(n.table,{children:(0,t.jsxs)(n.tbody,{children:[(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:["Supported types",(0,t.jsx)(n.br,{})]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:["TinyInt",(0,t.jsx)(n.br,{})]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:["NULL (equivalent to JSON null)",(0,t.jsx)(n.br,{})]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:["BigInt (64 bit)",(0,t.jsx)(n.br,{}),"Double",(0,t.jsx)(n.br,{})]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:["String (Text)",(0,t.jsx)(n.br,{})]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:["Jsonb",(0,t.jsx)(n.br,{})]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:["Variant (nested object)",(0,t.jsx)(n.br,{})]})}),(0,t.jsx)(n.tr,{children:(0,t.jsxs)(n.td,{children:["Array<T> (one-dimensional only)",(0,t.jsx)(n.br,{})]})})]})}),"\n",(0,t.jsx)(n.p,{children:"Simple INSERT example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"INSERT INTO vartab VALUES\n  (1, 'null'),\n  (2, NULL),\n  (3, 'true'),\n  (4, '-17'),\n  (5, '123.12'),\n  (6, '1.912'),\n  (7, '\"A quote\"'),\n  (8, '[-1, 12, false]'),\n  (9, '{ \"x\": \"abc\", \"y\": false, \"z\": 10 }'),\n  (10, '\"2021-01-01\"');\n"})}),"\n",(0,t.jsx)(n.p,{children:"Tip: Non-standard JSON types such as date/time will be stored as strings unless a Schema Template is provided. For better computation efficiency, consider extracting them to static columns or declaring their types via a Schema Template."}),"\n",(0,t.jsx)(n.h2,{id:"extended-types-schema-template",children:"Extended types (Schema Template)"}),"\n",(0,t.jsx)(n.p,{children:"Besides primitive types, VARIANT supports the following extended types via Schema Template:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Number (extended)\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Decimal: Decimal32 / Decimal64 / Decimal128 / Decimal256"}),"\n",(0,t.jsx)(n.li,{children:"LargeInt"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Datetime"}),"\n",(0,t.jsx)(n.li,{children:"Timestamptz"}),"\n",(0,t.jsx)(n.li,{children:"Date"}),"\n",(0,t.jsx)(n.li,{children:"IPV4 / IPV6"}),"\n",(0,t.jsx)(n.li,{children:"Boolean"}),"\n",(0,t.jsx)(n.li,{children:"ARRAY<T> (T can be any of the above, one-dimensional only)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Note: Predefined Schema can only be specified at table creation. ALTER is currently not supported (future versions may support adding new subcolumn definitions, but changing an existing subcolumn type is not supported)."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE test_var_schema (\n    id BIGINT NOT NULL,\n    v1 VARIANT<\n        \'large_int_val\': LARGEINT,\n        \'string_val\': STRING,\n        \'decimal_val\': DECIMAL(38, 9),\n        \'datetime_val\': DATETIME,\n        \'tz_val\': TIMESTAMPTZ,\n        \'ip_val\': IPV4\n    > NULL\n)\nPROPERTIES ("replication_num" = "1");\n\nINSERT INTO test_var_schema VALUES (1, \'{\n    "large_int_val" : "123222222222222222222222",\n    "string_val" : "Hello World",\n    "decimal_val" : 1.11111111,\n    "datetime_val" : "2025-05-16 11:11:11",\n    "tz_val" : "2025-05-16 11:11:11+08:00",\n    "ip_val" : "127.0.0.1"\n}\');\n\nSELECT variant_type(v1) FROM test_var_schema;\n\n+---------------------------------------------------------------------------------------------------------------------------------------------------+\n| variant_type(v1)                                                                                                                                  |\n+---------------------------------------------------------------------------------------------------------------------------------------------------+\n| {"datetime_val":"datetimev2","decimal_val":"decimal128i","ip_val":"ipv4","large_int_val":"largeint","string_val":"string","tz_val":"timestamptz"} |\n+---------------------------------------------------------------------------------------------------------------------------------------------------+\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'{"date": 2020-01-01}'})," and ",(0,t.jsx)(n.code,{children:'{"ip": 127.0.0.1}'})," are invalid JSON texts; the correct format is ",(0,t.jsx)(n.code,{children:'{"date": "2020-01-01"}'})," and ",(0,t.jsx)(n.code,{children:'{"ip": "127.0.0.1"}'}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Once a Schema Template is specified, if a JSON value conflicts with the declared type and cannot be converted, it will be stored as NULL. For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:'INSERT INTO test_var_schema VALUES (1, \'{\n  "decimal_val" : "1.11111111",\n  "ip_val" : "127.xxxxxx.xxxx",\n  "large_int_val" : "aaabbccc"\n}\');\n\n-- Only decimal_val remains\nSELECT * FROM test_var_schema;\n\n+------+-----------------------------+\n| id   | v1                          |\n+------+-----------------------------+\n|    1 | {"decimal_val":1.111111110} |\n+------+-----------------------------+\n'})}),"\n",(0,t.jsx)(n.p,{children:"Schema only guides the persisted storage type. During query execution, the effective type depends on actual data at runtime:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"-- At runtime v['a'] may still be STRING\nSELECT variant_type(CAST('{\"a\" : \"12345\"}' AS VARIANT<'a' : INT>)['a']);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Wildcard matching and order:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE test_var_schema (\n    id BIGINT NOT NULL,\n    v1 VARIANT<\n        'enumString*' : STRING,\n        'enum*' : ARRAY<TEXT>,\n        'ip*' : IPV6\n    > NULL\n)\nPROPERTIES (\"replication_num\" = \"1\");\n\n-- If enumString1 matches both patterns, the first matching pattern in definition order (STRING) is used\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If a column name contains ",(0,t.jsx)(n.code,{children:"*"})," and you want to match it by its literal name (not as a prefix wildcard), use:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"v1 VARIANT<\n    MATCH_NAME 'enumString*' : STRING\n> NULL\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Matched subpaths are materialized as columns by default. If too many paths match and generate excessive columns, consider enabling ",(0,t.jsx)(n.code,{children:"variant_enable_typed_paths_to_sparse"})," (see \u201CConfiguration\u201D)."]}),"\n",(0,t.jsx)(n.h2,{id:"type-conflicts-and-promotion-rules",children:"Type conflicts and promotion rules"}),"\n",(0,t.jsx)(n.p,{children:"When incompatible types appear on the same path (e.g., the same field shows up as both integer and string), the type is promoted to JSONB to avoid information loss:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:'{"a" : 12345678}\n{"a" : "HelloWorld"}\n-- a will be promoted to JSONB\n'})}),"\n",(0,t.jsx)(n.p,{children:"Promotion rules:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Source type"}),(0,t.jsx)(n.th,{children:"Current type"}),(0,t.jsx)(n.th,{children:"Final type"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"TinyInt"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"BigInt"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"BigInt"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"TinyInt"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Double"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Double"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"TinyInt"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"String"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JSONB"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"TinyInt"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Array"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JSONB"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"BigInt"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Double"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JSONB"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"BigInt"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"String"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JSONB"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"BigInt"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Array"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JSONB"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Double"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"String"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JSONB"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Double"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Array"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JSONB"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Array<Double>"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Array<String>"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Array<Jsonb>"})})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"If you need strict types (for stable indexing and storage), declare them via Schema Template."}),"\n",(0,t.jsx)(n.h2,{id:"variant-indexes",children:"Variant indexes"}),"\n",(0,t.jsx)(n.h3,{id:"choosing-indexes",children:"Choosing indexes"}),"\n",(0,t.jsx)(n.p,{children:"VARIANT supports BloomFilter and Inverted Index on subpaths."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"High-cardinality equality/IN filters: prefer BloomFilter (sparser index, better write performance)."}),"\n",(0,t.jsxs)(n.li,{children:["Tokenization/phrase/range search: use Inverted Index and set proper ",(0,t.jsx)(n.code,{children:"parser"}),"/",(0,t.jsx)(n.code,{children:"analyzer"})," properties."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:'...  \nPROPERTIES("replication_num" = "1", "bloom_filter_columns" = "v");\n\n-- Use BloomFilter for equality/IN filters\nSELECT * FROM tbl WHERE v[\'id\'] = 12345678;\nSELECT * FROM tbl WHERE v[\'id\'] IN (1, 2, 3);\n'})}),"\n",(0,t.jsx)(n.p,{children:"Once an inverted index is created on a VARIANT column, all subpaths inherit the same index properties (e.g., parser):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS tbl (\n    k BIGINT,\n    v VARIANT,\n    INDEX idx_v(v) USING INVERTED PROPERTIES(\"parser\" = \"english\")\n);\n\n-- All subpaths inherit the english parser\nSELECT * FROM tbl WHERE v['id_1'] MATCH 'Doris';\nSELECT * FROM tbl WHERE v['id_2'] MATCH 'Apache';\n"})}),"\n",(0,t.jsx)(n.h3,{id:"index-by-subpath",children:"Index by subpath"}),"\n",(0,t.jsx)(n.p,{children:"In 3.1.x/4.0 and later, you can specify index properties for certain VARIANT subpaths, and even configure both tokenized and non-tokenized inverted indexes for the same path. Path-specific indexes require the path type to be declared via Schema Template."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:'-- Common properties: field_pattern (target path), analyzer, parser, support_phrase, etc.\nCREATE TABLE IF NOT EXISTS tbl (\n    k BIGINT,\n    v VARIANT<\'content\' : STRING>,\n    INDEX idx_tokenized(v) USING INVERTED PROPERTIES("parser" = "english", "field_pattern" = "content"),\n    INDEX idx_v(v) USING INVERTED PROPERTIES("field_pattern" = "content")\n);\n\n-- v.content has both tokenized and non-tokenized inverted indexes\nSELECT * FROM tbl WHERE v[\'content\'] MATCH \'Doris\';\nSELECT * FROM tbl WHERE v[\'content\'] = \'Doris\';\n'})}),"\n",(0,t.jsx)(n.p,{children:"Wildcard path indexing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS tbl (\n    k BIGINT,\n    v VARIANT<'pattern_*' : STRING>,\n    INDEX idx_tokenized(v) USING INVERTED PROPERTIES(\"parser\" = \"english\", \"field_pattern\" = \"pattern_*\"),\n    INDEX idx_v(v) USING INVERTED -- global non-tokenized inverted index\n);\n\nSELECT * FROM tbl WHERE v['pattern_1'] MATCH 'Doris';\nSELECT * FROM tbl WHERE v['pattern_1'] = 'Doris';\n"})}),"\n",(0,t.jsx)(n.p,{children:"Note: 2.1.7+ supports only InvertedIndex V2 properties (fewer files, lower write IOPS; suitable for disaggregated storage/compute). 2.1.8+ removes offline Build Index."}),"\n",(0,t.jsx)(n.h3,{id:"when-indexes-dont-work",children:"When indexes don\u2019t work"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Type changes cause index loss: if a subpath changes to an incompatible type (e.g., INT \u2192 JSONB), the index is lost. Fix by pinning types and indexes via Schema Template."}),"\n",(0,t.jsxs)(n.li,{children:["Query type mismatch:\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"-- v['id'] is actually STRING; using INT equality causes index not to be used\nSELECT * FROM tbl WHERE v['id'] = 123456;\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Misconfigured index: indexes apply to subpaths, not the entire VARIANT column.\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"-- VARIANT itself cannot be indexed as a whole\nSELECT * FROM tbl WHERE v MATCH 'Doris';\n\n-- If whole-JSON search is needed, store a duplicate STRING column and index it\nCREATE TABLE IF NOT EXISTS tbl (\n    k BIGINT,\n    v VARIANT,\n    v_str STRING,\n    INDEX idx_v_str(v_str) USING INVERTED PROPERTIES(\"parser\" = \"english\")\n);\nSELECT * FROM tbl WHERE v_str MATCH 'Doris';\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"insert-and-load",children:"INSERT and load"}),"\n",(0,t.jsx)(n.h3,{id:"insert-into-values",children:"INSERT INTO VALUES"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS variant_tbl (\n    k BIGINT,\n    v VARIANT\n) PROPERTIES(\"replication_num\" = \"1\");\n\nINSERT INTO variant_tbl VALUES (1, '{\"a\" : 123}');\n\nselect * from variant_tbl;\n+------+-----------+\n| k    | v         |\n+------+-----------+\n|    1 | {\"a\":123} |\n+------+-----------+\n\n-- v['a'] is a VARIANT\nselect v['a'] from variant_tbl;\n+--------+\n| v['a'] |\n+--------+\n| 123    |\n+--------+\n\n-- Accessing a non-existent key returns NULL\nselect v['a']['no_such_key'] from variant_tbl;;\n+-----------------------+\n| v['a']['no_such_key'] |\n+-----------------------+\n| NULL                  |\n+-----------------------+\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"load-stream-load",children:"Load (Stream Load)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Line-delimited JSON (one JSON record per line)\ncurl --location-trusted -u root: -T gh_2022-11-07-3.json \\\n  -H "read_json_by_line:true" -H "format:json" \\\n  http://127.0.0.1:8030/api/test_variant/github_events/_stream_load\n'})}),"\n",(0,t.jsxs)(n.p,{children:["See also: ",(0,t.jsx)(n.code,{children:"https://doris.apache.org/docs/dev/data-operate/import/complex-types/variant"})]}),"\n",(0,t.jsxs)(n.p,{children:["After loading, verify with ",(0,t.jsx)(n.code,{children:"SELECT count(*)"})," or sample with ",(0,t.jsx)(n.code,{children:"SELECT * ... LIMIT 1"}),". For high-throughput ingestion, prefer RANDOM bucketing and enable Group Commit."]}),"\n",(0,t.jsx)(n.h2,{id:"supported-operations-and-cast-rules",children:"Supported operations and CAST rules"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"VARIANT cannot be compared/operated directly with other types; comparisons between two VARIANTs are not supported either."}),"\n",(0,t.jsx)(n.li,{children:"For comparison, filtering, aggregation, and ordering, CAST subpaths to concrete types (explicitly or implicitly)."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"-- Explicit CAST\nSELECT CAST(v['arr'] AS ARRAY<TEXT>) FROM tbl;\nSELECT * FROM tbl WHERE CAST(v['decimal'] AS DECIMAL(27, 9)) = 1.111111111;\nSELECT * FROM tbl WHERE CAST(v['date'] AS DATE) = '2021-01-02';\n\n-- Implicit CAST\nSELECT * FROM tbl WHERE v['bool'];\nSELECT * FROM tbl WHERE v['str'] MATCH 'Doris';\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"VARIANT itself cannot be used directly in ORDER BY, GROUP BY, as a JOIN KEY, or as an aggregate argument; CAST subpaths instead."}),"\n",(0,t.jsx)(n.li,{children:"Strings can be implicitly converted to VARIANT."}),"\n"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"VARIANT"}),(0,t.jsx)(n.th,{children:"Castable"}),(0,t.jsx)(n.th,{children:"Coercible"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ARRAY"})}),(0,t.jsx)(n.td,{children:"\u2714"}),(0,t.jsx)(n.td,{children:"\u274C"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"BOOLEAN"})}),(0,t.jsx)(n.td,{children:"\u2714"}),(0,t.jsx)(n.td,{children:"\u2714"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"DATE/DATETIME"})}),(0,t.jsx)(n.td,{children:"\u2714"}),(0,t.jsx)(n.td,{children:"\u2714"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"FLOAT"})}),(0,t.jsx)(n.td,{children:"\u2714"}),(0,t.jsx)(n.td,{children:"\u2714"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPV4/IPV6"})}),(0,t.jsx)(n.td,{children:"\u2714"}),(0,t.jsx)(n.td,{children:"\u2714"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"DECIMAL"})}),(0,t.jsx)(n.td,{children:"\u2714"}),(0,t.jsx)(n.td,{children:"\u2714"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"MAP"})}),(0,t.jsx)(n.td,{children:"\u274C"}),(0,t.jsx)(n.td,{children:"\u274C"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"TIMESTAMP"})}),(0,t.jsx)(n.td,{children:"\u2714"}),(0,t.jsx)(n.td,{children:"\u2714"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"VARCHAR"})}),(0,t.jsx)(n.td,{children:"\u2714"}),(0,t.jsx)(n.td,{children:"\u2714"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"JSON"})}),(0,t.jsx)(n.td,{children:"\u2714"}),(0,t.jsx)(n.td,{children:"\u2714"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"wide-columns",children:"Wide columns"}),"\n",(0,t.jsxs)(n.p,{children:["When ingested data contains many distinct JSON keys, VARIANT materialized subcolumns can grow rapidly; at scale this may cause metadata bloat, higher write/merge cost, and query slowdowns. To address \u201Cwide columns\u201D (too many subcolumns), VARIANT provides two mechanisms: ",(0,t.jsx)(n.strong,{children:"Sparse columns"})," and ",(0,t.jsx)(n.strong,{children:"DOC encoding"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Note: these two mechanisms are mutually exclusive\u2014enabling DOC encoding disables sparse columns, and vice versa."}),"\n",(0,t.jsx)(n.h3,{id:"sparse-columns",children:"Sparse columns"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How it works"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The system ranks paths by non-null ratio / sparsity: high-frequency (less-sparse) paths are materialized as independent subcolumns; remaining low-frequency (sparse) paths are merged and stored in sparse columns. The maximum number of materialized subcolumns is controlled by ",(0,t.jsx)(n.code,{children:"variant_max_subcolumns_count"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If a path is declared in a Schema Template, by default it will not be moved into sparse columns; set ",(0,t.jsx)(n.code,{children:"variant_enable_typed_paths_to_sparse"})," to allow typed paths to be moved into sparse columns."]}),"\n",(0,t.jsxs)(n.li,{children:["Sparse columns support sharding: distribute sparse subpaths across multiple sparse columns to reduce per-column read overhead and improve read efficiency. Use ",(0,t.jsx)(n.code,{children:"variant_sparse_hash_shard_count"})," to specify how many sparse columns are physically stored."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"When to use"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Many JSON keys overall, but queries mostly target a small subset of high-frequency fields (hot fields)."}),"\n",(0,t.jsx)(n.li,{children:"Highly skewed key distribution (a few keys appear frequently; many keys appear occasionally): you want good hot-path performance while keeping long-tail keys queryable (typically slower)."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Limitations and configuration notes"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If most keys have similar non-null ratios (little sparsity contrast), it\u2019s hard to identify truly sparse paths and the benefit of sparse columns is reduced."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"variant_max_subcolumns_count"})," (materialized subcolumns) is recommended to stay \u2264 10000."]}),"\n",(0,t.jsxs)(n.li,{children:["If you have high query requirements on typed paths (declared via Schema Template), prefer ",(0,t.jsx)(n.code,{children:"variant_enable_typed_paths_to_sparse = false"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"variant_sparse_hash_shard_count"})," can be roughly estimated as \u201Cnumber of sparse paths / 128\u201D. Example: total JSON keys \u2248 10,000, ",(0,t.jsx)(n.code,{children:"variant_max_subcolumns_count = 2000"}),", then sparse paths \u2248 8000, so ",(0,t.jsx)(n.code,{children:"variant_sparse_hash_shard_count"})," can start around ",(0,t.jsx)(n.code,{children:"8000/128"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"doc-encoding-doc-mode",children:"DOC encoding (DOC mode)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How it works"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Paths can still be materialized as independent subcolumns for path-based queries, and the original JSON is additionally stored as a stored field to return the full JSON document efficiently."}),"\n",(0,t.jsxs)(n.li,{children:["DOC encoding supports sharding: the original JSON is split into multiple columns for storage and reassembled when querying the full JSON. Use ",(0,t.jsx)(n.code,{children:"variant_doc_hash_shard_count"})," to specify the number of DOC shards."]}),"\n",(0,t.jsxs)(n.li,{children:["For small-batch writes, subcolumns can be skipped and materialized later during merges. This is controlled by ",(0,t.jsx)(n.code,{children:"variant_doc_materialization_min_rows"}),". For example, if ",(0,t.jsx)(n.code,{children:"variant_doc_materialization_min_rows = 10000"}),", writes below 10,000 rows will only store the original JSON and won\u2019t materialize subcolumns for that batch."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"When to use"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Many distinct keys overall, but each row contains only a small subset of keys (e.g. per-row keys < 5% of total keys): typical sparse wide-column workloads."}),"\n",(0,t.jsxs)(n.li,{children:["Workloads frequently need the full JSON document (e.g. ",(0,t.jsx)(n.code,{children:"SELECT *"})," / full-row return) and you want to avoid assembling JSON from a large number of subcolumns."]}),"\n",(0,t.jsx)(n.li,{children:"You want to reduce subcolumn materialization overhead for small batches and defer it to later merges."}),"\n",(0,t.jsx)(n.li,{children:"You can accept additional storage cost (because the original JSON is stored as a stored field)."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Limitations and configuration notes"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["DOC mode requires ",(0,t.jsx)(n.code,{children:"variant_enable_doc_mode = true"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"In DOC mode, typed paths declared via Schema Template are limited to numeric, string, and array types."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"variant_doc_hash_shard_count"})," can be roughly estimated as \u201Ctotal JSON keys / 128\u201D."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"See the \u201CConfiguration\u201D section below for the full property list."}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Wide tables optimization"}),": For wide tables with a large number of dynamic sub-columns (e.g., more than 2000 columns) generated by the ",(0,t.jsx)(n.code,{children:"VARIANT"})," type, it is highly recommended to enable ",(0,t.jsx)(n.strong,{children:"Storage Format V3"})," by specifying ",(0,t.jsx)(n.code,{children:'"storage_format" = "V3"'})," in the table ",(0,t.jsx)(n.code,{children:"PROPERTIES"}),". This decouples column metadata from the Segment Footer, speeding up file opening and reducing memory overhead."]}),"\n",(0,t.jsx)(n.li,{children:"JSON key length \u2264 255."}),"\n",(0,t.jsx)(n.li,{children:"Cannot be a primary key or sort key."}),"\n",(0,t.jsxs)(n.li,{children:["Cannot be nested within other types (e.g., ",(0,t.jsx)(n.code,{children:"Array<Variant>"}),", ",(0,t.jsx)(n.code,{children:"Struct<Variant>"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Reading the entire VARIANT column scans all subpaths. If a column has many subpaths, consider storing the original JSON string in an extra STRING/JSONB column for whole-object searches like ",(0,t.jsx)(n.code,{children:"LIKE"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE example_table (\n  id INT,\n  data_variant VARIANT\n);\nSELECT * FROM example_table WHERE data_variant LIKE '%doris%';\n\n-- Better: keep the original JSON string for whole-object matching\nCREATE TABLE example_table (\n  id INT,\n  data_string STRING,\n  data_variant VARIANT\n);\nSELECT * FROM example_table WHERE data_string LIKE '%doris%';\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Starting from 3.1+, VARIANT supports type-level properties on columns:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE example_table (\n  id INT,\n  data_variant VARIANT<\n      'path_1' : INT,\n      'path_2' : STRING,\n      properties(\n          'variant_max_subcolumns_count' = '2048',\n          'variant_enable_typed_paths_to_sparse' = 'true',\n          'variant_sparse_hash_shard_count' = '64'\n      )\n  >\n);\n"})}),"\n",(0,t.jsx)(n.table,{children:(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Property"}),(0,t.jsx)(n.td,{children:"Description"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"`variant_max_subcolumns_count`"}),(0,t.jsx)(n.td,{children:"Max number of materialized paths. Above the threshold, new paths may be stored in a shared data structure. Default: 2048 (Recommended). 0 means no limit; do not exceed 10000."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"`variant_enable_typed_paths_to_sparse`"}),(0,t.jsx)(n.td,{children:"By default, typed paths are always materialized (and do not count against `variant_max_subcolumns_count`). When set to `true`, typed paths also count toward the threshold and may be moved to the shared structure."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"`variant_sparse_hash_shard_count`"}),(0,t.jsx)(n.td,{children:"Shard count for sparse columns. Distributes sparse subpaths across multiple sparse columns to improve read performance. Default: 1; tune based on the number of sparse subpaths."})]})]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE example_table (\n  id INT,\n  data_variant VARIANT<\n      'path_1' : INT,\n      'path_2' : STRING,\n      properties(\n          'variant_enable_doc_mode' = 'true',\n          'variant_doc_materialization_min_rows' = '10000',\n          'variant_doc_hash_shard_count' = '64'\n      )\n  >\n);\n"})}),"\n",(0,t.jsx)(n.table,{children:(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Property"}),(0,t.jsx)(n.td,{children:"Description"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"`variant_enable_doc_mode`"}),(0,t.jsx)(n.td,{children:"Enable DOC encoding mode. When `true`, the original JSON is stored as a stored field to quickly return the whole JSON document. DOC mode is mutually exclusive with sparse columns. Default: `false`."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"`variant_doc_materialization_min_rows`"}),(0,t.jsx)(n.td,{children:"Minimum row threshold to materialize subcolumns in DOC mode. When rows are below this value, only the original JSON is stored; after compaction merges files to reach the threshold, subcolumns are materialized. Helps reduce overhead for small-batch writes."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"`variant_doc_hash_shard_count`"}),(0,t.jsx)(n.td,{children:"Shard count for DOC encoding. The original JSON is split into the specified number of columns for storage and reassembled when querying the whole JSON. Default: 64; tune based on JSON size and concurrency."})]})]})}),"\n",(0,t.jsx)(n.p,{children:"Behavior at limits and tuning suggestions:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"After exceeding the threshold, new paths are written into the shared structure; Rowset merges may also recycle some paths into the shared structure."}),"\n",(0,t.jsx)(n.li,{children:"The system prefers to keep paths with higher non-null ratios and higher access frequencies materialized."}),"\n",(0,t.jsx)(n.li,{children:"Close to 10,000 materialized paths requires strong hardware (\u2265128G RAM, \u226532C per node recommended)."}),"\n",(0,t.jsxs)(n.li,{children:["Ingestion tuning: increase client ",(0,t.jsx)(n.code,{children:"batch_size"})," appropriately, or use Group Commit (increase ",(0,t.jsx)(n.code,{children:"group_commit_interval_ms"}),"/",(0,t.jsx)(n.code,{children:"group_commit_data_bytes"})," as needed)."]}),"\n",(0,t.jsx)(n.li,{children:"If partition pruning is not needed, consider RANDOM bucketing and enabling single-tablet loading to reduce compaction write amplification."}),"\n",(0,t.jsxs)(n.li,{children:["BE tuning knobs: ",(0,t.jsx)(n.code,{children:"max_cumu_compaction_threads"})," (\u22658), ",(0,t.jsx)(n.code,{children:"vertical_compaction_num_columns_per_group=500"})," (improves vertical compaction but increases memory), ",(0,t.jsx)(n.code,{children:"segment_cache_memory_percentage=20"})," (improves metadata cache efficiency)."]}),"\n",(0,t.jsx)(n.li,{children:"Watch Compaction Score; if it keeps rising, compaction is lagging\u2014reduce ingestion pressure."}),"\n",(0,t.jsxs)(n.li,{children:["Avoid large ",(0,t.jsx)(n.code,{children:"SELECT *"})," on VARIANT; prefer specific projections like ",(0,t.jsx)(n.code,{children:"SELECT v['path']"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note: If you see Stream Load error ",(0,t.jsx)(n.code,{children:"[DATA_QUALITY_ERROR]Reached max column size limit 2048"})," (only on 2.1.x and 3.0.x), it means the merged tablet schema reached its column limit. You may increase ",(0,t.jsx)(n.code,{children:"variant_max_merged_tablet_schema_size"})," (not recommended beyond 4096; requires strong hardware)."]}),"\n",(0,t.jsx)(n.h2,{id:"inspect-number-of-columns-and-types",children:"Inspect number of columns and types"}),"\n",(0,t.jsxs)(n.p,{children:["Approach 1: use ",(0,t.jsx)(n.code,{children:"variant_type"})," to inspect per-row schema (more precise, higher cost):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SELECT variant_type(v) FROM variant_tbl;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Approach 2: extended ",(0,t.jsx)(n.code,{children:"DESC"})," to show materialized subpaths (only those extracted):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"SET describe_extend_variant_column = true;\nDESC variant_tbl;\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"DESCRIBE ${table_name} PARTITION ($partition_name);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Use both: Approach 1 is precise; Approach 2 is efficient."}),"\n",(0,t.jsx)(n.h2,{id:"compared-with-json-type",children:"Compared with JSON type"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Storage: JSON is stored as JSONB (row-oriented). VARIANT is inferred and materialized into columns on write (higher compression, smaller size)."}),"\n",(0,t.jsx)(n.li,{children:"Query: JSON requires parsing. VARIANT scans columns directly and is usually much faster."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"ClickBench (43 queries):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Storage: VARIANT saves ~65% vs JSON."}),"\n",(0,t.jsx)(n.li,{children:"Query: VARIANT is 8x+ faster than JSON, close to predefined static columns."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Storage space"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Size"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Predefined columns"}),(0,t.jsx)(n.td,{children:"12.618 GB"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"VARIANT"}),(0,t.jsx)(n.td,{children:"12.718 GB"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"JSON"}),(0,t.jsx)(n.td,{children:"35.711 GB"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"~65% space savings"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Run"}),(0,t.jsx)(n.th,{children:"Predefined"}),(0,t.jsx)(n.th,{children:"VARIANT"}),(0,t.jsx)(n.th,{children:"JSON"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"First (cold)"}),(0,t.jsx)(n.td,{children:"233.79s"}),(0,t.jsx)(n.td,{children:"248.66s"}),(0,t.jsx)(n.td,{children:"Most timed out"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Second (hot)"}),(0,t.jsx)(n.td,{children:"86.02s"}),(0,t.jsx)(n.td,{children:"94.82s"}),(0,t.jsx)(n.td,{children:"789.24s"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Third (hot)"}),(0,t.jsx)(n.td,{children:"83.03s"}),(0,t.jsx)(n.td,{children:"92.29s"}),(0,t.jsx)(n.td,{children:"743.69s"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Are ",(0,t.jsx)(n.code,{children:"null"})," in VARIANT and SQL ",(0,t.jsx)(n.code,{children:"NULL"})," different?\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No. They are equivalent."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Why doesn\u2019t my query/index work?\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Check whether you CAST paths to the correct types; whether the type was promoted to JSONB due to conflicts; or whether you mistakenly expect an index on the whole VARIANT instead of on subpaths."}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},250065:function(e,n,s){s.d(n,{Z:function(){return l},a:function(){return a}});var i=s(667294);let t={},r=i.createContext(t);function a(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);