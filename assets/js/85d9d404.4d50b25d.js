"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["545733"],{637339:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return o},default:function(){return h},frontMatter:function(){return r},metadata:function(){return n},toc:function(){return l}});var n=a(968590),s=a(785893),i=a(250065);let r={title:"Is your latest data really the latest? check the data update mechanism of your database",description:"This is about how to support both row update and partial column update in a database in a way that is simple in execution and efficient in data quality guarantee.",date:"2023-07-24",author:"Apache Doris",tags:["Tech Sharing"],image:"/images/check-the-data-update-mechanism-of-your-database.jpg"},o=void 0,d={authorsImageUrls:[void 0]},l=[{value:"Row Update",id:"row-update",level:2},{value:"Partial Column Update",id:"partial-column-update",level:2},{value:"Order of Data Updates",id:"order-of-data-updates",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){let t={a:"a",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"In databases, data update is to add, delete, or modify data. Timely data update is an important part of high quality data services."}),"\n",(0,s.jsxs)(t.p,{children:["Technically speaking, there are two types of data updates: you either update a whole row (",(0,s.jsx)(t.strong,{children:"Row Update"}),") or just update part of the columns (",(0,s.jsx)(t.strong,{children:"Partial Column Update"}),"). Many databases supports both of them, but in different ways. This post is about one of them, which is simple in execution and efficient in data quality guarantee."]}),"\n",(0,s.jsxs)(t.p,{children:["As an open source analytic database, Apache Doris supports both Row Update and Partial Column Update with one data model: the ",(0,s.jsx)(t.a,{href:"https://doris.apache.org/docs/dev/data-table/data-model#unique-model",children:(0,s.jsx)(t.strong,{children:"Unique Key Model"})}),". It is where you put data that doesn't need to be aggregated. In the Unique Key Model, you can specify one column or the combination of several columns as the Unique Key (a.k.a. Primary Key). For one Unique Key, there will always be one row of data: the newly ingested data record replaces the old. That's how data updates work."]}),"\n",(0,s.jsx)(t.p,{children:"The idea is straightforward, but in real-life implementation, it happens that the latest data does not arrive the last or doesn't even get written at all, so I'm going to show you how Apache Doris implements data update and avoids messups with its Unique Key Model."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"data-update",src:a(176835).Z+"",width:"1280",height:"705"})}),"\n",(0,s.jsx)(t.h2,{id:"row-update",children:"Row Update"}),"\n",(0,s.jsxs)(t.p,{children:["For data writing to the Unique Key Model, Apache Doris adopts the ",(0,s.jsx)(t.strong,{children:"Upsert"})," semantics, which means ",(0,s.jsx)(t.strong,{children:"Update or Insert"}),". If the new data record includes a Unique Key that already exists in the table, the new record will replace the old record; if it includes a brand new Unique Key, the new record will be inserted into the table as a whole. The Upsert operation can provide high throughput and guarantee data reliability."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Example"}),":"]}),"\n",(0,s.jsxs)(t.p,{children:["In the following table, the Unique Key is the combination of three columns: ",(0,s.jsx)(t.code,{children:"user_id, date, group_id"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-SQL",children:"mysql> desc test_table;\n+-------------+--------------+------+-------+---------+-------+\n| Field       | Type         | Null | Key   | Default | Extra |\n+-------------+--------------+------+-------+---------+-------+\n| user_id     | BIGINT       | Yes  | true  | NULL    |       |\n| date        | DATE         | Yes  | true  | NULL    |       |\n| group_id    | BIGINT       | Yes  | true  | NULL    |       |\n| modify_date | DATE         | Yes  | false | NULL    | NONE  |\n| keyword     | VARCHAR(128) | Yes  | false | NULL    | NONE  |\n+-------------+--------------+------+-------+---------+-------+\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Execute ",(0,s.jsx)(t.code,{children:"insert into"})," to write in a data record. Since the table was empty, by the Upsert semantics, it means to add a new row to the table."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-SQL",children:"mysql> insert into test_table values (1, \"2023-04-28\", 2, \"2023-04-28\", \"foo\");\nQuery OK, 1 row affected (0.05 sec)\n{'label':'insert_2fb45d1833db4348_b612b8791c97b467', 'status':'VISIBLE', 'txnId':'343'}\n\nmysql> select * from test_table;\n+---------+------------+----------+-------------+---------+\n| user_id | date       | group_id | modify_date | keyword |\n+---------+------------+----------+-------------+---------+\n|       1 | 2023-04-28 |        2 | 2023-04-28  | foo     |\n+---------+------------+----------+-------------+---------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"Then insert two more data records, one of which has the same Unique Key with the previously inserted row. Now, by the Upsert semantics, it means to replace the old row with the new one of the same Unique Key, and insert the record of the new Unique Key."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-SQL",children:"mysql> insert into test_table values (1, \"2023-04-28\", 2, \"2023-04-29\", \"foo\"), (2, \"2023-04-29\", 2, \"2023-04-29\", \"bar\");\nQuery OK, 2 rows affected (0.04 sec)\n{'label':'insert_7dd3954468aa4ac1_a63a3852e3573b4c', 'status':'VISIBLE', 'txnId':'344'}\n\nmysql> select * from test_table;\n+---------+------------+----------+-------------+---------+\n| user_id | date       | group_id | modify_date | keyword |\n+---------+------------+----------+-------------+---------+\n|       2 | 2023-04-29 |        2 | 2023-04-29  | bar     |\n|       1 | 2023-04-28 |        2 | 2023-04-29  | foo     |\n+---------+------------+----------+-------------+---------+\n"})}),"\n",(0,s.jsx)(t.h2,{id:"partial-column-update",children:"Partial Column Update"}),"\n",(0,s.jsx)(t.p,{children:"Besides row update, under many circumstances, data analysts require the convenience of partial column update. For example, in user portraits, they would like to update certain dimensions of their users in real time. Or, if they need to maintain a flat table that is made of data from various source tables, they will prefer partial column update than complicated join operations as a way of data update."}),"\n",(0,s.jsx)(t.p,{children:"Apache Doris supports partial column update with the UPDATE statement. It filters the rows that need to be modified, read them, changes a few values, and write the rows back to the table."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(t.p,{children:"Suppose that there is an order table, in which the Order ID is the Unique Key."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-SQL",children:"+----------+--------------+-----------------+\n| order_id | order_amount | order_status    |\n+----------+--------------+-----------------+\n| 1        |          100 | Payment Pending |\n+----------+--------------+-----------------+\n1 row in set (0.01 sec)\n"})}),"\n",(0,s.jsx)(t.p,{children:'When the buyer completes the payment, Apache Doris should change the order status of Order ID 1 from "Payment Pending" to "Delivery Pending". This is when the Update command comes into play.'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-SQL",children:"mysql> UPDATE test_order SET order_status = 'Delivery Pending' WHERE order_id = 1;\nQuery OK, 1 row affected (0.11 sec)\n{'label':'update_20ae22daf0354fe0-b5aceeaaddc666c5', 'status':'VISIBLE', 'txnId':'33', 'queryId':'20ae22daf0354fe0-b5aceeaaddc666c5'}\n"})}),"\n",(0,s.jsx)(t.p,{children:"This is the table after updating."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-SQL",children:"+----------+--------------+------------------+\n| order_id | order_amount | order_status     |\n+----------+--------------+------------------+\n| 1        |          100 | Delivery Pending |\n+----------+--------------+------------------+\n1 row in set (0.01 sec)\n"})}),"\n",(0,s.jsx)(t.p,{children:"The execution of the Update command consists of three steps in the system:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Step One: Read the row where Order ID = 1 (1, 100, 'Payment Pending')"}),"\n",(0,s.jsx)(t.li,{children:'Step Two: Modify the order status from "Payment Pending" to "Delivery Pending" (1, 100, \'Delivery Pending\')'}),"\n",(0,s.jsx)(t.li,{children:"Step Three: Insert the new row into the table"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"partial-column-update-1",src:a(79422).Z+"",width:"1484",height:"296"})}),"\n",(0,s.jsx)(t.p,{children:"The table is in the Unique Key Model, which means for rows of the same Unique Key, only the last inserted one will be reserved, so this is what the table will finally look like:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"partial-column-update-2",src:a(368236).Z+"",width:"1500",height:"260"})}),"\n",(0,s.jsx)(t.h2,{id:"order-of-data-updates",children:"Order of Data Updates"}),"\n",(0,s.jsx)(t.p,{children:"So far this sounds simple, but in the actual world, data update might fail due to reasons such as data format errors, and thus mess up the data writing order. The order of data update matters more than you imagine. For example, in financial transactions, messed-up data writing order might lead to transaction data losses, errors, or duplication, which further leads to bigger problems."}),"\n",(0,s.jsx)(t.p,{children:"Apache Doris provides two options for users to guarantee that their data is updated in the correct order:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"1. Update by the order of transaction commit"})}),"\n",(0,s.jsx)(t.p,{children:"In Apache Doris, each data ingestion task is a transaction. Each successfully ingested task will be given a data version and the number of data versions is strictly increasing. If the ingestion fails, the transaction will be rolled back, and no new data version will be generated."}),"\n",(0,s.jsx)(t.p,{children:"By default, the Upsert semantics follows the order of the transaction commits. If there are two data ingestion tasks involving the same Unique Key, the first task generating data version 2 and the second, data version 3, then according to transaction commit order, data version 3 will replace data version 2."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"2. Update by the user-defined order"})}),"\n",(0,s.jsx)(t.p,{children:"In real-time data analytics, data updates often happen in high concurrency. It is possible that there are multiple data ingestion tasks updating the same row, but these tasks are committed in unknown order, so the last saved update remains unknown, too."}),"\n",(0,s.jsxs)(t.p,{children:['For example, these are two data updates, with "2023-04-30" and "2023-05-01" as the ',(0,s.jsx)(t.code,{children:"modify_data"}),', respectively. If they are written into the system concurrently, but the "2023-05-01" one is successfully committed first and the other later, then the "2023-04-30" record will be saved due to its higher data version number, but we know it is not the latest one.']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Plain",children:"mysql> insert into test_table values (2, \"2023-04-29\", 2, \"2023-05-01\", \"bbb\");\nQuery OK, 1 row affected (0.04 sec)\n{'label':'insert_e2daf8cea5524ee1_94e5c87e7bb74d67', 'status':'VISIBLE', 'txnId':'345'}\n\nmysql> insert into test_table values (2, \"2023-04-29\", 2, \"2023-04-30\", \"aaa\");\nQuery OK, 1 row affected (0.03 sec)\n{'label':'insert_ef906f685a7049d0_b135b6cfee49fb98', 'status':'VISIBLE', 'txnId':'346'}\n\nmysql> select * from test_table;\n+---------+------------+----------+-------------+---------+\n| user_id | date       | group_id | modify_date | keyword |\n+---------+------------+----------+-------------+---------+\n|       2 | 2023-04-29 |        2 | 2023-04-30 | aaa     |\n|       1 | 2023-04-28 |        2 | 2023-04-29  | foo     |\n+---------+------------+----------+-------------+---------+\n"})}),"\n",(0,s.jsx)(t.p,{children:"That's why in high-concurrency scenarios, Apache Doris allows data update in user-defined order. Users can designate a column to the Sequence Column. In this way, the system will identity save the latest data version based on value in the Sequence Column."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example:"})}),"\n",(0,s.jsxs)(t.p,{children:["You can designate a Sequence Column by specifying the ",(0,s.jsx)(t.code,{children:"function_column.sequence_col"})," property upon table creation."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-SQL",children:'CREATE TABLE test.test_table\n(\n    user_id bigint,\n    date date,\n    group_id bigint,\n    modify_date date,\n    keyword VARCHAR(128)\n)\nUNIQUE KEY(user_id, date, group_id)\nDISTRIBUTED BY HASH (user_id) BUCKETS 32\nPROPERTIES(\n    "function_column.sequence_col" = \'modify_date\',\n    "replication_num" = "1",\n    "in_memory" = "false"\n);\n'})}),"\n",(0,s.jsx)(t.p,{children:"Then check and see, the data record with the highest value in the Sequence Column will be saved:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-SQL",children:"mysql> insert into test_table values (2, \"2023-04-29\", 2, \"2023-05-01\", \"bbb\");\nQuery OK, 1 row affected (0.03 sec)\n{'label':'insert_3aac37ae95bc4b5d_b3839b49a4d1ad6f', 'status':'VISIBLE', 'txnId':'349'}\n\nmysql> insert into test_table values (2, \"2023-04-29\", 2, \"2023-04-30\", \"aaa\");\nQuery OK, 1 row affected (0.03 sec)\n{'label':'insert_419d4008768d45f3_a6912e584cf1b500', 'status':'VISIBLE', 'txnId':'350'}\n\nmysql> select * from test_table;\n+---------+------------+----------+-------------+---------+\n| user_id | date       | group_id | modify_date | keyword |\n+---------+------------+----------+-------------+---------+\n|       2 | 2023-04-29 |        2 | 2023-05-01  | bbb     |\n|       1 | 2023-04-28 |        2 | 2023-04-29  | foo     |\n+---------+------------+----------+-------------+---------+\n"})}),"\n",(0,s.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(t.p,{children:["Congratulations. Now you've gained an overview of how data updates are implemented in Apache Doris. With this knowledge, you can basically guarantee efficiency and accuracy of data updating. But wait, there is so much more about that. As Apache Doris 2.0 is going to provide more powerful Partial Column Update capabilities, with improved execution of the Update statement and the support for more complicated multi-table Join queries, I will show you how to take advantage of them in details in my follow-up writings. ",(0,s.jsx)(t.a,{href:"https://join.slack.com/t/apachedoriscommunity/shared_invite/zt-2unfw3a3q-MtjGX4pAd8bCGC1UV0sKcw",children:"We"})," are constantly updating our data updates!"]})]})}function h(e={}){let{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},176835:function(e,t,a){a.d(t,{Z:function(){return n}});let n=a.p+"assets/images/Dataupdate_1-f213a24dcaaac700ff9f45906687c4a9.png"},79422:function(e,t,a){a.d(t,{Z:function(){return n}});let n=a.p+"assets/images/Dataupdate_2-9a653bfdd528301c5b147351f157da3a.png"},368236:function(e,t,a){a.d(t,{Z:function(){return n}});let n=a.p+"assets/images/Dataupdate_3-0af75c350522fdc2c1074db4b2235711.png"},250065:function(e,t,a){a.d(t,{Z:function(){return o},a:function(){return r}});var n=a(667294);let s={},i=n.createContext(s);function r(e){let t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(i.Provider,{value:t},e.children)}},968590:function(e){e.exports=JSON.parse('{"permalink":"/blog/Is-Your-Latest-Data-Really-the-Latest-Check-the-Data-Update-Mechanism-of-Your-Database","source":"@site/blog/Is-Your-Latest-Data-Really-the-Latest-Check-the-Data-Update-Mechanism-of-Your-Database.md","title":"Is your latest data really the latest? check the data update mechanism of your database","description":"This is about how to support both row update and partial column update in a database in a way that is simple in execution and efficient in data quality guarantee.","date":"2023-07-24T00:00:00.000Z","tags":[{"inline":true,"label":"Tech Sharing","permalink":"/blog/tags/tech-sharing"}],"hasTruncateMarker":false,"authors":[{"name":"Apache Doris","key":null,"page":null}],"frontMatter":{"title":"Is your latest data really the latest? check the data update mechanism of your database","description":"This is about how to support both row update and partial column update in a database in a way that is simple in execution and efficient in data quality guarantee.","date":"2023-07-24","author":"Apache Doris","tags":["Tech Sharing"],"image":"/images/check-the-data-update-mechanism-of-your-database.jpg"},"unlisted":false,"prevItem":{"title":"For entry-level data engineers: how to build a simple but solid data architecture","permalink":"/blog/For-Entry-Level-Data-Engineers-How-to-Build-a-Simple-but-Solid-Data-Architecture"},"nextItem":{"title":"Apache Doris announced the official release of version 1.2.6","permalink":"/blog/release-note-1.2.6"}}')}}]);