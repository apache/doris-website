"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["368876"],{94074:function(e,n,i){i.r(n),i.d(n,{default:()=>h,frontMatter:()=>r,metadata:()=>t,assets:()=>l,toc:()=>d,contentTitle:()=>s});var t=JSON.parse('{"id":"design/doris_storage_optimization","title":"Doris Storage File Format Optimization","description":"\x3c!--","source":"@site/community/design/doris_storage_optimization.md","sourceDirName":"design","slug":"/design/doris_storage_optimization","permalink":"/community/design/doris_storage_optimization","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Doris Storage File Format Optimization","language":"en"},"sidebar":"community","previous":{"title":"Security","permalink":"/community/security"},"next":{"title":"GROUPING SETS Design","permalink":"/community/design/grouping_sets_design"}}'),o=i("785893"),a=i("250065");let r={title:"Doris Storage File Format Optimization",language:"en"},s="Doris Storage File Format Optimization",l={},d=[{value:"File format",id:"file-format",level:2},{value:"DataPage",id:"datapage",level:3},{value:"Bloom Filter Pages",id:"bloom-filter-pages",level:3},{value:"Ordinal Index Page",id:"ordinal-index-page",level:3},{value:"Short Key Index page",id:"short-key-index-page",level:3},{value:"Column&#39;s other indexes",id:"columns-other-indexes",level:3},{value:"Metadata Definition",id:"metadata-definition",level:3},{value:"Read-write logic",id:"read-write-logic",level:2},{value:"Write",id:"write",level:3},{value:"Read",id:"read",level:3},{value:"Coding",id:"coding",level:2},{value:"Compression",id:"compression",level:2},{value:"TODO",id:"todo",level:2}];function c(e){let n={center:"center",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"doris-storage-file-format-optimization",children:"Doris Storage File Format Optimization"})}),"\n",(0,o.jsx)(n.h2,{id:"file-format",children:"File format"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:i(688574).Z+"",width:"640",height:"825"})}),"\n",(0,o.jsx)(n.center,{children:"1. doris segment"}),"\n",(0,o.jsx)(n.p,{children:"Documents include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The file starts with an 8-byte magic code to identify the file format and version"}),"\n",(0,o.jsx)(n.li,{children:"Data Region: Used to store data information for each column, where the data is loaded on demand by pages."}),"\n",(0,o.jsx)(n.li,{children:"Index Region: Doris stores the index data of each column in Index Region, where the data is loaded according to column granularity, so the data information of the following column is stored separately."}),"\n",(0,o.jsxs)(n.li,{children:["Footer\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"FileFooterPB: Metadata Information for Definition Files"}),"\n",(0,o.jsx)(n.li,{children:"Checksum of 4 bytes of footer Pb content"}),"\n",(0,o.jsx)(n.li,{children:"Four bytes FileFooterPB message length for reading FileFooterPB"}),"\n",(0,o.jsx)(n.li,{children:"The 8 byte MAGIC CODE is stored in the last bit to facilitate the identification of file types in different scenarios."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The data in the file is organized in the form of page, which is the basic unit of coding and compression. Current page types include the following:"}),"\n",(0,o.jsx)(n.h3,{id:"datapage",children:"DataPage"}),"\n",(0,o.jsx)(n.p,{children:"Data Page is divided into two types: nullable and non-nullable data pages."}),"\n",(0,o.jsx)(n.p,{children:"Nullable's data page includes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"\n                 +----------------+\n                 |  value count   |\n                 |----------------|\n                 |  first row id  |\n                 |----------------|\n                 | bitmap length  |\n                 |----------------|\n                 |  null bitmap   |\n                 |----------------|\n                 |     data       |\n                 |----------------|\n                 |    checksum    |\n                 +----------------+\n"})}),"\n",(0,o.jsx)(n.p,{children:"non -zero data page32467;- 26500;- 229140;-"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"                 |----------------|\n                 |   value count  |\n                 |----------------|\n                 |  first row id  |\n                 |----------------|\n                 |     data       |\n                 |----------------|\n                 |    checksum    |\n                 +----------------+\n"})}),"\n",(0,o.jsx)(n.p,{children:"The meanings of each field are as follows:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["value count\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Represents the number of rows in a page"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["First row id\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Line number of the first line in page"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["bitmap length\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Represents the number of bytes in the next bitmap"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["null bitmap\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"bitmap representing null information"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Data\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Store data after encoding and compress"}),"\n",(0,o.jsx)(n.li,{children:"You need to write in the header information of the data: is_compressed"}),"\n",(0,o.jsx)(n.li,{children:"Various kinds of data encoded by different codes need to write some field information in the header information in order to achieve data parsing."}),"\n",(0,o.jsx)(n.li,{children:"TODO: Add header information for various encodings"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Checksum\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Store page granularity checksum, including page header and subsequent actual data"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"bloom-filter-pages",children:"Bloom Filter Pages"}),"\n",(0,o.jsx)(n.p,{children:"For each bloom filter column, a page of the bloom filter is generated corresponding to the granularity of the page and saved in the bloom filter pages area."}),"\n",(0,o.jsx)(n.h3,{id:"ordinal-index-page",children:"Ordinal Index Page"}),"\n",(0,o.jsx)(n.p,{children:"For each column, a sparse index of row numbers is established according to page granularity. The content is a pointer to the block (including offset and length) for the line number of the start line of the page"}),"\n",(0,o.jsx)(n.h3,{id:"short-key-index-page",children:"Short Key Index page"}),"\n",(0,o.jsx)(n.p,{children:"We generate a sparse index of short key every N rows (configurable) with the contents of short key - > line number (ordinal)"}),"\n",(0,o.jsx)(n.h3,{id:"columns-other-indexes",children:"Column's other indexes"}),"\n",(0,o.jsx)(n.p,{children:"The format design supports the subsequent expansion of other index information, such as inverted index, spatial index, etc. It only needs to write the required data to the existing column data, and add the corresponding metadata fields to FileFooterPB."}),"\n",(0,o.jsx)(n.h3,{id:"metadata-definition",children:"Metadata Definition"}),"\n",(0,o.jsx)(n.p,{children:"SegmentFooterPB is defined as:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"message ColumnPB {\n    required int32 unique_id = 1;   // The column id is used here, and the column name is not used\n    optional string name = 2;   // Column name,  when name equals __DORIS_DELETE_SIGN__, this column is a hidden delete column\n    required string type = 3;   // Column type\n    optional bool is_key = 4;   // Whether column is a primary key column\n    optional string aggregation = 5;    // Aggregate type\n    optional bool is_nullable = 6;      // Whether column is allowed to assign null\n    optional bytes default_value = 7;   // Default value\n    optional int32 precision = 8;       // Precision of column\n    optional int32 frac = 9;\n    optional int32 length = 10;         // Length of column\n    optional int32 index_length = 11;   // Length of column index\n    optional bool is_bf_column = 12;    // Whether column has bloom filter index\n    optional bool has_bitmap_index = 15 [default=false];  // Whether column has bitmap index\n}\n\n// page offset\nmessage PagePointerPB {\n	required uint64 offset; // offset of page in segment file\n	required uint32 length; // length of page\n}\n\nmessage MetadataPairPB {\n  optional string key = 1;\n  optional bytes value = 2;\n}\n\nmessage ColumnMetaPB {\n	optional ColumnMessage encoding; // Encoding of column\n\n	optional PagePointerPB dict_page // Dictionary page\n	repeated PagePointerPB bloom_filter_pages; // Bloom filter pages\n	optional PagePointerPB ordinal_index_page; // Ordinal index page\n	optional PagePointerPB page_zone_map_page; // Page level of statistics index data\n\n	optional PagePointerPB bitmap_index_page; // Bitmap index page\n\n	optional uint64 data_footprint; // The size of the index in the column\n	optional uint64 index_footprint; // The size of the data in the column\n	optional uint64 raw_data_footprint; // Original column data size\n\n	optional CompressKind compress_kind; // Column compression type\n\n	optional ZoneMapPB column_zone_map; // Segment level of statistics index data\n	repeated MetadataPairPB column_meta_datas;\n}\n\nmessage SegmentFooterPB {\n	optional uint32 version = 2 [default = 1]; // For version compatibility and upgrade use\n	repeated ColumnPB schema = 5; // Schema of columns\n  optional uint64 num_values = 4; // Number of lines saved in the file\n  optional uint64 index_footprint = 7; // Index size\n  optional uint64 data_footprint = 8; // Data size\n	optional uint64 raw_data_footprint = 8; // Original data size\n\n  optional CompressKind compress_kind = 9 [default = COMPRESS_LZO]; // Compression type\n  repeated ColumnMetaPB column_metas = 10; // Column metadata\n	optional PagePointerPB key_index_page = 11; // short key index page\n}\n\n"})}),"\n",(0,o.jsx)(n.h2,{id:"read-write-logic",children:"Read-write logic"}),"\n",(0,o.jsx)(n.h3,{id:"write",children:"Write"}),"\n",(0,o.jsx)(n.p,{children:"The general writing process is as follows:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Write magic"}),"\n",(0,o.jsx)(n.li,{children:"Generate corresponding Column Writer according to schema information. Each Column Writer obtains corresponding encoding information (configurable) according to different types, and generates corresponding encoder according to encoding."}),"\n",(0,o.jsx)(n.li,{children:"Call encoder - > add (value) for data writing. Each K line generates a short key index entry, and if the current page satisfies certain conditions (the size exceeds 1M or the number of rows is K), a new page is generated and cached in memory."}),"\n",(0,o.jsx)(n.li,{children:"Continuous cycle step 3 until data writing is completed. Brush the data of each column into the file in sequence"}),"\n",(0,o.jsx)(n.li,{children:"Generate FileFooterPB information and write it to the file."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Relevant issues:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"How does the index of short key be generated?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Now we still generate a short key sparse index according to how many rows are sparse, and keep a short sparse index generated every 1024 rows. The specific content is: short key - > ordinal"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"What should be stored in the ordinal index?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Store the first ordinal to page pointer mapping information for pages"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"What are stored in pages of different encoding types?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Dictionary Compression"}),"\n",(0,o.jsx)(n.li,{children:"plain"}),"\n",(0,o.jsx)(n.li,{children:"rle"}),"\n",(0,o.jsx)(n.li,{children:"bshuf"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"read",children:"Read"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Read the magic of the file and judge the type and version of the file."}),"\n",(0,o.jsx)(n.li,{children:"Read FileFooterPB and check sum"}),"\n",(0,o.jsx)(n.li,{children:"Read short key index and data ordinal index information of corresponding columns according to required columns"}),"\n",(0,o.jsx)(n.li,{children:"Use start key and end key, locate the row number to be read through short key index, then determine the row ranges to be read through ordinal index, and filter the row ranges to be read through statistics, inverted index and so on."}),"\n",(0,o.jsx)(n.li,{children:"Then read row data through ordinal index according to row ranges"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Relevant issues:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"How to quickly locate a row within the page?"}),"\n",(0,o.jsx)(n.p,{children:"The data inside the page is encoding, so it cannot locate the row-level data quickly. Different encoding methods have different schemes for fast line number positioning in-house, which need to be analyzed concretely:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"If it is rle-coded, skip is performed by resolving the head of RLE until the RLE block containing the row is reached, and then the reverse solution is performed."}),"\n",(0,o.jsx)(n.li,{children:"binary plain encoding: offset information will be stored in the page, and offset information will be specified in the page header. When reading, offset information will be parsed into the array first, so that you can quickly locate the data of a row of block through offset data information of each row."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"How to achieve efficient block reading? Consider merging adjacent blocks while they are being read, one-time reading?\nThis requires judging whether the block is continuous at the time of reading, and if it is continuous, reading it once."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"coding",children:"Coding"}),"\n",(0,o.jsx)(n.p,{children:"In the existing Doris storage, plain encoding is adopted for string type encoding, which is inefficient. After comparison, it is found that in Baidu statistics scenario, data will expand more than twice because of string type coding. Therefore, it is planned to introduce dictionary-based coding compression."}),"\n",(0,o.jsx)(n.h2,{id:"compression",children:"Compression"}),"\n",(0,o.jsx)(n.p,{children:"It implements a scalable compression framework, supports a variety of compression algorithms, facilitates the subsequent addition of new compression algorithms, and plans to introduce zstd compression."}),"\n",(0,o.jsx)(n.h2,{id:"todo",children:"TODO"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"How to implement nested types? How to locate line numbers in nested types?"}),"\n",(0,o.jsx)(n.li,{children:"How to optimize the downstream inverted index and column statistics caused by ScanRange splitting?"}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},688574:function(e,n,i){i.d(n,{Z:function(){return t}});let t=i.p+"assets/images/segment_v2-35f14e9d11067d490a85debb8ea7d2a8.png"},250065:function(e,n,i){i.d(n,{Z:function(){return s},a:function(){return r}});var t=i(667294);let o={},a=t.createContext(o);function r(e){let n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);