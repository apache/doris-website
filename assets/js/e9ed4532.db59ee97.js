"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["95186"],{762907:function(e,t,n){n.r(t),n.d(t,{default:()=>h,frontMatter:()=>l,metadata:()=>s,assets:()=>d,toc:()=>c,contentTitle:()=>a});var s=JSON.parse('{"id":"sql-manual/sql-statements/job/CREATE-JOB","title":"CREATE JOB","description":"Description","source":"@site/docs/sql-manual/sql-statements/job/CREATE-JOB.md","sourceDirName":"sql-manual/sql-statements/job","slug":"/sql-manual/sql-statements/job/CREATE-JOB","permalink":"/docs/dev/sql-manual/sql-statements/job/CREATE-JOB","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"CREATE JOB","language":"en"},"sidebar":"docs","previous":{"title":"SHOW ROW POLICY","permalink":"/docs/dev/sql-manual/sql-statements/data-governance/SHOW-ROW-POLICY"},"next":{"title":"PAUSE JOB","permalink":"/docs/dev/sql-manual/sql-statements/job/PAUSE-JOB"}}'),i=n("785893"),r=n("250065");let l={title:"CREATE JOB",language:"en"},a=void 0,d={},c=[{value:"Description",id:"description",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Required parameters",id:"required-parameters",level:2},{value:"Optional parameters",id:"optional-parameters",level:2},{value:"Access Control Requirements",id:"access-control-requirements",level:2},{value:"Usage Notes",id:"usage-notes",level:2},{value:"Examples",id:"examples",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Documents",id:"related-documents",level:2},{value:"CONFIG",id:"config",level:2}];function o(e){let t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(t.p,{children:"Doris Job is a task that runs according to a set plan. It is used to trigger predefined operations at a specific time or a specified time interval, so as to help us automatically perform some tasks. Functionally, it is similar to the scheduled task on the operating system (such as cron in Linux and scheduled tasks in Windows)."}),"\n",(0,i.jsxs)(t.p,{children:["There are two types of jobs: ",(0,i.jsx)(t.code,{children:"ONE_TIME"})," and ",(0,i.jsx)(t.code,{children:"RECURRING"}),". Among them, the ",(0,i.jsx)(t.code,{children:"ONE_TIME"})," type of job will be triggered at a specified time point. It is mainly used for one-time tasks, while the ",(0,i.jsx)(t.code,{children:"RECURRING"})," type of job will be triggered cyclically within a specified time interval. This method is mainly used for periodic tasks.\nThe ",(0,i.jsx)(t.code,{children:"RECURRING"})," type of job can specify the start time and end time, that is, ",(0,i.jsx)(t.code,{children:"STARTS/ENDS"}),". If the start time is not specified, the default first execution time is the current time + one scheduling cycle. If the end time is specified, the task execution is completed. If the end time is reached (or exceeded, or the next execution cycle will exceed the end time), it will be updated to the FINISHED state, and no more tasks will be generated at this time."]}),"\n",(0,i.jsxs)(t.p,{children:["There are 4 states for a job (",(0,i.jsx)(t.code,{children:"RUNNING"}),", ",(0,i.jsx)(t.code,{children:"STOPPED"}),", ",(0,i.jsx)(t.code,{children:"PAUSED"}),", ",(0,i.jsx)(t.code,{children:"FINISHED"}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["The initial state is ",(0,i.jsx)(t.code,{children:"RUNNING"}),". A job in the ",(0,i.jsx)(t.code,{children:"RUNNING"})," state will generate a TASK for execution according to the established scheduling cycle. When the job is completed and reaches the end time, the state changes to ",(0,i.jsx)(t.code,{children:"FINISHED"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["A job in the ",(0,i.jsx)(t.code,{children:"PAUSED"})," state can be resumed through the RESUME operation and changed to the RUNNING state."]}),"\n",(0,i.jsxs)(t.p,{children:["A job in the ",(0,i.jsx)(t.code,{children:"STOPPED"})," state is actively triggered by the user, and the running job will be canceled and the job will be deleted."]}),"\n",(0,i.jsxs)(t.p,{children:["A job in the ",(0,i.jsx)(t.code,{children:"FINISHED"})," state will be retained in the system for 24 hours and will be deleted after 24 hours."]}),"\n",(0,i.jsxs)(t.p,{children:["JOB only describes job information. Execution will generate TASK. TASK status is divided into ",(0,i.jsx)(t.code,{children:"PENDING"}),", ",(0,i.jsx)(t.code,{children:"RUNNING"}),", ",(0,i.jsx)(t.code,{children:"SUCCEESS"}),", ",(0,i.jsx)(t.code,{children:"FAILED"}),", ",(0,i.jsx)(t.code,{children:"CANCELED"}),"\n",(0,i.jsx)(t.code,{children:"PENDING"})," means that the trigger time has arrived but the resource run is waiting. After the resource is allocated, the status changes to ",(0,i.jsx)(t.code,{children:"RUNNING"}),". Success/failure of execution changes to ",(0,i.jsx)(t.code,{children:"SUCCESS"}),"/",(0,i.jsx)(t.code,{children:"FAILED"}),".\n",(0,i.jsx)(t.code,{children:"CANCELED"})," means cancellation status. TASK persists the final status, i.e. ",(0,i.jsx)(t.code,{children:"SUCCESS"}),"/",(0,i.jsx)(t.code,{children:"FAILED"}),". Other statuses can be checked during operation, but will not be visible if restarted."]}),"\n",(0,i.jsx)(t.h2,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"CREATE\n    JOB  \n    <job_name>\n    ON SCHEDULE <schedule>\n    [ COMMENT <string> ]\n    DO <sql_body> \n"})}),"\n",(0,i.jsx)(t.p,{children:"Where:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"schedule:\n  { AT <at_timestamp> | EVERY <interval> [STARTS <start_timestamp> ] [ENDS <end_timestamp> ] }\n"})}),"\n",(0,i.jsx)(t.p,{children:"Where:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"interval:\n  quantity { WEEK | DAY | HOUR | MINUTE }\n"})}),"\n",(0,i.jsx)(t.h2,{id:"required-parameters",children:"Required parameters"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["1. ",(0,i.jsx)(t.code,{children:"<job_name>"})]})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["Job name, which identifies a unique event in a db. The job name must be globally unique. If a job with the same name already exists, an error will be reported. We reserve the ",(0,i.jsx)(t.strong,{children:"inner_"})," prefix for internal use in the system, so users cannot create names starting with ",(0,i.jsx)(t.strong,{children:"inner_"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["2. ",(0,i.jsx)(t.code,{children:"<schedule>"})]})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"The ON SCHEDULE clause specifies the type, triggering time and frequency of the job. It can specify a one-time job or a periodic job."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["3. ",(0,i.jsx)(t.code,{children:"<sql_body>"})]})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"The DO clause specifies the operation to be performed when the job is triggered, that is, a SQL statement."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"optional-parameters",children:"Optional parameters"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["1. ",(0,i.jsx)(t.code,{children:"AT <at_timestamp>"})]})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["Format: 'YYYY-MM-DD HH:MM:SS', used for ",(0,i.jsx)(t.strong,{children:"one-time events"}),", it specifies that the event is executed only once at a given date and time timestamp, and when the execution is completed, the job status will change to FINISHED."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["2. ",(0,i.jsx)(t.code,{children:"EVERY <interval>"})]})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Indicates a regularly repeated operation, it specifies the execution frequency of the job, and a time interval must be specified after the keyword, which can be days, hours, minutes, seconds, or weeks."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["3. ",(0,i.jsx)(t.code,{children:"STARTS <start_timestamp>"})]})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Format: 'YYYY-MM-DD HH:MM:SS', used to specify the start time of the job. If not specified, it will be executed from the next time point after the current time. The start time must be greater than the current time."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["4. ",(0,i.jsx)(t.code,{children:"ENDS <end_timestamp>"})]})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Format: 'YYYY-MM-DD HH:MM:SS', used to specify the end time of the job. If not specified, it means permanent execution. The date must be greater than the current time. If the start time is specified, that is, STARTS, the end time must be greater than the start time."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"access-control-requirements",children:"Access Control Requirements"}),"\n",(0,i.jsx)(t.p,{children:"The user who executes this SQL command must have at least the following permissions:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Privilege"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Object"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Notes"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"ADMIN_PRIV"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Database"}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["Currently only supports ",(0,i.jsx)(t.strong,{children:"ADMIN"})," permissions to perform this operation"]})]})})]}),"\n",(0,i.jsx)(t.h2,{id:"usage-notes",children:"Usage Notes"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"TASK only retains the latest 100 records."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Currently only supports ",(0,i.jsx)(t.strong,{children:"INSERT internal table"})," operations, and will support more operations in the future."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"When the next scheduled task time expires, that is, when the task needs to be scheduled for execution, if the current JOB still has historical tasks being executed, the current task scheduling will be skipped. Therefore, it is very important to control a reasonable execution interval."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Create a job named my_job, which is executed once every minute. The operation performed is to import the data in db2.tbl2 into db1.tbl1."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"CREATE JOB my_job ON SCHEDULE EVERY 1 MINUTE DO INSERT INTO db1.tbl1 SELECT * FROM db2.tbl2;\n"})}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Create a one-time job that will be executed once at 2020-01-01 00:00:00 to import the data in db2.tbl2 into db1.tbl1."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"CREATE JOB my_job ON SCHEDULE AT '2020-01-01 00:00:00' DO INSERT INTO db1.tbl1 SELECT * FROM db2.tbl2;\n"})}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Create a periodic Job that will start executing at 2020-01-01 00:00:00 and execute once a day. The operation performed is to import the data in db2.tbl2 into db1.tbl1."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"CREATE JOB my_job ON SCHEDULE EVERY 1 DAY STARTS '2020-01-01 00:00:00' DO INSERT INTO db1.tbl1 SELECT * FROM db2.tbl2 WHERE create_time >= days_add(now(),-1);\n"})}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Create a periodic job that will start at 2020-01-01 00:00:00 and execute once a day. The operation is to import the data in db2.tbl2 into db1.tbl1. The job ends at 2020-01-01 00:10:00."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"CREATE JOB my_job ON SCHEDULE EVERY 1 DAY STARTS '2020-01-01 00:00:00' ENDS '2020-01-01 00:10:00' DO INSERT INTO db1.tbl1 SELECT * FROM db2.tbl2 create_time >= days_add(now(),-1);\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Manage jobs reasonably to avoid a large number of jobs being triggered at the same time, which will cause task accumulation and affect the normal operation of the system."}),"\n",(0,i.jsx)(t.li,{children:"The task execution interval should be set within a reasonable range, at least greater than the task execution time."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/dev/sql-manual/sql-statements/job/PAUSE-JOB",children:"Pause-JOB"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/dev/sql-manual/sql-statements/job/RESUME-JOB",children:"Resume-JOB"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/dev/sql-manual/sql-statements/job/DROP-JOB",children:"Delete-JOB"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/dev/sql-manual/sql-functions/table-valued-functions/jobs",children:"Query-JOB"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/dev/sql-manual/sql-functions/table-valued-functions/jobs",children:"Query-TASKS"})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"config",children:"CONFIG"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"fe.conf"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"job_dispatch_timer_job_thread_num, the number of threads used to distribute timed tasks, the default value is 2, if there are a large number of periodic execution tasks, you can increase this parameter."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"job_dispatch_timer_job_queue_size, the queue size for storing timed tasks when tasks are accumulated, the default value is 1024. If a large number of tasks are triggered at the same time, this parameter can be increased. Otherwise, the queue will be full, and the submitted task will enter a blocked state, which will cause subsequent tasks to fail to submit."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"finished_job_cleanup_threshold_time_hour, the time threshold for cleaning up completed tasks, in hours, the default value is 24 hours."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"job_insert_task_consumer_thread_num = 10; the number of threads used to execute Insert tasks, the value should be greater than 0, otherwise the default value is 5."}),"\n"]}),"\n"]})]})}function h(e={}){let{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return a},a:function(){return l}});var s=n(667294);let i={},r=s.createContext(i);function l(e){let t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);