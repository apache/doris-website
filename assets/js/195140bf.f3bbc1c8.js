"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["422244"],{758451:function(e,n,s){s.r(n),s.d(n,{default:()=>o,frontMatter:()=>l,metadata:()=>t,assets:()=>a,toc:()=>d,contentTitle:()=>r});var t=JSON.parse('{"id":"sql-manual/basic-element/sql-data-types/semi-structured/STRUCT","title":"STRUCT","description":"Type Description","source":"@site/docs/sql-manual/basic-element/sql-data-types/semi-structured/STRUCT.md","sourceDirName":"sql-manual/basic-element/sql-data-types/semi-structured","slug":"/sql-manual/basic-element/sql-data-types/semi-structured/STRUCT","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/semi-structured/STRUCT","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"STRUCT","language":"en"},"sidebar":"docs","previous":{"title":"MAP","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/semi-structured/MAP"},"next":{"title":"JSON","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/semi-structured/JSON"}}'),c=s("785893"),i=s("250065");let l={title:"STRUCT",language:"en"},r=void 0,a={},d=[{value:"Type Description",id:"type-description",level:2},{value:"Type Constraints",id:"type-constraints",level:2},{value:"Type Construction",id:"type-construction",level:2},{value:"Modifying Type",id:"modifying-type",level:2},{value:"Element Access",id:"element-access",level:2},{value:"Examples",id:"examples",level:2}];function T(e){let n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h2,{id:"type-description",children:"Type Description"}),"\n",(0,c.jsx)(n.p,{children:"The STRUCT type is used to combine multiple fields into a single structure, where each field can have its own name and type, suitable for representing nested or complex business data structures."}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.code,{children:"STRUCT<field_name:field_type [COMMENT 'comment_string'], ... >"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"field_name"})," represents the name, ",(0,c.jsx)(n.strong,{children:"cannot be empty, cannot be duplicated, and is case-insensitive"}),"."]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"field_type"})," represents the type, which is nullable and cannot be specified as NOT NULL. Supported types include: ",(0,c.jsx)(n.code,{children:"BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, DECIMAL, DATE, DATETIME, CHAR, VARCHAR, STRING, IPV4, IPV6, ARRAY, MAP, STRUCT"}),"."]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"[COMMENT 'comment-string']"})," represents an optional comment."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"type-constraints",children:"Type Constraints"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["The maximum nesting depth supported by the ",(0,c.jsx)(n.code,{children:"STRUCT"})," type is 9."]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Conversion between ",(0,c.jsx)(n.code,{children:"STRUCT"})," types depends on whether the internal types can be converted (names do not affect conversion). ",(0,c.jsx)(n.code,{children:"STRUCT"})," types cannot be converted to other types."]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["String types can be converted to ",(0,c.jsx)(n.code,{children:"STRUCT"})," types (through parsing, returning NULL if parsing fails)."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["In the ",(0,c.jsx)(n.code,{children:"AGGREGATE"})," table model, ",(0,c.jsx)(n.code,{children:"STRUCT"})," types only support ",(0,c.jsx)(n.code,{children:"REPLACE"})," and ",(0,c.jsx)(n.code,{children:"REPLACE_IF_NOT_NULL"}),". ",(0,c.jsx)(n.strong,{children:"In any table model, they cannot be used as KEY columns, nor as partition or bucket columns."})]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Columns of ",(0,c.jsx)(n.code,{children:"STRUCT"})," type do not support comparison or arithmetic operations, ",(0,c.jsxs)(n.strong,{children:["do not support ",(0,c.jsx)(n.code,{children:"ORDER BY"})," and ",(0,c.jsx)(n.code,{children:"GROUP BY"})," operations, cannot be used as ",(0,c.jsx)(n.code,{children:"JOIN KEY"}),", and cannot be used in ",(0,c.jsx)(n.code,{children:"DELETE"})," statements."]})]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Columns of ",(0,c.jsx)(n.code,{children:"STRUCT"})," type do not support creating any indexes."]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"type-construction",children:"Type Construction"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Use ",(0,c.jsx)(n.code,{children:"STRUCT()"})," to construct a value of type ",(0,c.jsx)(n.code,{children:"STRUCT"}),", where the internal names start from col1."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SQL",children:'SELECT STRUCT(1, \'a\', "abc");\n\n+--------------------------------------+\n| STRUCT(1, \'a\', "abc")                |\n+--------------------------------------+\n| {"col1":1, "col2":"a", "col3":"abc"} |\n+--------------------------------------+\n'})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Use ",(0,c.jsx)(n.code,{children:"NAMED_STRUCT()"})," to construct a specific ",(0,c.jsx)(n.code,{children:"STRUCT"})," type value."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SQL",children:'SELECT NAMED_STRUCT("name", "Jack", "id", 1728923);\n\n+---------------------------------------------+\n| NAMED_STRUCT("name", "Jack", "id", 1728923) |\n+---------------------------------------------+\n| {"name":"Jack", "id":1728923}               |\n+---------------------------------------------+\n'})}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"modifying-type",children:"Modifying Type"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Modification is allowed only when the subcolumn type of ",(0,c.jsx)(n.code,{children:"STRUCT"})," is ",(0,c.jsx)(n.code,{children:"VARCHAR"}),"."]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Only allows changing the parameter of ",(0,c.jsx)(n.code,{children:"VARCHAR"})," from smaller to larger, not the other way around."]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE struct_table (\n    `k` INT NOT NULL,\n    `struct_varchar` STRUCT<name: VARCHAR(10), age: INT>\n) ENGINE=OLAP\nDUPLICATE KEY(`k`)\nDISTRIBUTED BY HASH(`k`) BUCKETS 1\nPROPERTIES (\n    "replication_num" = "1"\n);\n\nALTER TABLE struct_table MODIFY COLUMN struct_varchar STRUCT<name: VARCHAR(20), age: INT>;\n'})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Subcolumns inside ",(0,c.jsx)(n.code,{children:"STRUCT"})," type do not support deletion, but new subcolumns can be added at the end."]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SQL",children:'  CREATE TABLE struct_table (\n      `k` INT NOT NULL,\n      `struct_varchar` STRUCT<name: VARCHAR(10), age: INT>\n  ) ENGINE=OLAP\n  DUPLICATE KEY(`k`)\n  DISTRIBUTED BY HASH(`k`) BUCKETS 1\n  PROPERTIES (\n      "replication_num" = "1"\n  );\n\n  -- Add a subcolumn at the end\n  ALTER TABLE struct_table MODIFY COLUMN struct_varchar STRUCT<name: VARCHAR(10), age: INT, id: INT>;\n'})}),"\n",(0,c.jsx)(n.h2,{id:"element-access",children:"Element Access"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Use ",(0,c.jsx)(n.code,{children:"STRUCT_ELEMENT(struct, k/field_name)"})," to access a specific subcolumn inside the ",(0,c.jsx)(n.code,{children:"STRUCT"}),"."]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"k represents the position, starting from 1."}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"field_name"})," is the name of the subcolumn in the ",(0,c.jsx)(n.code,{children:"STRUCT"}),"."]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SQL",children:'SELECT STRUCT_ELEMENT(NAMED_STRUCT("name", "Jack", "id", 1728923), 1);\n\n+----------------------------------------------------------------+\n| STRUCT_ELEMENT(NAMED_STRUCT("name", "Jack", "id", 1728923), 1) |\n+----------------------------------------------------------------+\n| Jack                                                           |\n+----------------------------------------------------------------+\n\nSELECT STRUCT_ELEMENT(NAMED_STRUCT("name", "Jack", "id", 1728923), "id");\n\n+-------------------------------------------------------------------+\n| STRUCT_ELEMENT(NAMED_STRUCT("name", "Jack", "id", 1728923), "id") |\n+-------------------------------------------------------------------+\n|                                                           1728923 |\n+-------------------------------------------------------------------+\n'})}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"Nested Complex Types"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SQL",children:"-- Create table\nCREATE TABLE IF NOT EXISTS struct_table (\n    id INT,\n    struct_complex STRUCT<\n        basic_info: STRUCT<name: STRING, age: INT>,\n        contact: STRUCT<email: STRING, phone: STRING>,\n        preferences: STRUCT<tags: ARRAY<STRING>, settings: MAP<STRING, INT>>,\n        metadata: STRUCT<\n            created_at: DATETIME,\n            updated_at: DATETIME,\n            stats: STRUCT<views: INT, clicks: INT>\n        >\n    >\n) ENGINE=OLAP\nDUPLICATE KEY(id)\nDISTRIBUTED BY HASH(id) BUCKETS 1\x03\nPROPERTIES (\n    \"replication_allocation\" = \"tag.location.default: 1\"\n);\n\n-- Insert\nINSERT INTO struct_table VALUES (1, STRUCT(\n  STRUCT('John', 25),\n  STRUCT('john@example.com', '1234567890'),\n  STRUCT(['tag1', 'tag2'], MAP('setting1', 1, 'setting2', 2)),\n  STRUCT('2021-01-01 00:00:00', '2021-01-02 00:00:00', STRUCT(100, 50))\n));\n\n-- Query\nSELECT STRUCT_ELEMENT(STRUCT_ELEMENT(struct_complex, 'basic_info'), 'name')  FROM struct_table ORDER BY id;\n\n+----------------------------------------------------------------------+\n| STRUCT_ELEMENT(STRUCT_ELEMENT(struct_complex, 'basic_info'), 'name') |\n+----------------------------------------------------------------------+\n| John                                                                 |\n+----------------------------------------------------------------------+\n\nSELECT STRUCT_ELEMENT(STRUCT_ELEMENT(STRUCT_ELEMENT(struct_complex, 'metadata'), 'stats'), 'views') FROM struct_table ORDER BY id;\n\n+----------------------------------------------------------------------------------------------+\n| STRUCT_ELEMENT(STRUCT_ELEMENT(STRUCT_ELEMENT(struct_complex, 'metadata'), 'stats'), 'views') |\n+----------------------------------------------------------------------------------------------+\n|                                                                                          100 |\n+----------------------------------------------------------------------------------------------+\n"})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"Modifying Type"}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SQL",children:'-- Create table\nCREATE TABLE struct_table (\n      `k` INT NOT NULL,\n      `struct_varchar` STRUCT<name: VARCHAR(10), age: INT>\n  ) ENGINE=OLAP\n  DUPLICATE KEY(`k`)\n  DISTRIBUTED BY HASH(`k`) BUCKETS 1\n  PROPERTIES (\n      "replication_num" = "1"\n  );\n\n  -- Modify the type of the \'name\' subcolumn\n  ALTER TABLE struct_table MODIFY COLUMN struct_varchar STRUCT<name: VARCHAR(20), age: INT>;\n\n  -- Check column types\n  DESC struct_table;\n\n  +----------------+----------------------------------+------+-------+---------+-------+\n  | Field          | Type                             | Null | Key   | Default | Extra |\n  +----------------+----------------------------------+------+-------+---------+-------+\n  | k              | int                              | No   | true  | NULL    |       |\n  | struct_varchar | struct<name:varchar(20),age:int> | Yes  | false | NULL    | NONE  |\n  +----------------+----------------------------------+------+-------+---------+-------+\n\n  -- Create table\n  CREATE TABLE struct_table (\n      `k` INT NOT NULL,\n      `struct_varchar` STRUCT<name: VARCHAR(10), age: INT>\n  ) ENGINE=OLAP\n  DUPLICATE KEY(`k`)\n  DISTRIBUTED BY HASH(`k`) BUCKETS 1\n  PROPERTIES (\n      "replication_num" = "1"\n  );\n\n  -- Add a subcolumn at the end\n  ALTER TABLE struct_table MODIFY COLUMN struct_varchar STRUCT<name: VARCHAR(10), age: INT, id: INT>;\n\n  -- Check column types\n  DESC struct_table;\n\n  +----------------+-----------------------------------------+------+-------+---------+-------+\n  | Field          | Type                                    | Null | Key   | Default | Extra |\n  +----------------+-----------------------------------------+------+-------+---------+-------+\n  | k              | int                                     | No   | true  | NULL    |       |\n  | struct_varchar | struct<name:varchar(10),age:int,id:int> | Yes  | false | NULL    | NONE  |\n  +----------------+-----------------------------------------+------+-------+---------+-------+\n'})})]})}function o(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(T,{...e})}):T(e)}},250065:function(e,n,s){s.d(n,{Z:function(){return r},a:function(){return l}});var t=s(667294);let c={},i=t.createContext(c);function l(e){let n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);