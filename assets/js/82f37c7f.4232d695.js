"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["954231"],{752671:function(e,n,t){t.r(n),t.d(n,{default:()=>d,frontMatter:()=>r,metadata:()=>i,assets:()=>l,toc:()=>o,contentTitle:()=>c});var i=JSON.parse('{"id":"query-acceleration/sql-cache-manual","title":"SQL Cache","description":"Description","source":"@site/versioned_docs/version-2.1/query-acceleration/sql-cache-manual.md","sourceDirName":"query-acceleration","slug":"/query-acceleration/sql-cache-manual","permalink":"/docs/2.1/query-acceleration/sql-cache-manual","draft":false,"unlisted":false,"tags":[],"version":"2.1","frontMatter":{"title":"SQL Cache","language":"en"},"sidebar":"docs","previous":{"title":"FAQ","permalink":"/docs/2.1/query-acceleration/materialized-view/async-materialized-view/faq"},"next":{"title":"High-Concurrency Point Query Optimization","permalink":"/docs/2.1/query-acceleration/high-concurrent-point-query"}}'),s=t("785893"),a=t("250065");let r={title:"SQL Cache",language:"en"},c=void 0,l={},o=[{value:"Description",id:"description",level:2},{value:"Usage Limitations",id:"usage-limitations",level:2},{value:"Non-Deterministic Functions",id:"non-deterministic-functions",level:3},{value:"Principles",id:"principles",level:2},{value:"BE Principle",id:"be-principle",level:3},{value:"FE Principle",id:"fe-principle",level:3},{value:"Get Started",id:"get-started",level:2},{value:"Enabling and Disabling SQL Cache",id:"enabling-and-disabling-sql-cache",level:3},{value:"Checking If a Query Hits SQL Cache",id:"checking-if-a-query-hits-sql-cache",level:3},{value:"Metrics and Monitor",id:"metrics-and-monitor",level:2},{value:"Memory Control",id:"memory-control",level:2},{value:"FE Memory Control",id:"fe-memory-control",level:3},{value:"BE Memory Control",id:"be-memory-control",level:3},{value:"Troubleshooting Cache Miss",id:"troubleshooting-cache-miss",level:2}];function h(e){let n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,s.jsx)(n.p,{children:"SQL Cache is a query optimization mechanism provided by Doris that can significantly enhance query performance. It reduces redundant computations by caching query results, making it suitable for scenarios where data update infrequently."}),"\n",(0,s.jsx)(n.p,{children:"SQL Cache stores and retrieves caches based on the following key factors:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"SQL Text"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"View Definitions"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Table and Partition Versions"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"User Variables and Result Values"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Non-deterministic Functions and Result Values"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Row Policy Definitions"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Data Masking Definitions"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The combination of these factors uniquely determines a cached dataset. If any of these factors change, such as variations in SQL, different query fields or conditions, or version changes after data updates, the cache will not be hit."}),"\n",(0,s.jsx)(n.p,{children:"For queries involving multi-table joins, if one of the tables is updated, the partition ID or version number will differ, resulting in a cache miss."}),"\n",(0,s.jsx)(n.p,{children:"SQL Cache is highly suitable for T+1 update scenarios. Data is updated early in the morning, the first query fetches results from the Backend (BE) and stores them in the cache, and subsequent queries of the same nature retrieve results directly from the cache. Real-time data updates can also use SQL Cache, but may face a lower cache hit rate."}),"\n",(0,s.jsx)(n.p,{children:"Currently, SQL Cache supports both internal OlapTables and external Hive tables."}),"\n",(0,s.jsx)(n.h2,{id:"usage-limitations",children:"Usage Limitations"}),"\n",(0,s.jsx)(n.h3,{id:"non-deterministic-functions",children:"Non-Deterministic Functions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Non-deterministic functions refer to those whose computation results do not form a fixed relationship with their input parameters."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Take the common function ",(0,s.jsx)(n.code,{children:"select now()"})," as an example. It returns the current date and time. Since this function returns different results when executed at different times, its return value is dynamically changing. The ",(0,s.jsx)(n.code,{children:"now"})," function returns time at the second level, so SQL Cache from the previous second can be reused within the same second; however, a new SQL Cache needs to be created for the next second."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["To optimize cache utilization, it is recommended to convert such fine-grained time into coarse-grained time, such as using ",(0,s.jsx)(n.code,{children:"select * from tbl where dt=date(now())"}),". In this case, queries within the same day can leverage the SQL Cache."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["In contrast, the ",(0,s.jsx)(n.code,{children:"random()"})," function is difficult to utilize cache because its results vary each time it is executed. Therefore, the use of such non-deterministic functions in queries should be avoided as much as possible."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"principles",children:"Principles"}),"\n",(0,s.jsx)(n.h3,{id:"be-principle",children:"BE Principle"}),"\n",(0,s.jsx)(n.p,{children:"In most cases, SQL Cache results are selected through a consistent hashing method to choose a BE and are stored in that BE's memory. These results are stored in a HashMap structure. When requests to read or write the cache arrive, the system uses a digest of metadata information, such as the SQL string, as a key to quickly retrieve and manipulate result data from the HashMap."}),"\n",(0,s.jsx)(n.h3,{id:"fe-principle",children:"FE Principle"}),"\n",(0,s.jsx)(n.p,{children:"When the Frontend (FE) receives a query request, it first searches in its memory using the SQL string to determine if the same query has been executed before and attempts to retrieve the metadata information for that query. This information includes the versions of the tables and partitions involved in the query."}),"\n",(0,s.jsx)(n.p,{children:"If these metadata remain unchanged, it indicates that the data in the corresponding tables has not been modified, allowing the reuse of the previous SQL Cache. In this case, the FE can skip the SQL parsing and optimization process, directly locate the corresponding BE based on the consistent hashing algorithm, and attempt to retrieve the query results from it."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the target BE contains a cached result for the query, the FE can quickly return the results to the client."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Conversely, if the corresponding result cache is not found in the BE, the FE needs to execute the complete SQL parsing and optimization process and then transmit the query plan to the BE for computation and processing."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When the BE returns the computation results to the FE, the FE is responsible for storing these results in the corresponding BE and recording the metadata information of this query in its memory. This is done so that when the same query is received subsequently, the FE can directly retrieve the results from the BE, thereby improving query efficiency."}),"\n",(0,s.jsx)(n.p,{children:"Additionally, if the SQL optimization phase determines that the query results contain only 0 or 1 row of data, the FE will choose to store these results in its memory to respond more quickly to potential future identical queries."}),"\n",(0,s.jsx)(n.h2,{id:"get-started",children:"Get Started"}),"\n",(0,s.jsx)(n.h3,{id:"enabling-and-disabling-sql-cache",children:"Enabling and Disabling SQL Cache"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Enable SQL Cache for the current session, default is disabled  \nset enable_sql_cache=true;  \n-- Disable SQL Cache for the current session  \nset enable_sql_cache=false;  \n  \n-- Globally enable SQL Cache, default is disabled  \nset global enable_sql_cache=true;  \n-- Globally disable SQL Cache  \nset global enable_sql_cache=false;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"checking-if-a-query-hits-sql-cache",children:"Checking If a Query Hits SQL Cache"}),"\n",(0,s.jsxs)(n.p,{children:["In Doris versions 2.1.3 and later, users can execute the ",(0,s.jsx)(n.code,{children:"explain plan"})," statement to check if the current query successfully hits the SQL Cache."]}),"\n",(0,s.jsxs)(n.p,{children:["As shown in the example, when the query plan tree contains ",(0,s.jsx)(n.code,{children:"LogicalSqlCache"})," or ",(0,s.jsx)(n.code,{children:"PhysicalSqlCache"})," nodes, it indicates that the query has hit the SQL Cache."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"> explain plan select * from t2;  \n  \n+------------------------------------------------------------------------------------------------------------+  \n| Explain String (Nereids Planner)                                                                           |  \n+------------------------------------------------------------------------------------------------------------+  \n| ========== PARSED PLAN (time: 28ms) ==========                                                             |  \n| LogicalSqlCache[1] ( queryId=711dea740e4746e6-8bc11afe08f6542c )                                           |  \n| +--PhysicalResultSink[39] ( outputExprs=[id#0, name#1] )                                                   |  \n|    +--PhysicalOlapScan[t2]@0 ( stats=12 )                                                                  |  \n|                                                                                                            |  \n| ========== ANALYZED PLAN ==========                                                                        |  \n| LogicalSqlCache[1] ( queryId=711dea740e4746e6-8bc11afe08f6542c )                                           |  \n| +--PhysicalResultSink[39] ( outputExprs=[id#0, name#1] )                                                   |  \n|    +--PhysicalOlapScan[t2]@0 ( stats=12 )                                                                  |  \n|                                                                                                            |  \n| ========== REWRITTEN PLAN ==========                                                                       |  \n| LogicalSqlCache[1] ( queryId=711dea740e4746e6-8bc11afe08f6542c )                                           |  \n| +--PhysicalResultSink[39] ( outputExprs=[id#0, name#1] )                                                   |  \n|    +--PhysicalOlapScan[t2]@0 ( stats=12 )                                                                  |  \n|                                                                                                            |  \n| ========== OPTIMIZED PLAN ==========                                                                       |  \n| PhysicalSqlCache[3] ( queryId=711dea740e4746e6-8bc11afe08f6542c, backend=192.168.126.3:9051, rowCount=12 ) |  \n| +--PhysicalResultSink[39] ( outputExprs=[id#0, name#1] )                                                   |  \n|    +--PhysicalOlapScan[t2]@0 ( stats=12 )                                                                  |  \n+------------------------------------------------------------------------------------------------------------+\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For versions before Doris 2.1.3, users need to check the Profile information to confirm if the query hits the SQL Cache. In the Profile information, if the ",(0,s.jsx)(n.code,{children:"Is Cached:"})," field displays ",(0,s.jsx)(n.code,{children:"Yes"}),", it indicates that the query has successfully hit the SQL Cache."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"Execution  Summary:\n      -  Parse  SQL  Time:  18ms\n      -  Nereids  Analysis  Time:  N/A\n      -  Nereids  Rewrite  Time:  N/A\n      -  Nereids  Optimize  Time:  N/A\n      -  Nereids  Translate  Time:  N/A\n      -  Workload  Group:  normal\n      -  Analysis  Time:  N/A\n      -  Wait  and  Fetch  Result  Time:  N/A\n      -  Fetch  Result  Time:  0ms\n      -  Write  Result  Time:  0ms\n      -  Doris  Version:  915138e801\n      -  Is  Nereids:  Yes\n      -  Is  Cached:  Yes\n      -  Total  Instances  Num:  0\n      -  Instances  Num  Per  BE:  \n      -  Parallel  Fragment  Exec  Instance  Num:  1\n      -  Trace  ID:  \n      -  Transaction  Commit  Time:  N/A\n      -  Nereids  Distribute  Time:  N/A\n"})}),"\n",(0,s.jsx)(n.p,{children:"Both methods provide effective means for users to verify whether queries utilize the SQL Cache, helping users better assess query performance and optimize query strategies."}),"\n",(0,s.jsx)(n.h2,{id:"metrics-and-monitor",children:"Metrics and Monitor"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["1. The HTTP interface on the FE ",(0,s.jsx)(n.code,{children:"http://${FE_IP}:${FE_HTTP_PORT}/metrics"})," returns two relevant metrics:"]})," This indicator counts the number of hits, which only increases and never decreases. When FE is restarted, the count starts from 0."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Plain",children:'# Represents that 1 SQL has been written to the cache  \ndoris_fe_cache_added{type="sql"} 1  \n  \n# Represents that the SQL Cache has been hit twice  \ndoris_fe_cache_hit{type="sql"} 2\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["2. The HTTP interface on the BE ",(0,s.jsx)(n.code,{children:"http://${BE_IP}:${BE_HTTP_PORT}/metrics"})," returns relevant information:"]})," Since different caches may be stored in different BEs, it is necessary to collect metrics from all BEs to obtain complete information."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Plain",children:"# Represents that there are 1205 caches in the memory of the current BE  \ndoris_be_query_cache_sql_total_count 1205  \n  \n# The current total memory occupied by all caches in the BE is 44k  \ndoris_be_query_cache_memory_total_byte 44101\n"})}),"\n",(0,s.jsx)(n.h2,{id:"memory-control",children:"Memory Control"}),"\n",(0,s.jsx)(n.h3,{id:"fe-memory-control",children:"FE Memory Control"}),"\n",(0,s.jsx)(n.p,{children:"In FE, the metadata information of Cache is set to weak references. When FE memory is insufficient, the system will automatically release the least recently used Cache metadata. Additionally, users can further limit FE memory usage by executing the following SQL statements. This configuration takes effect in real-time and needs to be set for each FE. For persistent configuration, it should be saved in the fe.conf file."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Store up to 100 Cache metadata items, automatically releasing the least recently used ones when exceeded. The default value is 100.  \nADMIN SET FRONTEND CONFIG ('sql_cache_manage_num'='100');  \n  \n-- Automatically release Cache metadata after 300 seconds of inactivity. The default value is 300.  \nADMIN SET FRONTEND CONFIG ('expire_sql_cache_in_fe_second'='300');\n"})}),"\n",(0,s.jsx)(n.h3,{id:"be-memory-control",children:"BE Memory Control"}),"\n",(0,s.jsx)(n.p,{children:"Modify the following configurations in the be.conf file, and the changes will take effect after restarting BE:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- When the Cache memory exceeds query_cache_max_size_mb + query_cache_elasticity_size_mb,  \n-- release the least recently used Cache until the memory usage is below query_cache_max_size_mb.  \nquery_cache_max_size_mb = 256  \nquery_cache_elasticity_size_mb = 128\n"})}),"\n",(0,s.jsx)(n.p,{children:"Furthermore, configurations can be set in FE to avoid creating SQL Cache when the result row count or size exceeds certain thresholds:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- By default, do not create SQL Cache for results exceeding 3000 rows.  \nADMIN SET FRONTEND CONFIG ('cache_result_max_row_count'='3000');  \n  \n-- By default, do not create SQL Cache for results exceeding 30MB.  \nADMIN SET FRONTEND CONFIG ('cache_result_max_data_size'='31457280');\n"})}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting-cache-miss",children:"Troubleshooting Cache Miss"}),"\n",(0,s.jsx)(n.p,{children:"The reasons for cache invalidation typically include the following:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Changes in table/view structure, such as executing ",(0,s.jsx)(n.code,{children:"drop table"}),", ",(0,s.jsx)(n.code,{children:"replace table"}),", ",(0,s.jsx)(n.code,{children:"alter table"}),", or ",(0,s.jsx)(n.code,{children:"alter view"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Changes in table data, such as executing ",(0,s.jsx)(n.code,{children:"insert"}),", ",(0,s.jsx)(n.code,{children:"delete"}),", ",(0,s.jsx)(n.code,{children:"update"}),", or ",(0,s.jsx)(n.code,{children:"truncate"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Removal of user privileges, such as executing ",(0,s.jsx)(n.code,{children:"revoke"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Use of non-deterministic functions with changing evaluation values, such as executing ",(0,s.jsx)(n.code,{children:"select random()"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Use of variables with changing values, such as executing ",(0,s.jsx)(n.code,{children:"select * from tbl where dt = @dt_var"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Changes in Row Policy or Data Masking, such as setting certain table data to be invisible to users."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The result row count exceeds the FE-configured ",(0,s.jsx)(n.code,{children:"cache_result_max_row_count"}),", with a default value of 3000 rows."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The result size exceeds the FE-configured ",(0,s.jsx)(n.code,{children:"cache_result_max_data_size"}),", with a default value of 30MB."]}),"\n"]}),"\n"]})]})}function d(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return c},a:function(){return r}});var i=t(667294);let s={},a=i.createContext(s);function r(e){let n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);