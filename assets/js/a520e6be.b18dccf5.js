"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["263380"],{875018:function(e,t,a){a.r(t),a.d(t,{default:()=>c,frontMatter:()=>d,metadata:()=>n,assets:()=>s,toc:()=>l,contentTitle:()=>i});var n=JSON.parse('{"id":"data-operate/update/update-of-aggregate-model","title":"Updating Data on Aggregate Key Model","description":"This guide is about ingestion-based data updates for the Aggregate Key model in Doris.","source":"@site/versioned_docs/version-2.0/data-operate/update/update-of-aggregate-model.md","sourceDirName":"data-operate/update","slug":"/data-operate/update/update-of-aggregate-model","permalink":"/docs/2.0/data-operate/update/update-of-aggregate-model","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Updating Data on Aggregate Key Model","language":"en"},"sidebar":"docs","previous":{"title":"Updating Data on Unique Key Model","permalink":"/docs/2.0/data-operate/update/update-of-unique-model"},"next":{"title":"Concurrency Control for Updates in the Primary Key Model","permalink":"/docs/2.0/data-operate/update/unique-update-concurrent-control"}}'),r=a("785893"),o=a("250065");let d={title:"Updating Data on Aggregate Key Model",language:"en"},i="Update for Aggregate Load",s={},l=[{value:"Update all columns",id:"update-all-columns",level:2},{value:"Partial column update for Aggregate Key model",id:"partial-column-update-for-aggregate-key-model",level:2},{value:"Note",id:"note",level:2}];function u(e){let t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"update-for-aggregate-load",children:"Update for Aggregate Load"})}),"\n",(0,r.jsx)(t.p,{children:"This guide is about ingestion-based data updates for the Aggregate Key model in Doris."}),"\n",(0,r.jsx)(t.h2,{id:"update-all-columns",children:"Update all columns"}),"\n",(0,r.jsx)(t.p,{children:"When importing data into an Aggregate Key model in Doris by methods like Stream Load, Broker Load, Routine Load, and Insert Into, the new values are combined with the old values to produce new aggregated values based on the column's aggregation function. These values might be generated during insertion or produced asynchronously during compaction. However, when querying, users will always receive the same returned values."}),"\n",(0,r.jsx)(t.h2,{id:"partial-column-update-for-aggregate-key-model",children:"Partial column update for Aggregate Key model"}),"\n",(0,r.jsxs)(t.p,{children:["Tables in the Aggregate Key model are primarily used in cases with pre-aggregation requirements rather than data updates, but Doris allows partial column updates for them, too. Simply set the aggregation function to ",(0,r.jsx)(t.code,{children:"REPLACE_IF_NOT_NULL"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Create table"})}),"\n",(0,r.jsxs)(t.p,{children:["For the columns that need to be updated, set the aggregation function to ",(0,r.jsx)(t.code,{children:"REPLACE_IF_NOT_NULL"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-Plain",children:'CREATE TABLE order_tbl (\n  order_id int(11) NULL,\n  order_amount int(11) REPLACE_IF_NOT_NULL NULL,\n  order_status varchar(100) REPLACE_IF_NOT_NULL NULL\n) ENGINE=OLAP\nAGGREGATE KEY(order_id)\nCOMMENT \'OLAP\'\nDISTRIBUTED BY HASH(order_id) BUCKETS 1\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 1"\n);\n+----------+--------------+-----------------+\n| order_id | order_amount | order_status    |\n+----------+--------------+-----------------+\n| 1        |          100 | Pending Payment |\n+----------+--------------+-----------------+\n1 row in set (0.01 sec)\n'})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Ingest data"})}),"\n",(0,r.jsx)(t.p,{children:"For Stream Load, Broker Load, Routine Load, or INSERT INTO, you can directly write the updates to the fields."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example"})}),"\n",(0,r.jsx)(t.p,{children:"Using the same example as above, the corresponding Stream Load command would be (no additional headers required):"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",children:'$ cat update.csv\n\n1,To be shipped\n\n$ curl  --location-trusted -u root: -H "column_separator:," -H "columns:order_id,order_status" -T /tmp/update.csv http://127.0.0.1:8030/api/db1/order_tbl/_stream_load\n'})}),"\n",(0,r.jsxs)(t.p,{children:["The corresponding ",(0,r.jsx)(t.code,{children:"INSERT INTO"})," statement would be (no additional session variables required):"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-Plain",children:"INSERT INTO order_tbl (order_id, order_status) values (1,'Delivery Pending');\n"})}),"\n",(0,r.jsx)(t.h2,{id:"note",children:"Note"}),"\n",(0,r.jsx)(t.p,{children:"The Aggregate Key model does not perform additional data processing during data writing, so the writing performance in this model is the same as other models. However, aggregation during queries can result in performance loss. Typical aggregation queries can be 5~10 times slower than queries on Merge-on-Write tables in the Unique Key model."}),"\n",(0,r.jsx)(t.p,{children:"Under this circumstance, users cannot set a field from non-NULL to NULL, because NULL values written will be automatically neglected by the REPLACE_IF_NOT_NULL aggregation function."})]})}function c(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},250065:function(e,t,a){a.d(t,{Z:function(){return i},a:function(){return d}});var n=a(667294);let r={},o=n.createContext(r);function d(e){let t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);