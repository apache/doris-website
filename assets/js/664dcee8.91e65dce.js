"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["460978"],{566435:function(e,n,t){t.r(n),t.d(n,{default:()=>u,frontMatter:()=>i,metadata:()=>o,assets:()=>r,toc:()=>l,contentTitle:()=>d});var o=JSON.parse('{"id":"lakehouse/compute-node","title":"Elastic Compute Node","description":"Elastic compute nodes, as a special type of BE node, do not have data storage capabilities and are only responsible for data computation. Therefore,","source":"@site/versioned_docs/version-3.x/lakehouse/compute-node.md","sourceDirName":"lakehouse","slug":"/lakehouse/compute-node","permalink":"/docs/3.x/lakehouse/compute-node","draft":false,"unlisted":false,"tags":[],"version":"3.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Elastic Compute Node","language":"en","description":"Elastic compute nodes, as a special type of BE node, do not have data storage capabilities and are only responsible for data computation. Therefore,"},"sidebar":"docs","previous":{"title":"Metadata Cache","permalink":"/docs/3.x/lakehouse/meta-cache"},"next":{"title":"Statistics","permalink":"/docs/3.x/lakehouse/statistics"}}'),s=t("785893"),a=t("250065");let i={title:"Elastic Compute Node",language:"en",description:"Elastic compute nodes, as a special type of BE node, do not have data storage capabilities and are only responsible for data computation. Therefore,"},d=void 0,r={},l=[{value:"Usage of Compute Nodes",id:"usage-of-compute-nodes",level:2},{value:"BE Node Types",id:"be-node-types",level:3},{value:"Adding Compute Nodes",id:"adding-compute-nodes",level:3},{value:"Using Compute Nodes",id:"using-compute-nodes",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Resource Isolation and Elastic Scaling of Federated Queries",id:"resource-isolation-and-elastic-scaling-of-federated-queries",level:3},{value:"Common Issues",id:"common-issues",level:2}];function c(e){let n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Elastic compute nodes, as a special type of BE node, do not have data storage capabilities and are only responsible for data computation. Therefore, compute nodes can be regarded as stateless BE nodes, which can be easily added and removed."}),"\n",(0,s.jsx)(n.p,{children:"In lakehouse data analysis scenarios, elastic compute nodes can be used to query external data sources such as Hive, Iceberg, Hudi, Paimon, JDBC, etc. Doris does not handle the storage of external data source data, so elastic compute nodes can be used to easily expand the computing power for external data sources. Additionally, compute nodes can also be configured with cache directories to cache hot data from external data sources, further accelerating data reading."}),"\n",(0,s.jsxs)(n.p,{children:["Elastic compute nodes ",(0,s.jsx)(n.strong,{children:"are suitable for elastic resource control in the integrated storage and computing mode of Doris"}),". In the storage-compute separation architecture of Doris 3.0, BE nodes are stateless, so separate elastic compute nodes are no longer needed."]}),"\n",(0,s.jsx)(n.h2,{id:"usage-of-compute-nodes",children:"Usage of Compute Nodes"}),"\n",(0,s.jsx)(n.h3,{id:"be-node-types",children:"BE Node Types"}),"\n",(0,s.jsx)(n.p,{children:"In the integrated storage and computing mode, BE nodes are divided into two types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Mix"}),"\n",(0,s.jsx)(n.p,{children:"Mixed nodes. This is the default type of BE node. These nodes participate in both computation and the storage of Doris internal table data."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Computation"}),"\n",(0,s.jsx)(n.p,{children:"Elastic compute nodes. They do not handle data storage, only data computation."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"adding-compute-nodes",children:"Adding Compute Nodes"}),"\n",(0,s.jsxs)(n.p,{children:["Add the following configuration in the BE ",(0,s.jsx)(n.code,{children:"be.conf"})," configuration file:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"be_node_role=computation"})}),"\n",(0,s.jsx)(n.p,{children:"Afterwards, start the BE node, and it will run as a Computation type."}),"\n",(0,s.jsx)(n.p,{children:"Then you can connect to Doris and execute:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"ALTER SYSTEM ADD BACKEND"})}),"\n",(0,s.jsxs)(n.p,{children:["to add this BE node. Once added successfully, you can see the node type as ",(0,s.jsx)(n.code,{children:"computation"})," in the ",(0,s.jsx)(n.code,{children:"NodeRole"})," column of ",(0,s.jsx)(n.code,{children:"SHOW BACKENDS"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"using-compute-nodes",children:"Using Compute Nodes"}),"\n",(0,s.jsxs)(n.p,{children:["You need to configure the following parameters in the FE configuration file ",(0,s.jsx)(n.code,{children:"fe.conf"})," to enable compute nodes and control their behavior:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"prefer_compute_node_for_external_table"})}),(0,s.jsxs)(n.td,{children:["Default is ",(0,s.jsx)(n.code,{children:"false"}),". If set to ",(0,s.jsx)(n.code,{children:"true"}),", queries for external tables will be preferentially assigned to compute nodes. If ",(0,s.jsx)(n.code,{children:"false"}),", queries for external tables will be assigned to any BE node. If there are no compute nodes in the cluster, this parameter has no effect."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"min_backend_num_for_external_table"})}),(0,s.jsxs)(n.td,{children:["Only effective when ",(0,s.jsx)(n.code,{children:"prefer_compute_node_for_external_table"})," is ",(0,s.jsx)(n.code,{children:"true"}),". If the number of compute nodes in the cluster is less than this value, queries for external tables will attempt to acquire some mixed nodes to allocate, so that the total number of nodes reaches this value. If the number of compute nodes in the cluster is greater than this value, queries for external tables will only be assigned to compute nodes. Before version 2.0 (inclusive), the default value of this parameter was 3. After version 2.1, the default value is ",(0,s.jsx)(n.code,{children:"-1"}),", which means only the current number of compute nodes will be used."]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Further explanation of ",(0,s.jsx)(n.code,{children:"min_backend_num_for_external_table"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Assume there are 3 compute nodes and 5 mixed nodes in the cluster."}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"min_backend_num_for_external_table"})," is set to less than or equal to 3, then external table queries will only use 3 compute nodes. If set to greater than 3, say 6, then external table queries will use 3 compute nodes plus an additional 3 mixed nodes for computation."]}),"\n",(0,s.jsx)(n.p,{children:"In summary, this parameter is mainly used for the minimum number of BE nodes that can participate in external table computation, and will preferentially select compute nodes. Increasing this parameter will allow more BE nodes (not limited to compute nodes) to participate in external table query processing; decreasing this parameter can limit the number of BE nodes participating in external table query processing."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Note:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["After version 2.1, ",(0,s.jsx)(n.code,{children:"min_backend_num_for_external_table"})," can be set to ",(0,s.jsx)(n.code,{children:"-1"}),". In previous versions, this parameter must be a positive number. This parameter is only effective when ",(0,s.jsx)(n.code,{children:"prefer_compute_node_for_external_table = true"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If the value of ",(0,s.jsx)(n.code,{children:"min_backend_num_for_external_table"})," is greater than the total number of BE nodes, at most all BEs will be selected."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The above parameters can be dynamically modified using the ",(0,s.jsx)(n.code,{children:"ADMIN SET FRONTEND CONFIG"})," command without restarting the FE node. All FE nodes need to be configured. Alternatively, add the configuration in ",(0,s.jsx)(n.code,{children:"fe.conf"})," and restart the FE node."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"resource-isolation-and-elastic-scaling-of-federated-queries",children:"Resource Isolation and Elastic Scaling of Federated Queries"}),"\n",(0,s.jsx)(n.p,{children:"In federated query scenarios, users can deploy a dedicated set of compute nodes for querying external table data. This allows the isolation of external table query loads (such as large-scale analysis on Hive) from internal table query loads (such as low-latency fast data analysis)."}),"\n",(0,s.jsx)(n.p,{children:"At the same time, as stateless BE nodes, compute nodes can be easily scaled up and down. For example, a set of elastic compute node clusters can be deployed using k8s, utilizing more compute nodes for data lake analysis during peak business periods, and quickly scaling down during off-peak periods to reduce costs."}),"\n",(0,s.jsx)(n.h2,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Can mixed nodes and compute nodes be converted to each other?"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Compute nodes can be converted to mixed nodes. However, mixed nodes cannot be converted to compute nodes."}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Do compute nodes need to configure data storage directories?"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Yes. The data storage directory of compute nodes will not store user data, only some information files of the BE node itself, such as ",(0,s.jsx)(n.code,{children:"cluster_id"}),", and some temporary files during operation."]}),"\n",(0,s.jsx)(n.p,{children:"The storage directory of compute nodes requires only a small amount of disk space (MB level) and can be destroyed at any time along with the node without affecting user data."}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Can compute nodes and mixed nodes configure file cache directories?"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/docs/3.x/lakehouse/data-cache",children:"File cache"})," accelerates subsequent queries of the same data by caching data files from recently accessed remote storage systems (HDFS or object storage)."]}),"\n",(0,s.jsx)(n.p,{children:"Both compute nodes and mixed nodes can set up file cache directories. The file cache directory needs to be created in advance."}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"Do compute nodes need to be decommissioned through the DECOMMISION operation?"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["No. Compute nodes can be directly deleted using the ",(0,s.jsx)(n.code,{children:"DROP BACKEND"})," operation."]})]})}function u(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return d},a:function(){return i}});var o=t(667294);let s={},a=o.createContext(s);function i(e){let n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);