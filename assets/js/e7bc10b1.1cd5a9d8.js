"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["976821"],{638048:function(e,r,a){a.r(r),a.d(r,{default:()=>d,frontMatter:()=>o,metadata:()=>n,assets:()=>m,toc:()=>c,contentTitle:()=>s});var n=JSON.parse('{"id":"admin-manual/trouble-shooting/memory-management/memory-analysis/query-cancelled-after-query-memory-exceeded","title":"Query error Memory Tracker Limit Exceeded","description":"When MEMLIMITEXCEEDED appears in the query or load error message and contains memory tracker limit exceeded, it means that the task exceeds the single execution memory limit.","source":"@site/docs/admin-manual/trouble-shooting/memory-management/memory-analysis/query-cancelled-after-query-memory-exceeded.md","sourceDirName":"admin-manual/trouble-shooting/memory-management/memory-analysis","slug":"/admin-manual/trouble-shooting/memory-management/memory-analysis/query-cancelled-after-query-memory-exceeded","permalink":"/docs/dev/admin-manual/trouble-shooting/memory-management/memory-analysis/query-cancelled-after-query-memory-exceeded","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Query error Memory Tracker Limit Exceeded","language":"en"},"sidebar":"docs","previous":{"title":"Query error Process Memory Not Enough","permalink":"/docs/dev/admin-manual/trouble-shooting/memory-management/memory-analysis/query-cancelled-after-process-memory-exceeded"},"next":{"title":"OOM Killer Crash Analysis","permalink":"/docs/dev/admin-manual/trouble-shooting/memory-management/memory-analysis/oom-crash-analysis"}}'),i=a("785893"),t=a("250065");let o={title:"Query error Memory Tracker Limit Exceeded",language:"en"},s=void 0,m={},c=[{value:"Error message analysis",id:"error-message-analysis",level:2},{value:"Single execution memory limit and memory over-issuance",id:"single-execution-memory-limit-and-memory-over-issuance",level:2},{value:"Query Memory Analysis",id:"query-memory-analysis",level:2}];function l(e){let r={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["When ",(0,i.jsx)(r.code,{children:"MEM_LIMIT_EXCEEDED"})," appears in the query or load error message and contains ",(0,i.jsx)(r.code,{children:"memory tracker limit exceeded"}),", it means that the task exceeds the single execution memory limit."]}),"\n",(0,i.jsx)(r.h2,{id:"error-message-analysis",children:"Error message analysis"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-sql",children:"ERROR 1105 (HY000): errCode = 2, detailMessage = (10.16.10.8)[MEM_LIMIT_EXCEEDED]PreCatch error code:11, [E11] Allocator mem tracker check failed, [MEM_LIMIT_EXCEEDED] failed alloc size 1.03 MB, memory tracker limit exceeded, tracker label :Query#Id=f78208b15e064527-a84c5c0b04c04fcf, type:query, limit 100.00 MB, peak used 99.29 MB, current used 99.25 MB. backend 10.16.10.8, process memory used 2.65 GB. exec node:<execute:<ExecNode:VHASH_JOIN _NODE (id=4)>>, can `set exec_mem_limit=8G` to change limit, details see be.INFO.\n"})}),"\n",(0,i.jsx)(r.p,{children:"The error message is divided into two parts:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"failed alloc size 1.03 MB, memory tracker limit exceeded, tracker label:Query#Id=f78208b15e064527-a84c5c0b04c04fcf, type:query, limit 100.00 MB, peak used 99.29 MB, current used 99.25 MB"}),": Query ",(0,i.jsx)(r.code,{children:"f78208b15e064527-a84c5c0b04c04fcf"})," is currently being executed. When trying to apply for 1.03 MB of memory, it was found that the query exceeded the memory limit for a single execution. The query memory limit is 100 MB (",(0,i.jsx)(r.code,{children:"exec_mem_limit"})," in Session Variables). Currently, 99.25 MB has been used, and the peak memory is 99.29. MB."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"backend 10.16.10.8, process memory used 2.65 GB. exec node:<execute:<ExecNode:VHASH_JOIN_NODE (id=4)>>, can set exec_mem_limit=8G to change limit, details see be.INFO."}),": The location of this memory application is ",(0,i.jsx)(r.code,{children:"VHASH_JOIN_NODE (id=4)"}),", and it is prompted that the memory limit of a single query can be increased by ",(0,i.jsx)(r.code,{children:"set exec_mem_limit"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"single-execution-memory-limit-and-memory-over-issuance",children:"Single execution memory limit and memory over-issuance"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"show variables;"})," You can view Doris Session Veriable, where ",(0,i.jsx)(r.code,{children:"exec_mem_limit"})," is the execution memory limit for a single query and load, but since Doris 1.2, query memory over-issuance (overcommit) is supported, aiming to allow queries to set more flexible memory limits. When there is sufficient memory, even if the query memory exceeds the upper limit, it will not be Cancel, so users usually do not need to pay attention to query memory usage. Until the memory is insufficient, the query will wait for a while while trying to allocate new memory. At this time, based on certain rules, the query with a larger ratio of ",(0,i.jsx)(r.code,{children:"mem_used"})," to ",(0,i.jsx)(r.code,{children:"exec_mem_limit"})," will be canceled first. If the amount of memory released during the waiting process meets the requirements, the query will continue to execute, otherwise an exception will be thrown and the query will be terminated."]}),"\n",(0,i.jsxs)(r.p,{children:["If you want to turn off query memory over-issuance, refer to ",(0,i.jsx)(r.a,{href:"../../../config/be-config",children:"BE Configuration Items"})," and add ",(0,i.jsx)(r.code,{children:"enable_query_memory_overcommit=false"})," in ",(0,i.jsx)(r.code,{children:"conf/be.conf"}),". At this time, a single query and load memory exceeding ",(0,i.jsx)(r.code,{children:"exec_mem_limit"})," will be canceled. If you want to avoid the negative impact of large queries on cluster stability, or want to accurately control the execution of tasks on the cluster to ensure sufficient stability, then you can consider turning off query memory over-issuance."]}),"\n",(0,i.jsx)(r.h2,{id:"query-memory-analysis",children:"Query Memory Analysis"}),"\n",(0,i.jsxs)(r.p,{children:["If you need to analyze the memory usage of queries, refer to ",(0,i.jsx)(r.a,{href:"/docs/dev/admin-manual/trouble-shooting/memory-management/memory-analysis/query-memory-analysis",children:"Query Memory Analysis"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["After ",(0,i.jsx)(r.code,{children:"set enable_profile=true"})," is used to enable Query Profile, when a task exceeds the memory limit for a single execution, the call stack of the query requesting memory will be printed in ",(0,i.jsx)(r.code,{children:"be/log/be.INFO"}),", and the current memory used and peak value of each operator in the query can be seen. Refer to ",(0,i.jsx)(r.a,{href:"/docs/dev/admin-manual/trouble-shooting/memory-management/memory-analysis/memory-log-analysis",children:"Memory Log Analysis"})," to analyze ",(0,i.jsx)(r.code,{children:"Process Memory Summary"})," and ",(0,i.jsx)(r.code,{children:"Memory Tracker Summary"})," to help confirm whether the current query memory usage meets expectations."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-sql",children:"Allocator mem tracker check failed, [MEM_LIMIT_EXCEEDED]failed alloc size 32.00 MB, memory tracker limit exceeded, tracker label:Query#I\nd=41363cb6ba734ad5-bc8720bdf9b3090d, type:query, limit 100.00 MB, peak used 75.32 MB, current used 72.62 MB. backend 10.16.10.8, process memory used 2.33 GB. exec node:<>, can `set exec_mem_limit=8G`\n to change limit, details see be.INFO.\nProcess Memory Summary:\n    os physical memory 375.81 GB. process memory used 2.33 GB(= 2.60 GB[vm/rss] - 280.53 MB[tc/jemalloc_cache] + 0[reserved] + 0B[waiting_refresh]), limit 338.23 GB, soft limit 304.41 GB. sys availab\nle memory 337.33 GB(= 337.33 GB[proc/available] - 0[reserved] - 0B[waiting_refresh]), low water mark 6.40 GB, warning water mark 12.80 GB.\nMemory Tracker Summary:    MemTrackerLimiter Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Type=query, Limit=100.00 MB(104857600 B), Used=72.62 MB(76146688 B), Peak=75.32 MB(78981248 B)\n    MemTracker Label=HASH_JOIN_SINK_OPERATOR, Parent Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Used=122.00 B(122 B), Peak=122.00 B(122 B)\n    MemTracker Label=VDataStreamRecvr:41363cb6ba734ad5-bc8720bdf9b309fe, Parent Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Used=0(0 B), Peak=384.00 B(384 B)\n    MemTracker Label=local data queue mem tracker, Parent Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Used=0(0 B), Peak=384.00 B(384 B)\n    MemTracker Label=HASH_JOIN_SINK_OPERATOR, Parent Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Used=21.73 MB(22790276 B), Peak=21.73 MB(22790276 B)\n    MemTracker Label=VDataStreamRecvr:41363cb6ba734ad5-bc8720bdf9b309fe, Parent Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Used=0(0 B), Peak=2.23 MB(2342912 B)\n    MemTracker Label=local data queue mem tracker, Parent Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Used=0(0 B), Peak=2.23 MB(2342912 B)\n    MemTracker Label=HASH_JOIN_SINK_OPERATOR, Parent Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Used=24.03 MB(25201284 B), Peak=24.03 MB(25201284 B)\n    MemTracker Label=VDataStreamRecvr:41363cb6ba734ad5-bc8720bdf9b309fe, Parent Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Used=1.08 MB(1130496 B), Peak=7.17 MB(7520256 B)\n    MemTracker Label=local data queue mem tracker, Parent Label=Query#Id=41363cb6ba734ad5-bc8720bdf9b3090d, Used=1.08 MB(1130496 B), Peak=7.17 MB(7520256 B)\n"})})]})}function d(e={}){let{wrapper:r}={...(0,t.a)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},250065:function(e,r,a){a.d(r,{Z:function(){return s},a:function(){return o}});var n=a(667294);let i={},t=n.createContext(i);function o(e){let r=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(t.Provider,{value:r},e.children)}}}]);