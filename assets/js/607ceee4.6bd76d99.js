"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["159488"],{902910:function(e,n,t){t.r(n),t.d(n,{default:()=>u,frontMatter:()=>i,metadata:()=>s,assets:()=>c,toc:()=>d,contentTitle:()=>a});var s=JSON.parse('{"id":"install/deploy-on-kubernetes/separating-storage-compute/config-cg","title":"Config ComputeGroups","description":"In a decoupled storage and compute cluster, the Compute Group is responsible for importing data and caching data from object storage to enhance query ","source":"@site/versioned_docs/version-4.x/install/deploy-on-kubernetes/separating-storage-compute/config-cg.md","sourceDirName":"install/deploy-on-kubernetes/separating-storage-compute","slug":"/install/deploy-on-kubernetes/separating-storage-compute/config-cg","permalink":"/docs/4.x/install/deploy-on-kubernetes/separating-storage-compute/config-cg","draft":false,"unlisted":false,"tags":[],"version":"4.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Config ComputeGroups","language":"en","description":"In a decoupled storage and compute cluster, the Compute Group is responsible for importing data and caching data from object storage to enhance query "},"sidebar":"docs","previous":{"title":"Config FE","permalink":"/docs/4.x/install/deploy-on-kubernetes/separating-storage-compute/config-fe"},"next":{"title":"Deploy Doris Cluster","permalink":"/docs/4.x/install/deploy-on-kubernetes/separating-storage-compute/install-doris-cluster"}}'),o=t("785893"),r=t("250065");let i={title:"Config ComputeGroups",language:"en",description:"In a decoupled storage and compute cluster, the Compute Group is responsible for importing data and caching data from object storage to enhance query "},a=void 0,c={},d=[{value:"Minimal Compute Group Configuration",id:"minimal-compute-group-configuration",level:2},{value:"Configuring Multiple Compute Groups",id:"configuring-multiple-compute-groups",level:2},{value:"Configure Compute Resources",id:"configure-compute-resources",level:2},{value:"Access Configuration",id:"access-configuration",level:2},{value:"ClusterIP",id:"clusterip",level:3},{value:"Step 1: Configure the Service Type as ClusterIP",id:"step-1-configure-the-service-type-as-clusterip",level:4},{value:"Step 2: Obtain the Service Access Address",id:"step-2-obtain-the-service-access-address",level:4},{value:"NodePort",id:"nodeport",level:3},{value:"Static Configuration",id:"static-configuration",level:4},{value:"Dynamic Configuration",id:"dynamic-configuration",level:4},{value:"LoadBalancer Mode",id:"loadbalancer-mode",level:3},{value:"Custom Startup Configuration",id:"custom-startup-configuration",level:2},{value:"Persistent Storage Configuration",id:"persistent-storage-configuration",level:2},{value:"Persistent Storage Example",id:"persistent-storage-example",level:3},{value:"Disable Log Persistence",id:"disable-log-persistence",level:3}];function l(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"In a decoupled storage and compute cluster, the Compute Group is responsible for importing data and caching data from object storage to enhance query performance. Compute groups are isolated from each other."}),"\n",(0,o.jsx)(n.h2,{id:"minimal-compute-group-configuration",children:"Minimal Compute Group Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["A compute group is a collection of BE nodes that perform identical tasks. When configuring the ",(0,o.jsx)(n.code,{children:"DorisDisaggregatedCluster"})," resource, each compute group must be assigned a unique identifier that also serves as its name, which cannot be modified once set. A minimal compute group configuration consists of three components: ",(0,o.jsx)(n.code,{children:"uniqueId"}),", ",(0,o.jsx)(n.code,{children:"image"}),", and ",(0,o.jsx)(n.code,{children:"replicas"}),". For example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"spec:\n  computeGroups:\n   - uniqueId: ${uniqueId}\n     image: ${beImage}\n     replicas: 1\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here, ",(0,o.jsx)(n.code,{children:"${beImage}"})," is the image used to deploy the BE service; please use the image provided by the ",(0,o.jsx)(n.a,{href:"https://hub.docker.com/r/apache/doris",children:"Apache Doris official repository"}),". ",(0,o.jsx)(n.code,{children:"${uniqueId}"})," is the unique identifier and name of the compute group, which must match the pattern ",(0,o.jsx)(n.code,{children:"[a-zA-Z][0-9a-zA-Z_]+"}),". The ",(0,o.jsx)(n.code,{children:"replicas"})," field specifies the number of BE nodes within the compute group."]}),"\n",(0,o.jsx)(n.h2,{id:"configuring-multiple-compute-groups",children:"Configuring Multiple Compute Groups"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"DorisDisaggregatedCluster"})," resource supports the deployment of multiple independent compute groups. The following example shows a configuration with two compute groups, ",(0,o.jsx)(n.code,{children:"cg1"})," and ",(0,o.jsx)(n.code,{children:"cg2"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"spec:\n  computeGroups:\n  - uniqueId: cg1\n    image: ${beImage}\n    replicas: 3\n  - uniqueId: cg2\n    image: ${beImage}\n    replicas: 2\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, compute group ",(0,o.jsx)(n.code,{children:"cg1"})," has 3 replicas, and compute group ",(0,o.jsx)(n.code,{children:"cg2"})," has 2 replicas. Although compute groups are isolated, it is recommended that the BE nodes within each group use the same image across the decoupled cluster."]}),"\n",(0,o.jsx)(n.h2,{id:"configure-compute-resources",children:"Configure Compute Resources"}),"\n",(0,o.jsxs)(n.p,{children:["In the default deployment sample for a decoupled cluster, there are no resource restrictions on the BE service. The ",(0,o.jsx)(n.code,{children:"DorisDisaggregatedCluster"})," resource uses Kubernetes ",(0,o.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits",children:"resources.requests and resources.limits"})," to specify CPU and memory resources. For example, to allocate 8 CPU cores and 8Gi memory for the BE nodes in compute group ",(0,o.jsx)(n.code,{children:"cg1"}),", use the following configuration:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"spec:\n  computeGroups:\n  - uniqueId: cg1\n    requests:\n      cpu: 8\n      memory: 8Gi\n    limits:\n      cpu: 8\n      memory: 8Gi\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Apply this configuration to the appropriate ",(0,o.jsx)(n.a,{href:"/docs/4.x/install/deploy-on-kubernetes/separating-storage-compute/install-doris-cluster#step-3-deploy-the-compute-storage-decoupled-cluster",children:"DorisDisaggregatedCluster resource"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"access-configuration",children:"Access Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["By default, compute groups do not expose services externally. The Doris Operator provides a Service as a proxy for compute groups within the ",(0,o.jsx)(n.code,{children:"DorisDisaggregatedCluster"})," resource. Three service exposure modes are supported: ",(0,o.jsx)(n.code,{children:"ClusterIP"}),", ",(0,o.jsx)(n.code,{children:"NodePort"}),", and ",(0,o.jsx)(n.code,{children:"LoadBalancer"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"clusterip",children:"ClusterIP"}),"\n",(0,o.jsxs)(n.p,{children:["Kubernetes uses the ",(0,o.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#type-clusterip",children:"ClusterIP service type"})," by default, which provides an internal address within the cluster."]}),"\n",(0,o.jsx)(n.h4,{id:"step-1-configure-the-service-type-as-clusterip",children:"Step 1: Configure the Service Type as ClusterIP"}),"\n",(0,o.jsx)(n.p,{children:"Doris is configured to use ClusterIP mode by default in Kubernetes; no additional configuration is required."}),"\n",(0,o.jsx)(n.h4,{id:"step-2-obtain-the-service-access-address",children:"Step 2: Obtain the Service Access Address"}),"\n",(0,o.jsx)(n.p,{children:"After deploying the cluster, use the following command to view the Service exposed for the compute group:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"kubectl -n doris get svc\n"})}),"\n",(0,o.jsx)(n.p,{children:"A sample output is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"NAME                                     TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                               AGE\ntest-disaggregated-cluster-cg1           ClusterIP   10.152.183.154   <none>        9060/TCP,8040/TCP,9050/TCP,8060/TCP   2d\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This output shows the Service for the compute group with a ",(0,o.jsx)(n.code,{children:"uniqueId"})," of ",(0,o.jsx)(n.code,{children:"cg1"})," in the ",(0,o.jsx)(n.code,{children:"doris"})," namespace."]}),"\n",(0,o.jsx)(n.h3,{id:"nodeport",children:"NodePort"}),"\n",(0,o.jsxs)(n.p,{children:["If external access to Doris is required from outside the Kubernetes cluster, the ",(0,o.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport",children:"NodePort service type"})," can be used. NodePort supports two configuration methods: static host port mapping and dynamic host port assignment."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Dynamic Host Port Assignment:\nIf no explicit port mapping is provided, Kubernetes will automatically assign an unused host port (default range: 30000\u201332767) when the pod is created."}),"\n",(0,o.jsx)(n.li,{children:"Static Host Port Mapping:\nIf a port mapping is specified, and the host port is available, Kubernetes will allocate that port. For static assignment, you must plan the port mappings. Doris provides the following port for external interactions:"}),"\n"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Port Name"}),(0,o.jsx)(n.th,{children:"Default Port"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Web Server Port"}),(0,o.jsx)(n.td,{children:"8040"}),(0,o.jsx)(n.td,{children:"The HTTP server port on BE, used to view BE information."})]})})]}),"\n",(0,o.jsx)(n.h4,{id:"static-configuration",children:"Static Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["For compute group ",(0,o.jsx)(n.code,{children:"cg1"}),", the static NodePort configuration is as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"spec:\n  computeGroups:\n    - uniqueId: cg1\n      service:\n        type: NodePort\n        portMaps:\n          - nodePort: 31012\n            targetPort: 8040\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this configuration, the BE listening port 8040 for compute group ",(0,o.jsx)(n.code,{children:"cg1"})," is mapped to host port 31012."]}),"\n",(0,o.jsx)(n.h4,{id:"dynamic-configuration",children:"Dynamic Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["For compute group ",(0,o.jsx)(n.code,{children:"cg1"}),", the dynamic NodePort configuration is as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"spec:\n  computeGroups:\n    - uniqueId: cg1\n      service:\n        type: NodePort\n"})}),"\n",(0,o.jsx)(n.h3,{id:"loadbalancer-mode",children:"LoadBalancer Mode"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer",children:"LoadBalancer service"})," type is applicable in cloud-based Kubernetes environments and is provided by the cloud provider's load balancer.\nSet the ",(0,o.jsx)(n.code,{children:"computeGroup.service"})," type to LoadBalancer, as shown:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'spec:\n  feSpec:\n    service:\n      type: LoadBalancer\n      annotations:\n        service.beta.kubernetes.io/load-balancer-type: "external"\n'})}),"\n",(0,o.jsx)(n.h2,{id:"custom-startup-configuration",children:"Custom Startup Configuration"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Create a Custom ConfigMap Containing Startup Information\nIn the default deployment, each compute group's BE service starts with a default configuration file embedded in the image. The Doris Operator uses a Kubernetes ConfigMap to mount a custom startup configuration file. Below is an example ConfigMap for a BE service:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: be-configmap\n  labels:\n    app.kubernetes.io/component: be\ndata:\n  be.conf: |\n    # For JDK 17, these JAVA_OPTS serve as the default JVM options\n    JAVA_OPTS_FOR_JDK_17="-Xmx1024m -DlogPath=$LOG_DIR/jni.log -Xlog:gc*:$LOG_DIR/be.gc.log.$CUR_DATE:time,uptime:filecount=10,filesize=50M -Djavax.security.auth.useSubjectCredsOnly=false -Dsun.security.krb5.debug=true -Dsun.java.command=DorisBE -XX:-CriticalJNINatives -XX:+IgnoreUnrecognizedVMOptions --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.lang.invoke=ALL-UNNAMED --add-opens=java.base/java.lang.reflect=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED --add-opens=java.base/java.nio=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.base/java.util.concurrent.atomic=ALL-UNNAMED --add-opens=java.base/sun.nio.ch=ALL-UNNAMED --add-opens=java.base/sun.nio.cs=ALL-UNNAMED --add-opens=java.base/sun.security.action=ALL-UNNAMED --add-opens=java.base/sun.util.calendar=ALL-UNNAMED --add-opens=java.security.jgss/sun.security.krb5=ALL-UNNAMED --add-opens=java.management/sun.management=ALL-UNNAMED"\n    file_cache_path = [{"path":"/opt/apache-doris/be/file_cache","total_size":107374182400,"query_limit":107374182400}]\n    deploy_mode = cloud\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The startup configuration for the BE service in a decoupled cluster must include the file_cache_path setting. For the required format, please refer to the ",(0,o.jsx)(n.a,{href:"/docs/4.x/compute-storage-decoupled/compilation-and-deployment#541-configure-beconf",children:"Doris decoupled configuration for be.conf"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Deploy the ConfigMap\nUse the following command to deploy the custom ConfigMap containing the startup configuration to the Kubernetes cluster:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"kubectl -n ${namespace} -f ${beConfigMapFileName}.yaml\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here, ",(0,o.jsx)(n.code,{children:"${namespace}"})," is the namespace where the ",(0,o.jsx)(n.code,{children:"DorisDisaggregatedCluster"})," is deployed, and ",(0,o.jsx)(n.code,{children:"${beConfigMapFileName}"})," is the name of the file containing the custom ConfigMap."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Update the DorisDisaggregatedCluster Resource to Use the ConfigMap\nModify the resource to mount the ConfigMap at the required location, as shown below:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'spec:\n  computeGroups:\n  - uniqueId: cg1\n    configMaps:\n    - name: be-configmap\n      mountPath: "/etc/doris"\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{title:"Note",type:"tip",children:(0,o.jsxs)(n.p,{children:["The startup configuration must be mounted at the ",(0,o.jsx)(n.code,{children:"/etc/doris"})," directory."]})}),"\n",(0,o.jsx)(n.h2,{id:"persistent-storage-configuration",children:"Persistent Storage Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["In the default deployment, the BE service uses Kubernetes ",(0,o.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/storage/volumes/#emptydir",children:(0,o.jsx)(n.code,{children:"EmptyDir"})})," as its cache. EmptyDir is a non-persistent storage mode, meaning that cached data is lost after the service restarts, which can reduce query performance."]}),"\n",(0,o.jsxs)(n.p,{children:["To ensure that cached data is retained after service restarts and query efficiency is not degraded, persistent storage should be configured for the cache. The BE service logs are output both to standard output and to the directory specified by the ",(0,o.jsx)(n.code,{children:"LOG_DIR"})," parameter in the startup configuration. In addition, the StreamLoad import process uses ",(0,o.jsx)(n.code,{children:"/opt/apache-doris/be/storage"})," as a temporary storage location. To prevent data loss caused by unexpected service restarts, persistent storage should be mounted for this directory as well."]}),"\n",(0,o.jsx)(n.h3,{id:"persistent-storage-example",children:"Persistent Storage Example"}),"\n",(0,o.jsx)(n.p,{children:"The following is an example configuration for mounting persistent storage to the required data directories:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"spec:\n  computeGroups:\n  - uniqueId: cg1\n    persistentVolumes:\n    - mountPaths:\n      - /opt/apache-doris/be/log\n      persistentVolumeClaimSpec:\n        # storageClassName: ${storageclass_name}\n        accessModes:\n        - ReadWriteOnce\n        resources:\n          requests:\n            storage: 300Gi\n    - mountPaths:\n      - /opt/apache-doris/be/storage\n      persistentVolumeClaimSpec:\n        # storageClassName: ${storageclass_name}\n        accessModes:\n        - ReadWriteOnce\n        resources:\n          requests:\n            storage: 300Gi\n    - persistentVolumeClaimSpec:\n        # storageClassName: ${storageclass_name}\n        accessModes:\n        - ReadWriteOnce\n        resources:\n          requests:\n            storage: 500Gi\n"})}),"\n",(0,o.jsx)(n.p,{children:"In this configuration, a 300Gi persistent volume is mounted to the log directory using a custom storage configuration. Another 300Gi persistent volume is mounted to the directory used for WAL and StreamLoad imports. The cache directory is mounted with a 500Gi persistent volume created from a storage template."}),"\n",(0,o.jsx)(n.admonition,{title:"Note",type:"tip",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["If the mountPaths array is left empty, the current storage configuration is treated as a template. When users specify file_cache_path in the ",(0,o.jsx)(n.a,{href:"#custom-startup-configuration",children:"startup configuration"}),", the operator automatically parses the directory path and mounts it."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"It is recommended to configure four directories and mount four persistent volumes to maximize cloud disk performance."}),"\n"]}),"\n"]})}),"\n",(0,o.jsx)(n.h3,{id:"disable-log-persistence",children:"Disable Log Persistence"}),"\n",(0,o.jsx)(n.p,{children:"If log persistence is not required and logs should only be output to the standard output, configure as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"spec:\n  computeGroups:\n    - uniqueId: cg1\n      logNotStore: true\n"})})]})}function u(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return i}});var s=t(667294);let o={},r=s.createContext(o);function i(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);