"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["403380"],{67503:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>a,metadata:()=>i,assets:()=>l,toc:()=>d,contentTitle:()=>o});var i=JSON.parse('{"id":"sql-manual/sql-reference/Data-Manipulation-Statements/Load/CREATE-ROUTINE-LOAD","title":"CREATE-ROUTINE-LOAD","description":"CREATE-ROUTINE-LOAD","source":"@site/versioned_docs/version-2.0/sql-manual/sql-reference/Data-Manipulation-Statements/Load/CREATE-ROUTINE-LOAD.md","sourceDirName":"sql-manual/sql-reference/Data-Manipulation-Statements/Load","slug":"/sql-manual/sql-reference/Data-Manipulation-Statements/Load/CREATE-ROUTINE-LOAD","permalink":"/docs/2.0/sql-manual/sql-reference/Data-Manipulation-Statements/Load/CREATE-ROUTINE-LOAD","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"CREATE-ROUTINE-LOAD","language":"en"},"sidebar":"docs","previous":{"title":"MYSQL-LOAD","permalink":"/docs/2.0/sql-manual/sql-reference/Data-Manipulation-Statements/Load/MYSQL-LOAD"},"next":{"title":"ALTER-ROUTINE-LOAD","permalink":"/docs/2.0/sql-manual/sql-reference/Data-Manipulation-Statements/Load/ALTER-ROUTINE-LOAD"}}'),r=t("785893"),s=t("250065");let a={title:"CREATE-ROUTINE-LOAD",language:"en"},o=void 0,l={},d=[{value:"CREATE-ROUTINE-LOAD",id:"create-routine-load",level:2},{value:"Name",id:"name",level:3},{value:"Description",id:"description",level:3},{value:"Example",id:"example",level:3},{value:"Keywords",id:"keywords",level:3},{value:"Best Practice",id:"best-practice",level:3}];function c(e){let n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"create-routine-load",children:"CREATE-ROUTINE-LOAD"}),"\n",(0,r.jsx)(n.h3,{id:"name",children:"Name"}),"\n",(0,r.jsx)(n.p,{children:"CREATE ROUTINE LOAD"}),"\n",(0,r.jsx)(n.h3,{id:"description",children:"Description"}),"\n",(0,r.jsx)(n.p,{children:"The Routine Load function allows users to submit a resident import task, and import data into Doris by continuously reading data from a specified data source."}),"\n",(0,r.jsxs)(n.p,{children:["Currently, only data in CSV or Json format can be imported from Kakfa through unauthenticated or SSL authentication. ",(0,r.jsx)(n.a,{href:"../../../../data-operate/import/load-json-format",children:"Example of importing data in Json format"})]}),"\n",(0,r.jsx)(n.p,{children:"grammar:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD [db.]job_name [ON tbl_name]\n[merge_type]\n[load_properties]\n[job_properties]\nFROM data_source [data_source_properties]\n[COMMENT "comment"]\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"[db.]job_name"})}),"\n",(0,r.jsx)(n.p,{children:"The name of the import job. Within the same database, only one job with the same name can be running."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"tbl_name"})}),"\n",(0,r.jsx)(n.p,{children:'Specifies the name of the table to be imported.Optional parameter, If not specified, the dynamic table method will\nbe used, which requires the data in Kafka to contain table name information. Currently, only the table name can be\nobtained from the Kafka value, and it needs to conform to the format of "table_name|{"col1": "val1", "col2": "val2"}"\nfor JSON data. The "tbl_name" represents the table name, and "|" is used as the delimiter between the table name and\nthe table data. The same format applies to CSV data, such as "table_name|val1,val2,val3". It is important to note that\nthe "table_name" must be consistent with the table name in Doris, otherwise it may cause import failures.'}),"\n",(0,r.jsxs)(n.p,{children:["Tips: The ",(0,r.jsx)(n.code,{children:"columns_mapping"})," parameter is not supported for dynamic tables. If your table structure is consistent with\nthe table structure in Doris and there is a large amount of table information to be imported, this method will be the\nbest choice."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"merge_type"})}),"\n",(0,r.jsx)(n.p,{children:"Data merge type. The default is APPEND, which means that the imported data are ordinary append write operations. The MERGE and DELETE types are only available for Unique Key model tables. The MERGE type needs to be used with the [DELETE ON] statement to mark the Delete Flag column. The DELETE type means that all imported data are deleted data."}),"\n",(0,r.jsx)(n.p,{children:"Tips: When using dynamic multiple tables, please note that this parameter should be consistent with the type of each dynamic table, otherwise it will result in import failure."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"load_properties"}),"\n",(0,r.jsx)(n.p,{children:"Used to describe imported data. The composition is as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-SQL",children:"[column_separator],\n[columns_mapping],\n[preceding_filter],\n[where_predicates],\n[partitions],\n[DELETE ON],\n[ORDER BY]\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"column_separator"})}),"\n",(0,r.jsxs)(n.p,{children:["Specifies the column separator, defaults to ",(0,r.jsx)(n.code,{children:"\\t"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'COLUMNS TERMINATED BY ","'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"columns_mapping"})}),"\n",(0,r.jsx)(n.p,{children:"It is used to specify the mapping relationship between file columns and columns in the table, as well as various column transformations. For a detailed introduction to this part, you can refer to the [Column Mapping, Transformation and Filtering] document."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"(k1, k2, tmpk1, k3 = tmpk1 + 1)"})}),"\n",(0,r.jsx)(n.p,{children:"Tips: Dynamic multiple tables are not supported."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"preceding_filter"})}),"\n",(0,r.jsx)(n.p,{children:"Filter raw data. For a detailed introduction to this part, you can refer to the [Column Mapping, Transformation and Filtering] document."}),"\n",(0,r.jsx)(n.p,{children:"Tips: Dynamic multiple tables are not supported."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"where_predicates"})}),"\n",(0,r.jsx)(n.p,{children:"Filter imported data based on conditions. For a detailed introduction to this part, you can refer to the [Column Mapping, Transformation and Filtering] document."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"WHERE k1 > 100 and k2 = 1000"})}),"\n",(0,r.jsx)(n.p,{children:"Tips: When using dynamic multiple tables, please note that this parameter should be consistent with the type of each dynamic table, otherwise it will result in import failure."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"partitions"})}),"\n",(0,r.jsx)(n.p,{children:"Specify in which partitions of the import destination table. If not specified, it will be automatically imported into the corresponding partition."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"PARTITION(p1, p2, p3)"})}),"\n",(0,r.jsx)(n.p,{children:"Tips: When using dynamic multiple tables, please note that this parameter should conform to each dynamic table, otherwise it may cause import failure."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"DELETE ON"})}),"\n",(0,r.jsx)(n.p,{children:"It needs to be used with the MEREGE import mode, only for the table of the Unique Key model. Used to specify the columns and calculated relationships in the imported data that represent the Delete Flag."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"DELETE ON v3 >100"})}),"\n",(0,r.jsx)(n.p,{children:"Tips: When using dynamic multiple tables, please note that this parameter should conform to each dynamic table, otherwise it may cause import failure."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"ORDER BY"})}),"\n",(0,r.jsx)(n.p,{children:"Tables only for the Unique Key model. Used to specify the column in the imported data that represents the Sequence Col. Mainly used to ensure data order when importing."}),"\n",(0,r.jsx)(n.p,{children:"Tips: When using dynamic multiple tables, please note that this parameter should conform to each dynamic table, otherwise it may cause import failure."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"job_properties"})}),"\n",(0,r.jsx)(n.p,{children:"Common parameters for specifying routine import jobs."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'PROPERTIES (\n    "key1" = "val1",\n    "key2" = "val2"\n)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Currently we support the following parameters:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"desired_concurrent_number"})}),"\n",(0,r.jsx)(n.p,{children:"Desired concurrency. A routine import job will be divided into multiple subtasks for execution. This parameter specifies the maximum number of tasks a job can execute concurrently. Must be greater than 0. Default is 5."}),"\n",(0,r.jsx)(n.p,{children:"This degree of concurrency is not the actual degree of concurrency. The actual degree of concurrency will be comprehensively considered by the number of nodes in the cluster, the load situation, and the situation of the data source."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"desired_concurrent_number" = "3"'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"max_batch_interval/max_batch_rows/max_batch_size"})}),"\n",(0,r.jsx)(n.p,{children:"These three parameters represent:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"The maximum execution time of each subtask, in seconds. The range is 1 to 60. Default is 10."}),"\n",(0,r.jsx)(n.li,{children:"The maximum number of lines read by each subtask. Must be greater than or equal to 200000. The default is 200000."}),"\n",(0,r.jsx)(n.li,{children:"The maximum number of bytes read by each subtask. The unit is bytes and the range is 100MB to 1GB. The default is 100MB."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These three parameters are used to control the execution time and processing volume of a subtask. When either one reaches the threshold, the task ends."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'"max_batch_interval" = "20",\n"max_batch_rows" = "300000",\n"max_batch_size" = "209715200"\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"max_error_number"})}),"\n",(0,r.jsx)(n.p,{children:"The maximum number of error lines allowed within the sampling window. Must be greater than or equal to 0. The default is 0, which means no error lines are allowed."}),"\n",(0,r.jsxs)(n.p,{children:["The sampling window is ",(0,r.jsx)(n.code,{children:"max_batch_rows * 10"}),". That is, if the number of error lines is greater than ",(0,r.jsx)(n.code,{children:"max_error_number"})," within the sampling window, the routine operation will be suspended, requiring manual intervention to check data quality problems."]}),"\n",(0,r.jsx)(n.p,{children:"Rows that are filtered out by where conditions are not considered error rows."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"strict_mode"})}),"\n",(0,r.jsx)(n.p,{children:"Whether to enable strict mode, the default is off. If enabled, the column type conversion of non-null raw data will be filtered if the result is NULL. Specify as:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"strict_mode" = "true"'})}),"\n",(0,r.jsx)(n.p,{children:"The strict mode mode means strict filtering of column type conversions during the load process. The strict filtering strategy is as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"For column type conversion, if strict mode is true, the wrong data will be filtered. The error data here refers to the fact that the original data is not null, and the result is a null value after participating in the column type conversion."}),"\n",(0,r.jsx)(n.li,{children:"When a loaded column is generated by a function transformation, strict mode has no effect on it."}),"\n",(0,r.jsx)(n.li,{children:"For a column type loaded with a range limit, if the original data can pass the type conversion normally, but cannot pass the range limit, strict mode will not affect it. For example, if the type is decimal(1,0) and the original data is 10, it is eligible for type conversion but not for column declarations. This data strict has no effect on it."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"strict mode and load relationship of source data"})}),"\n",(0,r.jsx)(n.p,{children:"Here is an example of a column type of TinyInt."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Note: When a column in a table allows a null value to be loaded"}),"\n"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"source data"}),(0,r.jsx)(n.th,{children:"source data example"}),(0,r.jsx)(n.th,{children:"string to int"}),(0,r.jsx)(n.th,{children:"strict_mode"}),(0,r.jsx)(n.th,{children:"result"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"null"}),(0,r.jsx)(n.td,{children:"\\N"}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"true or false"}),(0,r.jsx)(n.td,{children:"NULL"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"not null"}),(0,r.jsx)(n.td,{children:"aaa or 2000"}),(0,r.jsx)(n.td,{children:"NULL"}),(0,r.jsx)(n.td,{children:"true"}),(0,r.jsx)(n.td,{children:"invalid data(filtered)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"not null"}),(0,r.jsx)(n.td,{children:"aaa"}),(0,r.jsx)(n.td,{children:"NULL"}),(0,r.jsx)(n.td,{children:"false"}),(0,r.jsx)(n.td,{children:"NULL"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"not null"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"true or false"}),(0,r.jsx)(n.td,{children:"correct data"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Here the column type is Decimal(1,0)"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Note: When a column in a table allows a null value to be loaded"}),"\n"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"source data"}),(0,r.jsx)(n.th,{children:"source data example"}),(0,r.jsx)(n.th,{children:"string to int"}),(0,r.jsx)(n.th,{children:"strict_mode"}),(0,r.jsx)(n.th,{children:"result"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"null"}),(0,r.jsx)(n.td,{children:"\\N"}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"true or false"}),(0,r.jsx)(n.td,{children:"NULL"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"not null"}),(0,r.jsx)(n.td,{children:"aaa"}),(0,r.jsx)(n.td,{children:"NULL"}),(0,r.jsx)(n.td,{children:"true"}),(0,r.jsx)(n.td,{children:"invalid data(filtered)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"not null"}),(0,r.jsx)(n.td,{children:"aaa"}),(0,r.jsx)(n.td,{children:"NULL"}),(0,r.jsx)(n.td,{children:"false"}),(0,r.jsx)(n.td,{children:"NULL"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"not null"}),(0,r.jsx)(n.td,{children:"1 or 10"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"true or false"}),(0,r.jsx)(n.td,{children:"correct data"})]})]})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Note: 10 Although it is a value that is out of range, because its type meets the requirements of decimal, strict mode has no effect on it. 10 will eventually be filtered in other ETL processing flows. But it will not be filtered by strict mode."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"timezone"})}),"\n",(0,r.jsx)(n.p,{children:"Specifies the time zone used by the import job. The default is to use the Session's timezone parameter. This parameter affects the results of all time zone-related functions involved in the import."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"format"})}),"\n",(0,r.jsx)(n.p,{children:"Specify the import data format, the default is csv, and the json format is supported."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"jsonpaths"})}),"\n",(0,r.jsx)(n.p,{children:"When the imported data format is json, the fields in the Json data can be extracted by specifying jsonpaths."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'-H "jsonpaths: [\\"$.k2\\", \\"$.k1\\"]"'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"strip_outer_array"})}),"\n",(0,r.jsx)(n.p,{children:"When the imported data format is json, strip_outer_array is true, indicating that the Json data is displayed in the form of an array, and each element in the data will be regarded as a row of data. The default value is false."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'-H "strip_outer_array: true"'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"json_root"})}),"\n",(0,r.jsx)(n.p,{children:"When the import data format is json, you can specify the root node of the Json data through json_root. Doris will extract the elements of the root node through json_root for parsing. Default is empty."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'-H "json_root: $.RECORDS"'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"send_batch_parallelism"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Integer, Used to set the default parallelism for sending batch, if the value for parallelism exceed ",(0,r.jsx)(n.code,{children:"max_send_batch_parallelism_per_job"})," in BE config, then the coordinator BE will use the value of ",(0,r.jsx)(n.code,{children:"max_send_batch_parallelism_per_job"}),"."]}),"\n",(0,r.jsxs)(n.ol,{start:"11",children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"load_to_single_tablet"}),"\nBoolean type, True means that one task can only load data to one tablet in the corresponding partition at a time. The default value is false. This parameter can only be set when loading data into the OLAP table with random bucketing."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"partial_columns"}),"\nBoolean type, True means that use partial column update, the default value is false, this parameter is only allowed to be set when the table model is Unique and Merge on Write is used. Multi-table does not support this parameter."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"max_filter_ratio"}),"\nThe maximum allowed filtering rate within the sampling window. Must be between 0 and 1. The default value is 0."]}),"\n",(0,r.jsxs)(n.p,{children:["The sampling window is ",(0,r.jsx)(n.code,{children:"max_batch_rows * 10"}),". That is, if the number of error lines / total lines is greater than ",(0,r.jsx)(n.code,{children:"max_filter_ratio"})," within the sampling window, the routine operation will be suspended, requiring manual intervention to check data quality problems."]}),"\n",(0,r.jsx)(n.p,{children:"Rows that are filtered out by where conditions are not considered error rows."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"enclose"}),'\nWhen the csv data field contains row delimiters or column delimiters, to prevent accidental truncation, single-byte characters can be specified as brackets for protection. For example, the column separator is ",", the bracket is "\'", and the data is "a,\'b,c\'", then "b,c" will be parsed as a field.\nNote: when the bracket is ',(0,r.jsx)(n.code,{children:'"'}),", trim_double_quotes must be set to true."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"escape"}),'\nUsed to escape characters that appear in a csv field identical to the enclosing characters. For example, if the data is "a,\'b,\'c\'", enclose is "\'", and you want "b,\'c to be parsed as a field, you need to specify a single-byte escape character, such as "", and then modify the data to "a,\' b,\'c\'".']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"FROM data_source [data_source_properties]"})}),"\n",(0,r.jsx)(n.p,{children:"The type of data source. Currently supports:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'FROM KAFKA\n(\n    "key1" = "val1",\n    "key2" = "val2"\n)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"data_source_properties"})," supports the following data source properties:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"kafka_broker_list"})}),"\n",(0,r.jsx)(n.p,{children:"Kafka's broker connection information. The format is ip:host. Separate multiple brokers with commas."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"kafka_broker_list" = "broker1:9092,broker2:9092"'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"kafka_topic"})}),"\n",(0,r.jsx)(n.p,{children:"Specifies the Kafka topic to subscribe to."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"kafka_topic" = "my_topic"'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"kafka_partitions/kafka_offsets"})}),"\n",(0,r.jsx)(n.p,{children:"Specify the kafka partition to be subscribed to, and the corresponding starting offset of each partition. If a time is specified, consumption will start at the nearest offset greater than or equal to the time."}),"\n",(0,r.jsx)(n.p,{children:"offset can specify a specific offset from 0 or greater, or:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"OFFSET_BEGINNING"}),": Start subscription from where there is data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"OFFSET_END"}),": subscribe from the end."]}),"\n",(0,r.jsx)(n.li,{children:'Time format, such as: "2021-05-22 11:00:00"'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If not specified, all partitions under topic will be subscribed from ",(0,r.jsx)(n.code,{children:"OFFSET_END"})," by default."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'"kafka_partitions" = "0,1,2,3",\n"kafka_offsets" = "101,0,OFFSET_BEGINNING,OFFSET_END"\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'"kafka_partitions" = "0,1,2,3",\n"kafka_offsets" = "2021-05-22 11:00:00,2021-05-22 11:00:00,2021-05-22 11:00:00"\n'})}),"\n",(0,r.jsx)(n.p,{children:"Note that the time format cannot be mixed with the OFFSET format."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"property"})}),"\n",(0,r.jsx)(n.p,{children:'Specify custom kafka parameters. The function is equivalent to the "--property" parameter in the kafka shell.'}),"\n",(0,r.jsx)(n.p,{children:'When the value of the parameter is a file, you need to add the keyword: "FILE:" before the value.'}),"\n",(0,r.jsxs)(n.p,{children:["For how to create a file, please refer to the ",(0,r.jsx)(n.a,{href:"../../../sql-reference/Data-Definition-Statements/Create/CREATE-FILE",children:"CREATE FILE"})," command documentation."]}),"\n",(0,r.jsx)(n.p,{children:"For more supported custom parameters, please refer to the configuration items on the client side in the official CONFIGURATION document of librdkafka. Such as:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'"property.client.id" = "12345",\n"property.ssl.ca.location" = "FILE:ca.pem"\n'})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"When connecting to Kafka using SSL, you need to specify the following parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'"property.security.protocol" = "ssl",\n"property.ssl.ca.location" = "FILE:ca.pem",\n"property.ssl.certificate.location" = "FILE:client.pem",\n"property.ssl.key.location" = "FILE:client.key",\n"property.ssl.key.password" = "abcdefg"\n'})}),"\n",(0,r.jsx)(n.p,{children:"in:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"property.security.protocol"})," and ",(0,r.jsx)(n.code,{children:"property.ssl.ca.location"})," are required to indicate the connection method is SSL and the location of the CA certificate."]}),"\n",(0,r.jsx)(n.p,{children:"If client authentication is enabled on the Kafka server side, thenAlso set:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'"property.ssl.certificate.location"\n"property.ssl.key.location"\n"property.ssl.key.password"\n'})}),"\n",(0,r.jsx)(n.p,{children:"They are used to specify the client's public key, private key, and password for the private key, respectively."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Specify the default starting offset of the kafka partition"}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"kafka_partitions/kafka_offsets"})," is not specified, all partitions are consumed by default."]}),"\n",(0,r.jsxs)(n.p,{children:["At this point, you can specify ",(0,r.jsx)(n.code,{children:"kafka_default_offsets"})," to specify the starting offset. Defaults to ",(0,r.jsx)(n.code,{children:"OFFSET_END"}),", i.e. subscribes from the end."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'"property.kafka_default_offsets" = "OFFSET_BEGINNING"\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"comment\nComment for the routine load job."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Tips",type:"tip",children:(0,r.jsx)(n.p,{children:"This feature is supported since the Apache Doris 1.2 version"})}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a Kafka routine import task named test1 for example_tbl of example_db. Specify the column separator and group.id and client.id, and automatically consume all partitions by default, and start subscribing from the location where there is data (OFFSET_BEGINNING)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test1 ON example_tbl\nCOLUMNS TERMINATED BY ",",\nCOLUMNS(k1, k2, k3, v1, v2, v3 = k1 * 100)\nPROPERTIES\n(\n    "desired_concurrent_number"="3",\n    "max_batch_interval" = "20",\n    "max_batch_rows" = "300000",\n    "max_batch_size" = "209715200",\n    "strict_mode" = "false"\n)\nFROM KAFKA\n(\n    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n    "kafka_topic" = "my_topic",\n    "property.group.id" = "xxx",\n    "property.client.id" = "xxx",\n    "property.kafka_default_offsets" = "OFFSET_BEGINNING"\n);\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'Create a Kafka routine dynamic multiple tables import task named "test1" for the "example_db". Specify the column delimiter, group.id, and client.id, and automatically consume all partitions, subscribing from the position with data (OFFSET_BEGINNING).'}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'Assuming that we need to import data from Kafka into tables "test1" and "test2" in the "example_db", we create a routine import task named "test1". At the same time, we write the data in "test1" and "test2" to a Kafka topic named "my_topic" so that data from Kafka can be imported into both tables through a routine import task.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test1\nPROPERTIES\n(\n    "desired_concurrent_number"="3",\n    "max_batch_interval" = "20",\n    "max_batch_rows" = "300000",\n    "max_batch_size" = "209715200",\n    "strict_mode" = "false"\n)\nFROM KAFKA\n(\n    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n    "kafka_topic" = "my_topic",\n    "property.group.id" = "xxx",\n    "property.client.id" = "xxx",\n    "property.kafka_default_offsets" = "OFFSET_BEGINNING"\n);\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a Kafka routine import task named test1 for example_tbl of example_db. Import tasks are in strict mode."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test1 ON example_tbl\nCOLUMNS(k1, k2, k3, v1, v2, v3 = k1 * 100),\nPRECEDING FILTER k1 = 1,\nWHERE k1 > 100 and k2 like "%doris%"\nPROPERTIES\n(\n    "desired_concurrent_number"="3",\n    "max_batch_interval" = "20",\n    "max_batch_rows" = "300000",\n    "max_batch_size" = "209715200",\n    "strict_mode" = "true"\n)\nFROM KAFKA\n(\n    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n    "kafka_topic" = "my_topic",\n    "kafka_partitions" = "0,1,2,3",\n    "kafka_offsets" = "101,0,0,200"\n);\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Import data from the Kafka cluster through SSL authentication. Also set the client.id parameter. The import task is in non-strict mode and the time zone is Africa/Abidjan"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test1 ON example_tbl\nCOLUMNS(k1, k2, k3, v1, v2, v3 = k1 * 100),\nWHERE k1 > 100 and k2 like "%doris%"\nPROPERTIES\n(\n    "desired_concurrent_number"="3",\n    "max_batch_interval" = "20",\n    "max_batch_rows" = "300000",\n    "max_batch_size" = "209715200",\n    "strict_mode" = "false",\n    "timezone" = "Africa/Abidjan"\n)\nFROM KAFKA\n(\n    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n    "kafka_topic" = "my_topic",\n    "property.security.protocol" = "ssl",\n    "property.ssl.ca.location" = "FILE:ca.pem",\n    "property.ssl.certificate.location" = "FILE:client.pem",\n    "property.ssl.key.location" = "FILE:client.key",\n    "property.ssl.key.password" = "abcdefg",\n    "property.client.id" = "my_client_id"\n);\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Import data in Json format. By default, the field name in Json is used as the column name mapping. Specify to import three partitions 0, 1, and 2, and the starting offsets are all 0"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test_json_label_1 ON table1\nCOLUMNS(category,price,author)\nPROPERTIES\n(\n    "desired_concurrent_number"="3",\n    "max_batch_interval" = "20",\n    "max_batch_rows" = "300000",\n    "max_batch_size" = "209715200",\n    "strict_mode" = "false",\n    "format" = "json"\n)\nFROM KAFKA\n(\n    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n    "kafka_topic" = "my_topic",\n    "kafka_partitions" = "0,1,2",\n    "kafka_offsets" = "0,0,0"\n);\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Import Json data, extract fields through Jsonpaths, and specify the root node of the Json document"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test1 ON example_tbl\nCOLUMNS(category, author, price, timestamp, dt=from_unixtime(timestamp, \'%Y%m%d\'))\nPROPERTIES\n(\n    "desired_concurrent_number"="3",\n    "max_batch_interval" = "20",\n    "max_batch_rows" = "300000",\n    "max_batch_size" = "209715200",\n    "strict_mode" = "false",\n    "format" = "json",\n    "jsonpaths" = "[\\"$.category\\",\\"$.author\\",\\"$.price\\",\\"$.timestamp\\"]",\n    "json_root" = "$.RECORDS"\n    "strip_outer_array" = "true"\n)\nFROM KAFKA\n(\n    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n    "kafka_topic" = "my_topic",\n    "kafka_partitions" = "0,1,2",\n    "kafka_offsets" = "0,0,0"\n);\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Create a Kafka routine import task named test1 for example_tbl of example_db. And use conditional filtering."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test1 ON example_tbl\nWITH MERGE\nCOLUMNS(k1, k2, k3, v1, v2, v3),\nWHERE k1 > 100 and k2 like "%doris%",\nDELETE ON v3 >100\nPROPERTIES\n(\n    "desired_concurrent_number"="3",\n    "max_batch_interval" = "20",\n    "max_batch_rows" = "300000",\n    "max_batch_size" = "209715200",\n    "strict_mode" = "false"\n)\nFROM KAFKA\n(\n    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n    "kafka_topic" = "my_topic",\n    "kafka_partitions" = "0,1,2,3",\n    "kafka_offsets" = "101,0,0,200"\n);\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Import data to Unique with sequence column Key model table"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test_job ON example_tbl\nCOLUMNS TERMINATED BY ",",\nCOLUMNS(k1,k2,source_sequence,v1,v2),\nORDER BY source_sequence\nPROPERTIES\n(\n    "desired_concurrent_number"="3",\n    "max_batch_interval" = "30",\n    "max_batch_rows" = "300000",\n    "max_batch_size" = "209715200"\n) FROM KAFKA\n(\n    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",\n    "kafka_topic" = "my_topic",\n    "kafka_partitions" = "0,1,2,3",\n    "kafka_offsets" = "101,0,0,200"\n);\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Consume from a specified point in time"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE ROUTINE LOAD example_db.test_job ON example_tbl\nPROPERTIES\n(\n    "desired_concurrent_number"="3",\n    "max_batch_interval" = "30",\n    "max_batch_rows" = "300000",\n    "max_batch_size" = "209715200"\n) FROM KAFKA\n(\n    "kafka_broker_list" = "broker1:9092,broker2:9092",\n    "kafka_topic" = "my_topic",\n    "kafka_default_offsets" = "2021-05-21 10:00:00"\n);\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"keywords",children:"Keywords"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"CREATE, ROUTINE, LOAD, CREATE LOAD\n"})}),"\n",(0,r.jsx)(n.h3,{id:"best-practice",children:"Best Practice"}),"\n",(0,r.jsx)(n.p,{children:"Partition and Offset for specified consumption"}),"\n",(0,r.jsx)(n.p,{children:"Doris supports the specified Partition and Offset to start consumption, and also supports the function of consumption at a specified time point. The configuration relationship of the corresponding parameters is described here."}),"\n",(0,r.jsx)(n.p,{children:"There are three relevant parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"kafka_partitions"}),': Specify a list of partitions to be consumed, such as "0, 1, 2, 3".']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"kafka_offsets"}),": Specify the starting offset of each partition, which must correspond to the number of ",(0,r.jsx)(n.code,{children:"kafka_partitions"}),' list. For example: "1000, 1000, 2000, 2000"']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"property.kafka_default_offsets"}),": Specifies the default starting offset of the partition."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When creating an import job, these three parameters can have the following combinations:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Composition"}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"kafka_partitions"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"kafka_offsets"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"property.kafka_default_offsets"})}),(0,r.jsx)(n.th,{children:"Behavior"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"The system will automatically find all partitions corresponding to the topic and start consumption from OFFSET_END"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"The system will automatically find all partitions corresponding to the topic and start consumption from the location specified by default offset"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"The system will start consumption from OFFSET_END of the specified partition"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"The system will start consumption from the specified offset of the specified partition"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"5"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"The system will start consumption from the specified partition, the location specified by default offset"})]})]})]})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return a}});var i=t(667294);let r={},s=i.createContext(r);function a(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);