"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["845617"],{381087:function(e,n,i){i.r(n),i.d(n,{default:()=>h,frontMatter:()=>c,metadata:()=>s,assets:()=>o,toc:()=>a,contentTitle:()=>l});var s=JSON.parse('{"id":"query-acceleration/condition-cache","title":"Condition Cache","description":"In large-scale analytical workloads, queries often include repeated filtering conditions (Conditions)","source":"@site/versioned_docs/version-4.x/query-acceleration/condition-cache.md","sourceDirName":"query-acceleration","slug":"/query-acceleration/condition-cache","permalink":"/docs/4.x/query-acceleration/condition-cache","draft":false,"unlisted":false,"tags":[],"version":"4.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Condition Cache","language":"en","description":"In large-scale analytical workloads, queries often include repeated filtering conditions (Conditions)"},"sidebar":"docs","previous":{"title":"SQL Cache","permalink":"/docs/4.x/query-acceleration/sql-cache-manual"},"next":{"title":"High-Concurrency Point Query Optimization","permalink":"/docs/4.x/query-acceleration/high-concurrent-point-query"}}'),t=i("785893"),r=i("250065");let c={title:"Condition Cache",language:"en",description:"In large-scale analytical workloads, queries often include repeated filtering conditions (Conditions)"},l=void 0,o={},a=[{value:"Introduction",id:"introduction",level:2},{value:"Working Principle",id:"working-principle",level:2},{value:"Applicable Scenarios",id:"applicable-scenarios",level:2},{value:"Configuration and Management",id:"configuration-and-management",level:2},{value:"Enable or Disable",id:"enable-or-disable",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Cache Statistics",id:"cache-statistics",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Typical Scenario",id:"typical-scenario",level:3},{value:"Notes",id:"notes",level:2},{value:"Summary",id:"summary",level:2}];function d(e){let n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:["In large-scale analytical workloads, queries often include ",(0,t.jsx)(n.strong,{children:"repeated filtering conditions (Conditions)"}),", for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"SELECT * FROM orders WHERE region = 'ASIA';\nSELECT count(*) FROM orders WHERE region = 'ASIA';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Such queries repeatedly execute the same filtering logic on identical data segments, leading to ",(0,t.jsx)(n.strong,{children:"redundant CPU and I/O overhead"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["To address this, ",(0,t.jsx)(n.strong,{children:"Apache Doris introduces the Condition Cache mechanism"}),".\nIt caches the filtering results of specific conditions on a given segment, allowing subsequent queries to ",(0,t.jsx)(n.strong,{children:"reuse those results directly"}),", thereby ",(0,t.jsx)(n.strong,{children:"reducing unnecessary scans and filtering operations"})," and significantly lowering query latency."]}),"\n",(0,t.jsx)(n.h2,{id:"working-principle",children:"Working Principle"}),"\n",(0,t.jsx)(n.p,{children:"The core concept of the Condition Cache is:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"The same filtering condition produces the same result on the same data segment."})}),"\n",(0,t.jsxs)(n.li,{children:["Doris generates a ",(0,t.jsx)(n.strong,{children:"64-bit digest"})," from the combination of \u201Ccondition expression + key range,\u201D which serves as a unique cache identifier."]}),"\n",(0,t.jsx)(n.li,{children:"Each segment can then look up existing filtering results in the cache using this digest."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Cached results are stored as compressed ",(0,t.jsxs)(n.strong,{children:["bit vectors (",(0,t.jsx)(n.code,{children:"std::vector<bool>"}),")"]}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"0"})," indicates that the row range does not meet the condition and can be skipped directly;"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"1"})," indicates that the range may contain matching data and needs further scanning."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Through this mechanism, Doris can quickly eliminate irrelevant data blocks at a coarse granularity, performing fine-grained filtering only when necessary."}),"\n",(0,t.jsx)(n.h2,{id:"applicable-scenarios",children:"Applicable Scenarios"}),"\n",(0,t.jsx)(n.p,{children:"Condition Cache is most effective in the following cases:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Repeated conditions"}),": Identical or similar filter conditions are frequently used."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Relatively stable data"}),": Data inside a segment is typically immutable (new segments are generated after INSERT/Compaction, naturally invalidating old caches)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High selectivity"}),": When filters leave only a small subset of rows, it maximizes scan reduction."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Condition Cache will ",(0,t.jsx)(n.strong,{children:"not"})," be used in the following situations:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Queries containing ",(0,t.jsx)(n.strong,{children:"delete predicates"})," (to ensure correctness, caching is disabled)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TopN runtime filters"})," generated at runtime (currently unsupported)."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"configuration-and-management",children:"Configuration and Management"}),"\n",(0,t.jsx)(n.h3,{id:"enable-or-disable",children:"Enable or Disable"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"SET enable_condition_cache = true;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Condition Cache uses an ",(0,t.jsx)(n.strong,{children:"LRU policy"})," for cache eviction."]}),"\n",(0,t.jsxs)(n.li,{children:["When exceeding ",(0,t.jsx)(n.code,{children:"condition_cache_limit"}),", the least recently used entries are automatically cleared."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You can modify the memory limit in ",(0,t.jsx)(n.code,{children:"be.conf"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"condition_cache_limit = 1024  # Unit: MB\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"After segment compaction, old cache entries are naturally invalidated through LRU eviction."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"cache-statistics",children:"Cache Statistics"}),"\n",(0,t.jsx)(n.p,{children:"Doris provides comprehensive metrics to help users monitor the effectiveness of Condition Cache:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Profile-level metrics"})," (visible in query execution plans)\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConditionCacheSegmentHit"}),": Number of segments that hit the cache"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConditionCacheFilteredRows"}),": Number of rows skipped directly by cached results"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"System metrics"})," (viewable via the monitoring system or ",(0,t.jsx)(n.code,{children:"/metrics"}),")\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"condition_cache_search_count"}),": Total cache lookup count"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"condition_cache_hit_count"}),": Number of successful cache hits"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These metrics help evaluate the cache\u2019s benefit and hit ratio."}),"\n",(0,t.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,t.jsx)(n.h3,{id:"typical-scenario",children:"Typical Scenario"}),"\n",(0,t.jsx)(n.p,{children:"Consider the following query:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"SELECT order_id, amount\nFROM orders\nWHERE region = 'ASIA' AND order_date >= '2023-01-01';\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"First execution"}),": The query performs a full scan and evaluates the filter; the Condition Cache stores the result in the LRU cache."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subsequent identical queries"}),": They reuse the cached results, skipping most irrelevant row ranges and scanning only potential matches."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["When multiple queries share the same filtering condition (e.g., ",(0,t.jsx)(n.code,{children:"region = 'ASIA' AND order_date >= '2023-01-01'"}),"), they can reuse each other\u2019s Condition Cache entries, reducing overall workload."]}),"\n",(0,t.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache is not persistent"}),": The Condition Cache is cleared upon Doris restart."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Delete operations disable caching"}),": Segments with delete markers require strict consistency and thus do not use the cache."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.p,{children:["Condition Cache is an optimization mechanism in Doris designed for ",(0,t.jsx)(n.strong,{children:"repeated conditional queries"}),". Its advantages include:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Avoiding redundant computation and reducing CPU/I/O overhead"}),"\n",(0,t.jsx)(n.li,{children:"Automatically and transparently effective without user intervention"}),"\n",(0,t.jsx)(n.li,{children:"Lightweight in memory consumption and highly efficient when hit and filter rates are high"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By leveraging the Condition Cache effectively, users can achieve significantly faster response times in high-frequency OLAP query scenarios."})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return l},a:function(){return c}});var s=i(667294);let t={},r=s.createContext(t);function c(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);