"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["879873"],{888446:function(e,t,n){n.r(t),n.d(t,{default:()=>u,frontMatter:()=>r,metadata:()=>i,assets:()=>l,toc:()=>c,contentTitle:()=>s});var i=JSON.parse('{"id":"table-design/data-partitioning/manual-bucketing","title":"Manual bucketing","description":"If partitions are used, DISTRIBUTED ... statement describes the rules for dividing data within each partition.","source":"@site/versioned_docs/version-2.0/table-design/data-partitioning/manual-bucketing.md","sourceDirName":"table-design/data-partitioning","slug":"/table-design/data-partitioning/manual-bucketing","permalink":"/docs/2.0/table-design/data-partitioning/manual-bucketing","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Manual bucketing","language":"en"},"sidebar":"docs","previous":{"title":"Dynamic partition","permalink":"/docs/2.0/table-design/data-partitioning/dynamic-partitioning"},"next":{"title":"Auto bucket","permalink":"/docs/2.0/table-design/data-partitioning/auto-bucket"}}'),a=n("785893"),o=n("250065");let r={title:"Manual bucketing",language:"en"},s=void 0,l={},c=[{value:"Recommendations for bucket number and data volume:",id:"recommendations-for-bucket-number-and-data-volume",level:2},{value:"Random distribution",id:"random-distribution",level:2}];function d(e){let t={a:"a",code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["If partitions are used, ",(0,a.jsx)(t.code,{children:"DISTRIBUTED .."}),". statement describes the rules for dividing data within each partition."]}),"\n",(0,a.jsx)(t.p,{children:"If partitions are not used, it describes the rules for dividing the data across the entire table."}),"\n",(0,a.jsx)(t.p,{children:"It is also possible to specify a bucketing method for each partition individually."}),"\n",(0,a.jsx)(t.p,{children:"The bucket columns can be multiple columns. For the Aggregate and Unique models, they must be Key columns, while for the duplicate key data model, they can be both key and value columns. Bucket columns can be the same as or different from Partition columns."}),"\n",(0,a.jsx)(t.p,{children:"The choice of bucket columns involves a trade-off between query throughput and query concurrency:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"If multiple bucket columns are selected, the data distribution will be more uniform. If a query condition does not include equal conditions for all bucket columns, the query will trigger simultaneous scanning of all buckets, increasing query throughput and reducing the latency of individual queries. This approach is suitable for high-throughput, low-concurrency query scenarios."}),"\n",(0,a.jsx)(t.li,{children:"If only one or a few bucket columns are selected, a point query can trigger scanning of just one bucket. In this case, when multiple point queries are concurrent, there is a higher probability that they will trigger scanning of different buckets, reducing the IO impact between queries (especially when different buckets are distributed across different disks). Therefore, this approach is suitable for high-concurrency point query scenarios."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"recommendations-for-bucket-number-and-data-volume",children:"Recommendations for bucket number and data volume:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The total number of tablets for a table is equal to (Partition num * Bucket num)."}),"\n",(0,a.jsx)(t.li,{children:"Without considering expansion, it is recommended that the number of tablets for a table be slightly more than the total number of disks in the cluster."}),"\n",(0,a.jsx)(t.li,{children:"In theory, there is no upper or lower limit for the data volume of a single tablet, but it is recommended to be within the range of 1G - 10G. If the data volume of a single tablet is too small, the data aggregation effect will not be good, and the metadata management pressure will be high. If the data volume is too large, it will not be conducive to the migration and replenishment of replicas, and it will increase the cost of retrying failed operations such as Schema Change or Rollup (the granularity of retrying these operations is the tablet)."}),"\n",(0,a.jsx)(t.li,{children:"When there is a conflict between the data volume principle and the quantity principle of tablets, it is recommended to prioritize the data volume principle."}),"\n",(0,a.jsxs)(t.li,{children:["When creating a table, the bucket number for each partition is uniformly specified. However, when dynamically adding partitions ",(0,a.jsx)(t.code,{children:"ADD PARTITION"}),", the bucket number for the new partition can be specified separately. This feature can be conveniently used to handle data reduction or expansion."]}),"\n",(0,a.jsx)(t.li,{children:"Once the bucket number for a partition is specified, it cannot be changed. Therefore, when determining the bucket number, it is necessary to consider the cluster expansion scenario in advance. For example, if there are only 3 hosts with 1 disk each, and the bucket number is set to 3 or less, then even if more machines are added later, the concurrency cannot be improved."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Here are some examples: Assuming there are 10 BEs, each with one disk. If a table has a total size of 500MB, 4-8 tablets can be considered. For 5GB: 8-16 tablets. For 50GB: 32 tablets. For 500GB: It is recommended to partition the table, with each partition size around 50GB and 16-32 tablets per partition. For 5TB: It is recommended to partition the table, with each partition size around 50GB and 16-32 tablets per partition."}),"\n",(0,a.jsxs)(t.p,{children:["The data volume of a table can be viewed using the ",(0,a.jsx)(t.a,{href:"../../sql-manual/sql-reference/Show-Statements/SHOW-DATA",children:"SHOW DATA"})," command, and the result should be divided by the number of replicas to obtain the actual data volume of the table."]}),"\n",(0,a.jsx)(t.h2,{id:"random-distribution",children:"Random distribution"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"If an OLAP table does not have fields of the update type, setting the data bucketing mode of the table to RANDOM can avoid severe data skew. When data is imported into the corresponding partitions of the table, each batch of a single import job will randomly select a tablet for writing."}),"\n",(0,a.jsx)(t.li,{children:"When the bucketing mode of a table is set to RANDOM, there is no bucketing column, it is not possible to query only a few buckets based on the values of the bucketing column. Queries on the table will simultaneously scan all buckets that hit the partition. This setting is suitable for aggregate query analysis of the entire table data, but not suitable for high-concurrency point queries."}),"\n",(0,a.jsxs)(t.li,{children:["If the data distribution of the OLAP table is Random Distribution, then during data import, single-tablet import mode can be set (set ",(0,a.jsx)(t.code,{children:"load_to_single_tablet"})," to true). Then, during large-volume data import, a task will only write to one tablet when writing data to the corresponding partition. This can improve the concurrency and throughput of data import, reduce the write amplification caused by data import and compaction, and ensure the stability of the cluster."]}),"\n"]})]})}function u(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return s},a:function(){return r}});var i=n(667294);let a={},o=i.createContext(a);function r(e){let t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);