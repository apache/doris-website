"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["963013"],{745152:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>i,metadata:()=>r,assets:()=>c,toc:()=>o,contentTitle:()=>l});var r=JSON.parse('{"id":"sql-manual/sql-functions/scalar-functions/string-functions/regexp-extract","title":"REGEXP_EXTRACT","description":"This is a function used to perform a regular match on a given string STR and extract the POS-th matching part that conforms to the specified pattern.","source":"@site/docs/sql-manual/sql-functions/scalar-functions/string-functions/regexp-extract.md","sourceDirName":"sql-manual/sql-functions/scalar-functions/string-functions","slug":"/sql-manual/sql-functions/scalar-functions/string-functions/regexp-extract","permalink":"/docs/dev/sql-manual/sql-functions/scalar-functions/string-functions/regexp-extract","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770477659000,"frontMatter":{"title":"REGEXP_EXTRACT","language":"en","description":"This is a function used to perform a regular match on a given string STR and extract the POS-th matching part that conforms to the specified pattern."},"sidebar":"docs","previous":{"title":"REGEXP_COUNT","permalink":"/docs/dev/sql-manual/sql-functions/scalar-functions/string-functions/regexp-count"},"next":{"title":"REGEXP_EXTRACT_ALL","permalink":"/docs/dev/sql-manual/sql-functions/scalar-functions/string-functions/regexp-extract-all"}}'),s=t("785893"),a=t("250065");let i={title:"REGEXP_EXTRACT",language:"en",description:"This is a function used to perform a regular match on a given string STR and extract the POS-th matching part that conforms to the specified pattern."},l=void 0,c={},o=[{value:"Description",id:"description",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"Example",id:"example",level:2}];function d(e){let n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,s.jsxs)(n.p,{children:["This is a function used to perform a regular match on a given string ",(0,s.jsx)(n.code,{children:"STR"})," and extract the ",(0,s.jsx)(n.code,{children:"POS"}),"-th matching part that conforms to the specified pattern. For the function to return a matching result, the pattern must exactly match some part of the ",(0,s.jsx)(n.code,{children:"STR"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"If no match is found, an empty string will be returned.\nIt should be noted that when handling character set matching, Utf-8 standard character classes should be used. This ensures that functions can correctly identify and process various characters from different languages."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"str"})," parameter is of 'string' type, representing the string to be subjected to regular matching.\nThe ",(0,s.jsx)(n.code,{children:"pattern"})," parameter is of 'string' type, representing the target regular expression pattern.\nThe ",(0,s.jsx)(n.code,{children:"pos"})," parameter is of 'integer' type, used to specify the position in the string from which to start searching for the regular expression match. The position starts from 1, and this parameter must be specified."]}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.code,{children:"pattern"})," is not allowed regexp regular,throw error;"]}),"\n",(0,s.jsxs)(n.p,{children:["Default supported character match classes : ",(0,s.jsx)(n.a,{href:"https://github.com/google/re2/wiki/Syntax",children:"https://github.com/google/re2/wiki/Syntax"})]}),"\n",(0,s.jsxs)(n.p,{children:["Doris supports enabling more advanced regular expression features, such as look-around zero-width assertions, through the session variable ",(0,s.jsx)(n.code,{children:"enable_extended_regex"})," (default is ",(0,s.jsx)(n.code,{children:"false"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["Supported character matching types when the session variable ",(0,s.jsx)(n.code,{children:"enable_extended_regex"})," is set to ",(0,s.jsx)(n.code,{children:"true"}),": ",(0,s.jsx)(n.a,{href:"https://www.boost.org/doc/libs/latest/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html",children:"https://www.boost.org/doc/libs/latest/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html"})]}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"REGEXP_EXTRACT(<str>, <pattern>, <pos>)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<str>"})}),(0,s.jsx)(n.td,{children:"The column that needs to undergo regular matching. It is of 'string' type."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<pattern>"})}),(0,s.jsx)(n.td,{children:"The target regular expression pattern. It is of 'string' type."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<pos>"})}),(0,s.jsxs)(n.td,{children:["The parameter used to specify the position in the string from which to start searching for the regular expression match. It is an integer value representing the character position in the string (starting from 1). ",(0,s.jsx)(n.code,{children:"pos"})," must be specified."]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,s.jsx)(n.p,{children:"The matching part of the pattern. It is of Varchar type. If no match is found, an empty string will be returned."}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:"Extract the first matching part.In this example, the regular expression ([[:lower:]]+)C([[:lower:]]+) matches the part of the string where one or more lowercase letters are followed by 'C' and then one or more lowercase letters. The first capturing group ([[:lower:]]+) before 'C' matches 'b', so the result is 'b'."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"mysql> SELECT regexp_extract('AbCdE', '([[:lower:]]+)C([[:lower:]]+)', 1);\n+-------------------------------------------------------------+\n| regexp_extract('AbCdE', '([[:lower:]]+)C([[:lower:]]+)', 1) |\n+-------------------------------------------------------------+\n| b                                                           |\n+-------------------------------------------------------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:"Extract the second matching part.Here, the second capturing group ([[:lower:]]+) after 'C' matches 'd', so the result is 'd'."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"mysql> SELECT regexp_extract('AbCdE', '([[:lower:]]+)C([[:lower:]]+)', 2);\n+-------------------------------------------------------------+\n| regexp_extract('AbCdE', '([[:lower:]]+)C([[:lower:]]+)', 2) |\n+-------------------------------------------------------------+\n| d                                                           |\n+-------------------------------------------------------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:"Match Chinese characters.The pattern (\\p{Han}+)(.+) first matches one or more Chinese characters (\\p{Han}+) and then matches the remaining part of the string ((.+)). The second capturing group matches the non - Chinese part of the string, so the result is 'This is a passage in English 1234567'."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"mysql> select regexp_extract('\u8FD9\u662F\u4E00\u6BB5\u4E2D\u6587 This is a passage in English 1234567', '(\\\\p{Han}+)(.+)', 2);\n+-----------------------------------------------------------------------------------------------+\n| regexp_extract('\u8FD9\u662F\u4E00\u6BB5\u4E2D\u6587 This is a passage in English 1234567', '(\\p{Han}+)(.+)', 2)       |\n+-----------------------------------------------------------------------------------------------+\n| This is a passage in English 1234567                                                          |\n+-----------------------------------------------------------------------------------------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:"Insert variable values and perform matching.This example inserts data into a table and then uses the REGEXP_EXTRACT function to extract matching parts from the stored strings based on the stored patterns and positions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"\nCREATE TABLE test_table_for_regexp_extract (\n        id INT,\n        text_data VARCHAR(500),\n        pattern VARCHAR(100),\n        pos INT\n    ) PROPERTIES (\"replication_num\"=\"1\");\n\nINSERT INTO test_table_for_regexp_extract VALUES\n    (1, 'AbCdE', '([[:lower:]]+)C([[:lower:]]+)', 1),    \n    (2, 'AbCdE', '([[:lower:]]+)C([[:lower:]]+)', 2),    \n    (3, '\u8FD9\u662F\u4E00\u6BB5\u4E2D\u6587 This is a passage in English 1234567', '(\\\\p{Han}+)(.+)', 2);\n\nSELECT id, regexp_extract(text_data, pattern, pos) as extract_result FROM test_table_for_regexp_extract ORDER BY id;\n\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"+------+----------------+\n| id   | extract_result |\n+------+----------------+\n|    1 | b              |\n|    2 | d              |\n|    3 | This is a passage in English 1234567 |\n+------+----------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:"Test with a pattern that has no match.Since the pattern ([[:digit:]]+) (one or more digits) does not match any part of the string 'AbCdE', an empty string is returned."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT regexp_extract('AbCdE', '([[:digit:]]+)', 1);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"+------------------------------------------------+\n| regexp_extract('AbCdE', '([[:digit:]]+)', 1)  |\n+------------------------------------------------+\n|                                                |\n+------------------------------------------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:"Emoji test case"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT regexp_extract('Text \uD83D\uDE0A More \uD83D\uDE00', '\uD83D\uDE0A|\uD83D\uDE00',0);\n\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"+------------------------------------------------------+\n| regexp_extract('Text \uD83D\uDE0A More \uD83D\uDE00', '\uD83D\uDE0A|\uD83D\uDE00',0)                 |\n+------------------------------------------------------+\n| \uD83D\uDE0A                                                     |\n+------------------------------------------------------+\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"'str' is NULL, return NULL"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"mysql> SELECT REGEXP_EXTRACT(NULL, '([a-z]+)', 1);\n+-------------------------------------+\n| REGEXP_EXTRACT(NULL, '([a-z]+)', 1) |\n+-------------------------------------+\n| NULL                                |\n+-------------------------------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:"'pattern' is NULL,return NULL"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"mysql> SELECT REGEXP_EXTRACT('Hello World', NULL, 1);\n+----------------------------------------+\n| REGEXP_EXTRACT('Hello World', NULL, 1) |\n+----------------------------------------+\n| NULL                                   |\n+----------------------------------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:"'pos' is NULL,return NULL"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"mysql> SELECT REGEXP_EXTRACT('Hello World', '([a-z]+)', NULL);\n+-------------------------------------------------+\n| REGEXP_EXTRACT('Hello World', '([a-z]+)', NULL) |\n+-------------------------------------------------+\n| NULL                                            |\n+-------------------------------------------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:"All parameters are NULL,return NULL"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"mysql> SELECT REGEXP_EXTRACT(NULL, NULL, NULL);\n+----------------------------------+\n| REGEXP_EXTRACT(NULL, NULL, NULL) |\n+----------------------------------+\n| NULL                             |\n+----------------------------------+\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.code,{children:"pattern"})," is not allowed regexp regular,throw error;"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT regexp_extract('AbCdE', '([[:digit:]]+', 1);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"ERROR 1105 (HY000): errCode = 2, detailMessage = (10.16.10.2)[INVALID_ARGUMENT]Could not compile regexp pattern: ([[:digit:]]+\nError: missing ): ([[:digit:]]+\n"})}),"\n",(0,s.jsx)(n.p,{children:"Advanced regexp"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT regexp_extract('foo123bar456baz', '(?<=foo)(\\\\d+)(?=bar)', 1);\n-- ERROR 1105 (HY000): errCode = 2, detailMessage = (127.0.0.1)[INVALID_ARGUMENT]Invalid regex pattern: (?<=foo)(\\d+)(?=bar). Error: invalid perl operator: (?<\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SET enable_extended_regex = true;\nSELECT regexp_extract('foo123bar456baz', '(?<=foo)(\\\\d+)(?=bar)', 1);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"+---------------------------------------------------------------+\n| regexp_extract('foo123bar456baz', '(?<=foo)(\\\\d+)(?=bar)', 1) |\n+---------------------------------------------------------------+\n| 123                                                           |\n+---------------------------------------------------------------+\n"})})]})}function h(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return l},a:function(){return i}});var r=t(667294);let s={},a=r.createContext(s);function i(e){let n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);