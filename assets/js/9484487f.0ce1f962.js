"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["654331"],{655127:function(n,e,s){s.r(e),s.d(e,{default:()=>o,frontMatter:()=>t,metadata:()=>d,assets:()=>c,toc:()=>a,contentTitle:()=>l});var d=JSON.parse('{"id":"sql-manual/basic-element/sql-data-types/conversion/ip-conversion","title":"Cast to IP Types","description":"IP types are used to store and process IP addresses, including IPv4 and IPv6 types. IPv4 is stored as uint32, while IPv6 is stored as uint128.","source":"@site/docs/sql-manual/basic-element/sql-data-types/conversion/ip-conversion.md","sourceDirName":"sql-manual/basic-element/sql-data-types/conversion","slug":"/sql-manual/basic-element/sql-data-types/conversion/ip-conversion","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/conversion/ip-conversion","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Cast to IP Types","language":"en","description":"IP types are used to store and process IP addresses, including IPv4 and IPv6 types. IPv4 is stored as uint32, while IPv6 is stored as uint128."},"sidebar":"docs","previous":{"title":"Cast to INT Types","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/conversion/int-conversion"},"next":{"title":"Cast to/from JSON","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/conversion/json-conversion"}}'),i=s("785893"),r=s("250065");let t={title:"Cast to IP Types",language:"en",description:"IP types are used to store and process IP addresses, including IPv4 and IPv6 types. IPv4 is stored as uint32, while IPv6 is stored as uint128."},l=void 0,c={},a=[{value:"Cast to IPv4",id:"cast-to-ipv4",level:2},{value:"FROM String",id:"from-string",level:3},{value:"Strict Mode",id:"strict-mode",level:4},{value:"BNF Definition",id:"bnf-definition",level:5},{value:"Rule Description",id:"rule-description",level:5},{value:"Examples",id:"examples",level:5},{value:"Non-Strict Mode",id:"non-strict-mode",level:4},{value:"BNF Definition",id:"bnf-definition-1",level:5},{value:"Rule Description",id:"rule-description-1",level:5},{value:"Examples",id:"examples-1",level:5},{value:"Cast to IPv6",id:"cast-to-ipv6",level:2},{value:"FROM String",id:"from-string-1",level:3},{value:"Strict Mode",id:"strict-mode-1",level:4},{value:"BNF Definition",id:"bnf-definition-2",level:5},{value:"Rule Description",id:"rule-description-2",level:5},{value:"Examples",id:"examples-2",level:5},{value:"Non-Strict Mode",id:"non-strict-mode-1",level:4},{value:"BNF Definition",id:"bnf-definition-3",level:5},{value:"Rule Description",id:"rule-description-3",level:5},{value:"Examples",id:"examples-3",level:5},{value:"FROM IPv4",id:"from-ipv4",level:3}];function h(n){let e={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:"IP types are used to store and process IP addresses, including IPv4 and IPv6 types. IPv4 is stored as uint32, while IPv6 is stored as uint128."}),"\n",(0,i.jsx)(e.h2,{id:"cast-to-ipv4",children:"Cast to IPv4"}),"\n",(0,i.jsx)(e.h3,{id:"from-string",children:"FROM String"}),"\n",(0,i.jsx)(e.h4,{id:"strict-mode",children:"Strict Mode"}),"\n",(0,i.jsx)(e.h5,{id:"bnf-definition",children:"BNF Definition"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:'<ipv4> ::= <whitespace>* <octet> "." <octet> "." <octet> "." <octet> <whitespace>*\n\n<octet> ::= <digit> | <digit><digit> | <digit><digit><digit>\n\n<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"\n\n<whitespace> ::= " " | "\\t" | "\\n" | "\\r" | "\\f" | "\\v"\n'})}),"\n",(0,i.jsx)(e.h5,{id:"rule-description",children:"Rule Description"}),"\n",(0,i.jsx)(e.p,{children:"An IPv4 address consists of 4 numeric segments separated by dots: number.number.number.number, for example: 192.168.1.1. Each segment must be within the range of 0 to 255. Numbers may have leading zeros. Any number of whitespace characters (including spaces, tabs, newlines, etc.) can be included before and after the address."}),"\n",(0,i.jsx)(e.p,{children:"If the format doesn't conform, an error is reported."}),"\n",(0,i.jsx)(e.h5,{id:"examples",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Input String"}),(0,i.jsx)(e.th,{children:"Parse Result"}),(0,i.jsx)(e.th,{children:"Comment"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"192.168.1.1"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Standard valid address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"0.0.0.0"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Minimum value boundary"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"255.255.255.255"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Maximum value boundary"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"10.20.30.40"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Regular address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"   192.168.1.1 "'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Can have whitespace before and after"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"192.168.01.1"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Leading zeros allowed (01 = 1)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.2.3"'}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Only 3 segments (must have 4)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.2.3.4.5"'}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"5 segments (must have 4)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"256.0.0.1"'}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"First segment > 255 (256 out of range)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.300.2.3"'}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Second segment > 255"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.2.3."'}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Fourth segment missing"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'".1.2.3"'}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"First segment missing"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1..2.3"'}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Second segment missing"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"a.b.c.d"'}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Non-numeric characters"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.2.+3.4"'}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Sign + is invalid"})]})]})]}),"\n",(0,i.jsx)(e.h4,{id:"non-strict-mode",children:"Non-Strict Mode"}),"\n",(0,i.jsx)(e.h5,{id:"bnf-definition-1",children:"BNF Definition"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:'<ipv4> ::= <whitespace>* <octet> "." <octet> "." <octet> "." <octet> <whitespace>*\n\n<octet> ::= <digit> | <digit><digit> | <digit><digit><digit>\n\n<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"\n\n<whitespace> ::= " " | "\\t" | "\\n" | "\\r" | "\\f" | "\\v"\n'})}),"\n",(0,i.jsx)(e.h5,{id:"rule-description-1",children:"Rule Description"}),"\n",(0,i.jsx)(e.p,{children:"An IPv4 address consists of 4 numeric segments separated by dots: number.number.number.number, for example: 192.168.1.1. Each segment must be within the range of 0 to 255. Numbers may have leading zeros. Any number of whitespace characters (including spaces, tabs, newlines, etc.) can be included before and after the address."}),"\n",(0,i.jsx)(e.p,{children:"If the format doesn't conform, null is returned."}),"\n",(0,i.jsx)(e.h5,{id:"examples-1",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Input String"}),(0,i.jsx)(e.th,{children:"Parse Result"}),(0,i.jsx)(e.th,{children:"Comment"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"192.168.1.1"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Standard valid address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"0.0.0.0"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Minimum value boundary"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"255.255.255.255"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Maximum value boundary"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"10.20.30.40"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Regular address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"   192.168.1.1 "'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Can have whitespace before and after"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"192.168.01.1"'}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Leading zeros allowed (01 = 1)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.2.3"'}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Only 3 segments (must have 4)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.2.3.4.5"'}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"5 segments (must have 4)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"256.0.0.1"'}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"First segment > 255 (256 out of range)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.300.2.3"'}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Second segment > 255"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.2.3."'}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Fourth segment missing"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'".1.2.3"'}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"First segment missing"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1..2.3"'}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Second segment missing"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"a.b.c.d"'}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Non-numeric characters"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:'"1.2.+3.4"'}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Sign + is invalid"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"cast-to-ipv6",children:"Cast to IPv6"}),"\n",(0,i.jsx)(e.h3,{id:"from-string-1",children:"FROM String"}),"\n",(0,i.jsxs)(e.admonition,{title:"Behavior Change",type:"caution",children:[(0,i.jsx)(e.p,{children:"Before version 4.0, Doris had more relaxed requirements for IPv6 address formats, for example:"}),(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Allowing multiple consecutive colons (like '1:1:::1')"}),"\n",(0,i.jsx)(e.li,{children:"Allowing double colons without actually abbreviating anything (like '1:1:1::1:1:1:1:1')"}),"\n"]}),(0,i.jsx)(e.p,{children:"Starting from version 4.0, these two non-standard formats will result in an error in strict mode or return null in non-strict mode."})]}),"\n",(0,i.jsx)(e.h4,{id:"strict-mode-1",children:"Strict Mode"}),"\n",(0,i.jsx)(e.h5,{id:"bnf-definition-2",children:"BNF Definition"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:'<ipv6> ::= <whitespace>* <ipv6-standard> <whitespace>*\n         | <whitespace>* <ipv6-compressed> <whitespace>*\n         | <whitespace>* <ipv6-ipv4-mapped> <whitespace>*\n\n<ipv6-standard> ::= <h16> ":" <h16> ":" <h16> ":" <h16> ":" <h16> ":" <h16> ":" <h16> ":" <h16>\n\n<h16> ::= <hexdigit>{1,4}\n\n<hexdigit> ::= <digit> | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F"\n\n<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"\n\n<whitespace> ::= " " | "\\t" | "\\n" | "\\r" | "\\f" | "\\v"\n'})}),"\n",(0,i.jsx)(e.h5,{id:"rule-description-2",children:"Rule Description"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Standard format: 8 groups of hexadecimal digits, each group consisting of 1 to 4 hexadecimal digits, separated by colons. Example: 2001:0db8:85a3:0000:0000:8a2e:0370:7334"}),"\n",(0,i.jsx)(e.li,{children:"Compressed format:"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Double colons (::) can be used to represent one or more consecutive groups of zeros."}),"\n",(0,i.jsx)(e.li,{children:"Double colons (::) can only appear once in the entire address."}),"\n",(0,i.jsx)(e.li,{children:"Just :: is also a valid address, representing all zeros."}),"\n",(0,i.jsx)(e.li,{children:"1:1:1::1:1:1:1:1 is not valid because :: doesn't represent consecutive zeros."}),"\n",(0,i.jsxs)(e.li,{children:["The following addresses are all valid and identical:\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"2001:0db8:0000:0000:0000:0000:1428:57ab"}),"\n",(0,i.jsx)(e.li,{children:"2001:0db8:0000:0000:0000::1428:57ab"}),"\n",(0,i.jsx)(e.li,{children:"2001:0db8:0:0:0:0:1428:57ab"}),"\n",(0,i.jsx)(e.li,{children:"2001:0db8:0::0:1428:57ab"}),"\n",(0,i.jsx)(e.li,{children:"2001:0db8::1428:57ab"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.ol,{start:"3",children:["\n",(0,i.jsx)(e.li,{children:"IPv4-mapped addresses:"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"IPv4 dotted decimal format can be used in the last 32 bits (last two groups) of an IPv6 address."}),"\n",(0,i.jsx)(e.li,{children:"This format is typically used to represent the mapping of IPv4 addresses to IPv6."}),"\n",(0,i.jsx)(e.li,{children:"Example: ::ffff:192.168.89.9 is equivalent to ::ffff:c0a8:5909"}),"\n"]}),"\n",(0,i.jsxs)(e.ol,{start:"4",children:["\n",(0,i.jsx)(e.li,{children:"Any number of whitespace characters (including spaces, tabs, newlines, etc.) can be included before and after the address."}),"\n",(0,i.jsx)(e.li,{children:"Hexadecimal letters can be uppercase (A-F) or lowercase (a-f)."}),"\n",(0,i.jsx)(e.li,{children:"The IPv4 part must follow IPv4 rules: each segment must be within the range of 0 to 255."}),"\n",(0,i.jsx)(e.li,{children:"If the address format doesn't conform to the above rules, an error is reported."}),"\n"]}),"\n",(0,i.jsx)(e.h5,{id:"examples-2",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Input String"}),(0,i.jsx)(e.th,{children:"Parse Result"}),(0,i.jsx)(e.th,{children:"Comment"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8:85a3:0000:0000:8a2e:0370:7334"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Standard valid address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"::"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"All zeros address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Using compressed format"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"::ffff:192.168.1.1"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"IPv4-mapped address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::1"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Can have whitespace before and after"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::1::2"}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Double colons (::) appear twice"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8:85a3:0000:0000:8a2e:0370:7334:1234"}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"More than 8 groups"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8:85a3:0000:8a2e:0370"}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Only 6 groups (must have 8 or use compressed format)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8:85g3:0000:0000:8a2e:0370:7334"}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Contains invalid hexadecimal character 'g'"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::ffff:192.168.1.260"}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"IPv4 part out of range (260 > 255)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::ffff:192.168..1"}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"IPv4 part format error (missing a segment)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:0db8:85a3:::8a2e:0370:7334"}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"Three colons in a row"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"20001:db8::1"}),(0,i.jsx)(e.td,{children:"Error"}),(0,i.jsx)(e.td,{children:"First group exceeds 4 hexadecimal digits"})]})]})]}),"\n",(0,i.jsx)(e.h4,{id:"non-strict-mode-1",children:"Non-Strict Mode"}),"\n",(0,i.jsx)(e.h5,{id:"bnf-definition-3",children:"BNF Definition"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:'<ipv6> ::= <whitespace>* <ipv6-standard> <whitespace>*\n         | <whitespace>* <ipv6-compressed> <whitespace>*\n         | <whitespace>* <ipv6-ipv4-mapped> <whitespace>*\n\n<ipv6-standard> ::= <h16> ":" <h16> ":" <h16> ":" <h16> ":" <h16> ":" <h16> ":" <h16> ":" <h16>\n\n<h16> ::= <hexdigit>{1,4}\n\n<hexdigit> ::= <digit> | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F"\n\n<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"\n\n<whitespace> ::= " " | "\\t" | "\\n" | "\\r" | "\\f" | "\\v"\n'})}),"\n",(0,i.jsx)(e.h5,{id:"rule-description-3",children:"Rule Description"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Standard format: 8 groups of hexadecimal digits, each group consisting of 1 to 4 hexadecimal digits, separated by colons. Example: 2001:0db8:85a3:0000:0000:8a2e:0370:7334"}),"\n",(0,i.jsx)(e.li,{children:"Compressed format:"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Double colons (::) can be used to represent one or more consecutive groups of zeros."}),"\n",(0,i.jsx)(e.li,{children:"Double colons (::) can only appear once in the entire address."}),"\n",(0,i.jsx)(e.li,{children:"Just :: is also a valid address, representing all zeros."}),"\n",(0,i.jsx)(e.li,{children:"1:1:1::1:1:1:1:1 is not valid because :: doesn't represent consecutive zeros."}),"\n",(0,i.jsxs)(e.li,{children:["The following addresses are all valid and identical:\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"2001:0db8:0000:0000:0000:0000:1428:57ab"}),"\n",(0,i.jsx)(e.li,{children:"2001:0db8:0000:0000:0000::1428:57ab"}),"\n",(0,i.jsx)(e.li,{children:"2001:0db8:0:0:0:0:1428:57ab"}),"\n",(0,i.jsx)(e.li,{children:"2001:0db8:0::0:1428:57ab"}),"\n",(0,i.jsx)(e.li,{children:"2001:0db8::1428:57ab"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.ol,{start:"3",children:["\n",(0,i.jsx)(e.li,{children:"IPv4-mapped addresses:"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"IPv4 dotted decimal format can be used in the last 32 bits (last two groups) of an IPv6 address."}),"\n",(0,i.jsx)(e.li,{children:"This format is typically used to represent the mapping of IPv4 addresses to IPv6."}),"\n",(0,i.jsx)(e.li,{children:"Example: ::ffff:192.168.89.9 is equivalent to ::ffff:c0a8:5909"}),"\n"]}),"\n",(0,i.jsxs)(e.ol,{start:"4",children:["\n",(0,i.jsx)(e.li,{children:"Any number of whitespace characters (including spaces, tabs, newlines, etc.) can be included before and after the address."}),"\n",(0,i.jsx)(e.li,{children:"Hexadecimal letters can be uppercase (A-F) or lowercase (a-f)."}),"\n",(0,i.jsx)(e.li,{children:"The IPv4 part must follow IPv4 rules: each segment must be within the range of 0 to 255."}),"\n",(0,i.jsx)(e.li,{children:"If the address format doesn't conform to the above rules, null is returned."}),"\n"]}),"\n",(0,i.jsx)(e.h5,{id:"examples-3",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Input String"}),(0,i.jsx)(e.th,{children:"Parse Result"}),(0,i.jsx)(e.th,{children:"Comment"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8:85a3:0000:0000:8a2e:0370:7334"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Standard valid address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"::"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"All zeros address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Using compressed format"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"::ffff:192.168.1.1"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"IPv4-mapped address"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::1"}),(0,i.jsx)(e.td,{children:"Success"}),(0,i.jsx)(e.td,{children:"Can have whitespace before and after"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::1::2"}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Double colons (::) appear twice"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8:85a3:0000:0000:8a2e:0370:7334:1234"}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"More than 8 groups"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8:85a3:0000:8a2e:0370"}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Only 6 groups (must have 8 or use compressed format)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8:85g3:0000:0000:8a2e:0370:7334"}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Contains invalid hexadecimal character 'g'"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::ffff:192.168.1.260"}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"IPv4 part out of range (260 > 255)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:db8::ffff:192.168..1"}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"IPv4 part format error (missing a segment)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2001:0db8:85a3:::8a2e:0370:7334"}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"Three colons in a row"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"20001:db8::1"}),(0,i.jsx)(e.td,{children:"null"}),(0,i.jsx)(e.td,{children:"First group exceeds 4 hexadecimal digits"})]})]})]}),"\n",(0,i.jsx)(e.h3,{id:"from-ipv4",children:"FROM IPv4"}),"\n",(0,i.jsx)(e.p,{children:"Any IPv4 address can be converted to IPv6. Conversion will always succeed, and behavior is consistent between strict and non-strict modes."}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Input IPv4"}),(0,i.jsx)(e.th,{children:"Converted IPv6"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"192.168.0.0"}),(0,i.jsx)(e.td,{children:"::ffff:192.168.0.0"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"0.0.0.0"}),(0,i.jsx)(e.td,{children:"::ffff:0.0.0.0"})]})]})]})]})}function o(n={}){let{wrapper:e}={...(0,r.a)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}},250065:function(n,e,s){s.d(e,{Z:function(){return l},a:function(){return t}});var d=s(667294);let i={},r=d.createContext(i);function t(n){let e=d.useContext(r);return d.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:t(n.components),d.createElement(r.Provider,{value:e},n.children)}}}]);