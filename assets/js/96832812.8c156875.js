"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["627995"],{948659:function(e,i,n){n.r(i),n.d(i,{default:()=>h,frontMatter:()=>r,metadata:()=>a,assets:()=>d,toc:()=>c,contentTitle:()=>l});var a=JSON.parse('{"id":"query-acceleration/materialized-view/sync-materialized-view","title":"Sync-Materialized View","description":"What is a Synchronous Materialized View","source":"@site/docs/query-acceleration/materialized-view/sync-materialized-view.md","sourceDirName":"query-acceleration/materialized-view","slug":"/query-acceleration/materialized-view/sync-materialized-view","permalink":"/docs/dev/query-acceleration/materialized-view/sync-materialized-view","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Sync-Materialized View","language":"en"},"sidebar":"docs","previous":{"title":"Materialized View Overview","permalink":"/docs/dev/query-acceleration/materialized-view/overview"},"next":{"title":"Overview of Asynchronous Materialized Views","permalink":"/docs/dev/query-acceleration/materialized-view/async-materialized-view/overview"}}'),t=n("785893"),s=n("250065");let r={title:"Sync-Materialized View",language:"en"},l=void 0,d={},c=[{value:"What is a Synchronous Materialized View",id:"what-is-a-synchronous-materialized-view",level:2},{value:"Applicable Scenarios",id:"applicable-scenarios",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Using Materialized Views",id:"using-materialized-views",level:2},{value:"Creating a Materialized View",id:"creating-a-materialized-view",level:3},{value:"Checking if the Materialized View is Created",id:"checking-if-the-materialized-view-is-created",level:3},{value:"Canceling Materialized View Creation",id:"canceling-materialized-view-creation",level:3},{value:"Viewing the Materialized View Structure",id:"viewing-the-materialized-view-structure",level:3},{value:"Viewing the Creation Statement of a Materialized View",id:"viewing-the-creation-statement-of-a-materialized-view",level:3},{value:"Querying Materialized Views",id:"querying-materialized-views",level:3},{value:"Dropping a Materialized View",id:"dropping-a-materialized-view",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Example 1: Accelerating Aggregation Queries",id:"example-1-accelerating-aggregation-queries",level:3},{value:"Example 2: Matching Different Prefix Indexes",id:"example-2-matching-different-prefix-indexes",level:3},{value:"Example 3: Pre-filtering and Expression Computation to Accelerate Queries",id:"example-3-pre-filtering-and-expression-computation-to-accelerate-queries",level:3},{value:"FAQ",id:"faq",level:2}];function o(e){let i={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h2,{id:"what-is-a-synchronous-materialized-view",children:"What is a Synchronous Materialized View"}),"\n",(0,t.jsx)(i.p,{children:"A synchronous materialized view is a special type of table in Doris that stores pre-computed data sets based on defined SELECT statements. Doris automatically maintains the data in synchronous materialized views, ensuring that any new imports or deletions in the base table are reflected in the materialized view in real-time, maintaining data consistency without requiring any additional manual maintenance. When querying, Doris automatically selects the optimal materialized view and retrieves data directly from it."}),"\n",(0,t.jsx)(i.h2,{id:"applicable-scenarios",children:"Applicable Scenarios"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Accelerating time-consuming aggregation operations"}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Queries requiring prefix index matching"}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Reducing the amount of data scanned by pre-filtering"}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Speeding up queries by pre-computing complex expressions"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Synchronous materialized views only support SELECT statements for a single table, including WHERE, GROUP BY, and ORDER BY clauses, but not JOIN, HAVING, LIMIT clauses, LATERAL VIEW."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Unlike asynchronous materialized views, synchronous materialized views cannot be queried directly."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"The SELECT list cannot include auto-increment columns, constants, duplicate expressions, or window functions."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["If the SELECT list contains aggregation functions, these must be root expressions (e.g., ",(0,t.jsx)(i.code,{children:"sum(a + 1)"})," is supported, but ",(0,t.jsx)(i.code,{children:"sum(a) + 1"})," is not), and no non-aggregation function expressions can follow the aggregation function (e.g., ",(0,t.jsx)(i.code,{children:"SELECT x, sum(a)"})," is allowed, but ",(0,t.jsx)(i.code,{children:"SELECT sum(a), x"})," is not)."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"If the condition column for a DELETE statement exists in the materialized view, the DELETE operation cannot proceed. If data deletion is necessary, the materialized view must be dropped first."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Excessive materialized views on a single table can impact import efficiency. When importing data, both the materialized views and the base table are updated synchronously. Excessive materialized views on a table can slow down imports, similar to importing data into multiple tables simultaneously."}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Materialized views on Unique Key data models can only reorder columns and do not support aggregation. Therefore, coarse-grained aggregation operations cannot be performed through materialized views on Unique Key models."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"using-materialized-views",children:"Using Materialized Views"}),"\n",(0,t.jsx)(i.p,{children:"Doris provides a comprehensive set of DDL syntax for materialized views, including creation, viewing, and deletion. Below is an example demonstrating how to use materialized views to accelerate aggregation calculations. Suppose a user has a sales record detail table that stores transaction IDs, salespersons, stores, sale dates, and amounts. The table creation and data insertion statements are as follows:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:'-- Create a test_db  \ncreate database test_db;  \nuse test_db;  \n  \n-- Create table  \ncreate table sales_records  \n(  \n    record_id int,   \n    seller_id int,   \n    store_id int,   \n    sale_date date,   \n    sale_amt bigint  \n)   \ndistributed by hash(record_id)   \nproperties("replication_num" = "1");  \n  \n-- Insert data  \ninsert into sales_records values(1,1,1,"2020-02-02",1), (1,1,1,"2020-02-02",2);\n'})}),"\n",(0,t.jsx)(i.h3,{id:"creating-a-materialized-view",children:"Creating a Materialized View"}),"\n",(0,t.jsxs)(i.p,{children:["If users frequently need to analyze sales volumes by different stores, they can create a materialized view for the ",(0,t.jsx)(i.code,{children:"sales_records"})," table, grouped by store ID and summing sales amounts for each store. The creation statement is as follows:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"create materialized view store_amt as   \nselect store_id, sum(sale_amt) from sales_records group by store_id;\n"})}),"\n",(0,t.jsx)(i.h3,{id:"checking-if-the-materialized-view-is-created",children:"Checking if the Materialized View is Created"}),"\n",(0,t.jsx)(i.p,{children:"Since creating a materialized view is an asynchronous operation, users need to check the status of the materialized view creation task asynchronously after submitting it. The command is as follows:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"show alter table materialized view from test_db;\n"})}),"\n",(0,t.jsx)(i.p,{children:"The output will show all materialized view creation tasks for that database. A sample output is:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"+--------+---------------+---------------------+---------------------+---------------+-----------------+----------+---------------+----------+------+----------+---------+  \n| JobId  | TableName     | CreateTime          | FinishTime          | BaseIndexName | RollupIndexName | RollupId | TransactionId | State    | Msg  | Progress | Timeout |  \n+--------+---------------+---------------------+---------------------+---------------+-----------------+----------+---------------+----------+------+----------+---------+  \n| 494349 | sales_records | 2020-07-30 20:04:56 | 2020-07-30 20:04:57 | sales_records | store_amt       | 494350   | 133107        | FINISHED |      | NULL     | 2592000 |  \n+--------+---------------+---------------------+---------------------+---------------+-----------------+----------+---------------+----------+------+----------+---------+\n"})}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"State"})," column indicates the status. When the state changes to ",(0,t.jsx)(i.code,{children:"FINISHED"}),", the materialized view is successfully created."]}),"\n",(0,t.jsx)(i.h3,{id:"canceling-materialized-view-creation",children:"Canceling Materialized View Creation"}),"\n",(0,t.jsx)(i.p,{children:"If the background asynchronous task for creating the materialized view has not yet completed, it can be canceled with the following command:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"cancel alter table materialized view from test_db.sales_records;\n"})}),"\n",(0,t.jsx)(i.p,{children:"If the materialized view has already been created, it cannot be canceled, but it can be deleted using the DROP command."}),"\n",(0,t.jsx)(i.h3,{id:"viewing-the-materialized-view-structure",children:"Viewing the Materialized View Structure"}),"\n",(0,t.jsx)(i.p,{children:"The structure of all materialized views created on a target table can be viewed using the following command:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"desc sales_records all;\n"})}),"\n",(0,t.jsx)(i.h3,{id:"viewing-the-creation-statement-of-a-materialized-view",children:"Viewing the Creation Statement of a Materialized View"}),"\n",(0,t.jsx)(i.p,{children:"The creation statement for a materialized view can be viewed with the following command:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"show create materialized view store_amt on sales_records;\n"})}),"\n",(0,t.jsx)(i.h3,{id:"querying-materialized-views",children:"Querying Materialized Views"}),"\n",(0,t.jsxs)(i.p,{children:["Once a materialized view is created, when users query sales volumes for different stores, Doris will directly read the aggregated data from the newly created materialized view ",(0,t.jsx)(i.code,{children:"store_amt"}),", thereby enhancing query efficiency. Users still specify the ",(0,t.jsx)(i.code,{children:"sales_records"})," table in their queries, for example:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"SELECT store_id, SUM(sale_amt) FROM sales_records GROUP BY store_id;\n"})}),"\n",(0,t.jsxs)(i.p,{children:["The above query will automatically match the ",(0,t.jsx)(i.code,{children:"store_amt"})," materialized view. Users can use the following command to verify whether the current query has matched an appropriate materialized view."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"EXPLAIN SELECT store_id, SUM(sale_amt) FROM sales_records GROUP BY store_id;\n"})}),"\n",(0,t.jsx)(i.p,{children:"The result is as follows:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"+------------------------------------------------------------------------+  \n| Explain String (Nereids Planner)                                       |  \n+------------------------------------------------------------------------+  \n| PLAN FRAGMENT 0                                                        |  \n|   OUTPUT EXPRS:                                                        |  \n|     store_id[#11]                                                      |  \n|     sum(sale_amt)[#12]                                                 |  \n|   PARTITION: HASH_PARTITIONED: mv_store_id[#7]                         |  \n|                                                                        |  \n|   HAS_COLO_PLAN_NODE: true                                             |  \n|                                                                        |  \n|   VRESULT SINK                                                         |  \n|      MYSQL_PROTOCAL                                                    |  \n|                                                                        |  \n|   3:VAGGREGATE (merge finalize)(384)                                   |  \n|   |  output: sum(partial_sum(mva_SUM__`sale_amt`)[#8])[#10]            |  \n|   |  group by: mv_store_id[#7]                                         |  \n|   |  sortByGroupKey: false                                             |  \n|   |  cardinality = 1                                                   |  \n|   |  final projections: mv_store_id[#9], sum(mva_SUM__`sale_amt`)[#10] |  \n|   |  final project output tuple id: 4                                  |  \n|   |  distribute expr lists: mv_store_id[#7]                            |  \n|   |                                                                    |  \n|   2:VEXCHANGE                                                          |  \n|      offset: 0                                                         |  \n|      distribute expr lists:                                            |  \n|                                                                        |  \n| PLAN FRAGMENT 1                                                        |  \n|                                                                        |  \n|   PARTITION: HASH_PARTITIONED: record_id[#2]                           |  \n|                                                                        |  \n|   HAS_COLO_PLAN_NODE: false                                            |  \n|                                                                        |  \n|   STREAM DATA SINK                                                     |  \n|     EXCHANGE ID: 02                                                    |  \n|     HASH_PARTITIONED: mv_store_id[#7]                                  |  \n|                                                                        |  \n|   1:VAGGREGATE (update serialize)(374)                                 |  \n|   |  STREAMING                                                         |  \n|   |  output: partial_sum(mva_SUM__`sale_amt`[#1])[#8]                  |  \n|   |  group by: mv_store_id[#0]                                         |  \n|   |  sortByGroupKey: false                                             |  \n|   |  cardinality = 1                                                   |  \n|   |  distribute expr lists:                                            |  \n|   |                                                                    |  \n|   0:VOlapScanNode(369)                                                 |  \n|      TABLE: test_db.sales_records(store_amt), PREAGGREGATION: ON       |  \n|      partitions = 1/1 (sales_records)                                  |  \n|      tablets = 10/10, tabletList = 266568, 266570, 266572 ...          |  \n|      cardinality = 1, avgRowSize = 1805.0, numNodes = 1                |  \n|      pushAggOp = NONE                                                  |  \n|                                                                        |  \n|                                                                        |  \n| ========== MATERIALIZATIONS ==========                                 |  \n|                                                                        |  \n| MaterializedView                                                       |  \n| MaterializedViewRewriteSuccessAndChose:                                |  \n|   internal.test_db.sales_records.store_amt chose,                      |  \n|                                                                        |  \n| MaterializedViewRewriteSuccessButNotChose:                             |  \n|   not chose: none,                                                     |  \n|                                                                        |  \n| MaterializedViewRewriteFail:                                           |  \n|                                                                        |  \n|                                                                        |  \n| ========== STATISTICS ==========                                       |  \n| planned with unknown column statistics                                 |  \n+------------------------------------------------------------------------+\n"})}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"MaterializedViewRewriteSuccessAndChose"})," displays the materialized view that was successfully matched, as shown in the following example:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"+------------------------------------------------------------------------+  \n| MaterializedViewRewriteSuccessAndChose:                                |  \n|   internal.test_db.sales_records.store_amt chose,                      |  \n+------------------------------------------------------------------------+\n"})}),"\n",(0,t.jsxs)(i.p,{children:["The above content indicates that the query successfully matched the materialized view named ",(0,t.jsx)(i.code,{children:"store_amt"}),". It's worth noting that if there is no data in the target table, the materialized view may not be hit."]}),"\n",(0,t.jsx)(i.p,{children:"Detailed explanations on MATERIALIZATIONS:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"MaterializedViewRewriteSuccessAndChose"}),": Displays the materialized view that was successfully selected and used for query optimization."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"MaterializedViewRewriteSuccessButNotChose"}),": Displays materialized views that matched the query but were not selected (the optimizer chooses the optimal materialized view based on its cost, and these matched but unselected views indicate they were not the optimal choice)."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"MaterializedViewRewriteFail"}),": Displays materialized views that failed to match the query, meaning the original SQL query could not match any existing materialized views and therefore could not be optimized using them."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"dropping-a-materialized-view",children:"Dropping a Materialized View"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"drop materialized view store_amt on sales_records;\n"})}),"\n",(0,t.jsx)(i.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(i.p,{children:"Below are additional examples demonstrating the use of materialized views."}),"\n",(0,t.jsx)(i.h3,{id:"example-1-accelerating-aggregation-queries",children:"Example 1: Accelerating Aggregation Queries"}),"\n",(0,t.jsx)(i.p,{children:"Business Scenario: Calculating ad UV (Unique Visitors) and PV (Page Views)."}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["Assuming the raw ad click data is stored in Doris, creating a materialized view with ",(0,t.jsx)(i.code,{children:"bitmap_union"})," can speed up queries for ad PV and UV. First, create a table to store ad click details:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"create table advertiser_view_record  \n(  \n    click_time datetime,   \n    advertiser varchar(10),   \n    channel varchar(10),   \n    user_id int  \n) distributed by hash(user_id) properties(\"replication_num\" = \"1\");  \ninsert into advertiser_view_record values(\"2020-02-02 02:02:02\",'a','a',1), (\"2020-02-02 02:02:02\",'a','a',2);\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Since users want to query the UV value of advertisements, which requires an exact deduplication of users for the same advertisement, the typical query would be:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"select \n    advertiser, \n    channel, \n    count(distinct user_id) \nfrom \n    advertiser_view_record \ngroup by \n    advertiser, channel;\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["For this UV calculation scenario, we can create a materialized view with ",(0,t.jsx)(i.code,{children:"bitmap_union"})," to achieve pre-exact deduplication. In Doris, the result of the ",(0,t.jsx)(i.code,{children:"count(distinct)"})," aggregation is identical to the result of the ",(0,t.jsx)(i.code,{children:"bitmap_union_count"})," aggregation. And ",(0,t.jsx)(i.code,{children:"bitmap_union_count"})," is equivalent to counting the results of ",(0,t.jsx)(i.code,{children:"bitmap_union"}),". Therefore, if the query involves ",(0,t.jsx)(i.code,{children:"count(distinct)"}),", creating a materialized view with ",(0,t.jsx)(i.code,{children:"bitmap_union"})," aggregation can speed up the query. Based on current usage scenarios, a materialized view can be created to group by advertisement and channel, with exact deduplication for ",(0,t.jsx)(i.code,{children:"user_id"}),"."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"create materialized view advertiser_uv as \nselect \n    advertiser, \n    channel, \n    bitmap_union(to_bitmap(user_id)) \nfrom \n    advertiser_view_record \ngroup by \n    advertiser, channel;\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["Once the materialized view table is created, when querying the UV for advertisements, Doris will automatically retrieve data from the newly created materialized view ",(0,t.jsx)(i.code,{children:"advertiser_uv"}),". If the previous SQL is executed:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"select \n    advertiser, \n    channel, \n    count(distinct user_id) \nfrom \n    advertiser_view_record \ngroup by \n    advertiser, channel;\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"After selecting the materialized view, the actual query will be transformed into:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"select \n    advertiser, \n    channel, \n    bitmap_union_count(to_bitmap(user_id)) \nfrom \n    advertiser_uv \ngroup by \n    advertiser, channel;\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["Use the ",(0,t.jsx)(i.code,{children:"explain"})," command to check if the query matches the materialized view:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"explain select \n    advertiser, \n    channel, \n    count(distinct user_id) \nfrom \n    advertiser_view_record \ngroup by \n    advertiser, channel;\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"The output will be:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"+---------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Explain String(Nereids Planner)                                                                                                                         |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------+\n| PLAN FRAGMENT 0                                                                                                                                         |\n|   OUTPUT EXPRS:                                                                                                                                         |\n|     advertiser[#13]                                                                                                                                     |\n|     channel[#14]                                                                                                                                        |\n|     count(DISTINCT user_id)[#15]                                                                                                                        |\n|   PARTITION: HASH_PARTITIONED: mv_advertiser[#7], mv_channel[#8]                                                                                        |\n|                                                                                                                                                         |\n|   HAS_COLO_PLAN_NODE: true                                                                                                                              |\n|                                                                                                                                                         |\n|   VRESULT SINK                                                                                                                                          |\n|      MYSQL_PROTOCAL                                                                                                                                     |\n|                                                                                                                                                         |\n|   3:VAGGREGATE (merge finalize)(440)                                                                                                                    |\n|   |  output: bitmap_union_count(partial_bitmap_union_count(mva_BITMAP_UNION__to_bitmap_with_check(CAST(`user_id` AS bigint)))[#9])[#12]                 |\n|   |  group by: mv_advertiser[#7], mv_channel[#8]                                                                                                        |\n|   |  sortByGroupKey:false                                                                                                                               |\n|   |  cardinality=1                                                                                                                                      |\n|   |  final projections: mv_advertiser[#10], mv_channel[#11], bitmap_union_count(mva_BITMAP_UNION__to_bitmap_with_check(CAST(`user_id` AS bigint)))[#12] |\n|   |  final project output tuple id: 4                                                                                                                   |\n|   |  distribute expr lists: mv_advertiser[#7], mv_channel[#8]                                                                                           |\n|   |                                                                                                                                                     |\n|   2:VEXCHANGE                                                                                                                                           |\n|      offset: 0                                                                                                                                          |\n|      distribute expr lists:                                                                                                                             |\n|                                                                                                                                                         |\n| PLAN FRAGMENT 1                                                                                                                                         |\n|                                                                                                                                                         |\n|   PARTITION: HASH_PARTITIONED: user_id[#6]                                                                                                              |\n|                                                                                                                                                         |\n|   HAS_COLO_PLAN_NODE: false                                                                                                                             |\n|                                                                                                                                                         |\n|   STREAM DATA SINK                                                                                                                                      |\n|     EXCHANGE ID: 02                                                                                                                                     |\n|     HASH_PARTITIONED: mv_advertiser[#7], mv_channel[#8]                                                                                                 |\n|                                                                                                                                                         |\n|   1:VAGGREGATE (update serialize)(430)                                                                                                                  |\n|   |  STREAMING                                                                                                                                          |\n|   |  output: partial_bitmap_union_count(mva_BITMAP_UNION__to_bitmap_with_check(CAST(`user_id` AS bigint))[#2])[#9]                                      |\n|   |  group by: mv_advertiser[#0], mv_channel[#1]                                                                                                        |\n|   |  sortByGroupKey:false                                                                                                                               |\n|   |  cardinality=1                                                                                                                                      |\n|   |  distribute expr lists:                                                                                                                             |\n|   |                                                                                                                                                     |\n|   0:VOlapScanNode(425)                                                                                                                                  |\n|      TABLE: test_db.advertiser_view_record(advertiser_uv), PREAGGREGATION: ON                                                                           |\n|      partitions=1/1 (advertiser_view_record)                                                                                                            |\n|      tablets=10/10, tabletList=266637,266639,266641 ...                                                                                                 |\n|      cardinality=1, avgRowSize=0.0, numNodes=1                                                                                                          |\n|      pushAggOp=NONE                                                                                                                                     |\n|                                                                                                                                                         |\n|                                                                                                                                                         |\n| ========== MATERIALIZATIONS ==========                                                                                                                  |\n|                                                                                                                                                         |\n| MaterializedView                                                                                                                                        |\n| MaterializedViewRewriteSuccessAndChose:                                                                                                                 |\n|   internal.test_db.advertiser_view_record.advertiser_uv chose,                                                                                          |\n|                                                                                                                                                         |\n| MaterializedViewRewriteSuccessButNotChose:                                                                                                              |\n|   not chose: none,                                                                                                                                      |\n|                                                                                                                                                         |\n| MaterializedViewRewriteFail:                                                                                                                            |\n|                                                                                                                                                         |\n|                                                                                                                                                         |\n| ========== STATISTICS ==========                                                                                                                        |\n| planed with unknown column statistics                                                                                                                   |\n+---------------------------------------------------------------------------------------------------------------------------------------------------------+\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["In the result of the explain command, you can see that ",(0,t.jsx)(i.code,{children:"internal.test_db.advertiser_view_record.advertiser_uv"})," was chosen. This indicates that the query will directly scan the data from the materialized view. This confirms that the match was successful. Secondly, the count(distinct) operation on the ",(0,t.jsx)(i.code,{children:"user_id"})," field is rewritten as ",(0,t.jsx)(i.code,{children:"bitmap_union_count(to_bitmap)"}),". This means that the exact deduplication effect is achieved through the use of Bitmap."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"example-2-matching-different-prefix-indexes",children:"Example 2: Matching Different Prefix Indexes"}),"\n",(0,t.jsx)(i.p,{children:"Business Scenario: Matching prefix indexes."}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"If a table has prefix indexes on k1 and k2, but queries sometimes involve k3, a materialized view can be created with k3 as the first column to leverage indexing:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:'create table test_table  \n(  \n    k1 int,   \n    k2 int,   \n    k3 int,   \n    kx date  \n)   \ndistributed by hash(k1)   \nproperties("replication_num" = "1");  \n  \ninsert into test_table values(1,1,1,1),(3,3,3,3);\n'})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Create a materialized view with k3 as the prefix index:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"create materialized view mv_1 as SELECT k3, k2, k1 FROM test_table;\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["Queries with ",(0,t.jsx)(i.code,{children:"WHERE k3 = 3"})," will match the materialized view, as verified by ",(0,t.jsx)(i.code,{children:"explain"}),"."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"explain select k1, k2, k3 from test_table where k3=3;\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"The output will be:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"+----------------------------------------------------------+\n| Explain String(Nereids Planner)                          |\n+----------------------------------------------------------+\n| PLAN FRAGMENT 0                                          |\n|   OUTPUT EXPRS:                                          |\n|     k1[#7]                                               |\n|     k2[#8]                                               |\n|     k3[#9]                                               |\n|   PARTITION: HASH_PARTITIONED: mv_k1[#2]                 |\n|                                                          |\n|   HAS_COLO_PLAN_NODE: false                              |\n|                                                          |\n|   VRESULT SINK                                           |\n|      MYSQL_PROTOCAL                                      |\n|                                                          |\n|   0:VOlapScanNode(256)                                   |\n|      TABLE: test_db.test_table(mv_1), PREAGGREGATION: ON |\n|      PREDICATES: (mv_k3[#0] = 3)                         |\n|      partitions=1/1 (test_table)                         |\n|      tablets=10/10, tabletList=271177,271179,271181 ...  |\n|      cardinality=1, avgRowSize=0.0, numNodes=1           |\n|      pushAggOp=NONE                                      |\n|      final projections: mv_k1[#2], mv_k2[#1], mv_k3[#0]  |\n|      final project output tuple id: 2                    |\n|                                                          |\n|                                                          |\n| ========== MATERIALIZATIONS ==========                   |\n|                                                          |\n| MaterializedView                                         |\n| MaterializedViewRewriteSuccessAndChose:                  |\n|   internal.test_db.test_table.mv_1 chose,                |\n|                                                          |\n| MaterializedViewRewriteSuccessButNotChose:               |\n|   not chose: none,                                       |\n|                                                          |\n| MaterializedViewRewriteFail:                             |\n|                                                          |\n|                                                          |\n| ========== STATISTICS ==========                         |\n| planed with unknown column statistics                    |\n+----------------------------------------------------------+\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:["In the result of the explain command, you can see that ",(0,t.jsx)(i.code,{children:"internal.test_db.test_table.mv_1"})," was chosen, indicating that the query hit the materialized view."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"example-3-pre-filtering-and-expression-computation-to-accelerate-queries",children:"Example 3: Pre-filtering and Expression Computation to Accelerate Queries"}),"\n",(0,t.jsx)(i.p,{children:"Business Scenario: Pre-filtering data or accelerating expression computation."}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Create a table and materialized views for pre-filtering and expression computation:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"create table d_table (\n   k1 int null,\n   k2 int not null,\n   k3 bigint null,\n   k4 date null\n)\nduplicate key (k1,k2,k3)\ndistributed BY hash(k1) buckets 3\nproperties(\"replication_num\" = \"1\");\n\ninsert into d_table select 1,1,1,'2020-02-20';\ninsert into d_table select 2,2,2,'2021-02-20';\ninsert into d_table select 3,-3,null,'2022-02-20';\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Creating Some Materialized Views:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"-- mv1 Perform expression calculations ahead of time\ncreate materialized view mv1 as \nselect \n    abs(k1)+k2+1,        \n    sum(abs(k2+2)+k3+3) \nfrom \n    d_table \ngroup by \n    abs(k1)+k2+1;\n\n-- mv2 Use where expressions to filter in advance to reduce the amount of data in materialized views\ncreate materialized view mv2 as \nselect \n    year(k4),\n    month(k4) \nfrom \n    d_table \nwhere \n    year(k4) = 2020;\n"})}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Testing Whether the Materialized Views Are Successfully Hit with Some Queries:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"-- Hit mv1\nselect \n    abs(k1)+k2+1,\n    sum(abs(k2+2)+k3+3) \nfrom \n    d_table \ngroup by \n    abs(k1)+k2+1;\n    \n-- Hit mv1\nselect \n    bin(abs(k1)+k2+1),\n    sum(abs(k2+2)+k3+3) \nfrom \n    d_table \ngroup by \n    bin(abs(k1)+k2+1);\n\n-- Hit mv2\nselect \n    year(k4) + month(k4) \nfrom \n    d_table \nwhere \n    year(k4) = 2020;\n\n-- Hit table d_table but not hit mv2, because where condition does not match\nselect \n    year(k4),\n    month(k4) \nfrom \n    d_table;\n\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"faq",children:"FAQ"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"Why isn't the rewrite successful after creating a materialized view?"}),"\n",(0,t.jsx)(i.p,{children:"If no matching data is found, it might be because the materialized view is still in the building process. In this case, you can use the following command to check the build status of the materialized view:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"show alter table materialized view from test_db;\n"})}),"\n",(0,t.jsxs)(i.p,{children:["If the query result shows that the ",(0,t.jsx)(i.code,{children:"status"})," field is not ",(0,t.jsx)(i.code,{children:"FINISHED"}),", you need to wait until the status becomes ",(0,t.jsx)(i.code,{children:"FINISHED"})," before the materialized view becomes available."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"When upgrading from 2.x to 3.0.0, why aren't the previous synchronous materialized views being hit?"}),"\n",(0,t.jsx)(i.p,{children:"Starting from version 3.0.0, transparent rewriting of synchronous materialized views uses plan structure information by default. If you find that materialized views that previously worked in 2.x are not being hit in 3.0.0, you can disable the following switch (which is enabled by default):"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-sql",children:"`SET enable_sync_mv_cost_based_rewrite = true;`\n"})}),"\n"]}),"\n"]})]})}function h(e={}){let{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},250065:function(e,i,n){n.d(i,{Z:function(){return l},a:function(){return r}});var a=n(667294);let t={},s=a.createContext(t);function r(e){let i=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(s.Provider,{value:i},e.children)}}}]);