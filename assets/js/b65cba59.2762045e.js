"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["632534"],{584304:function(e,n,a){a.r(n),a.d(n,{default:()=>p,frontMatter:()=>c,metadata:()=>s,assets:()=>r,toc:()=>d,contentTitle:()=>i});var s=JSON.parse('{"id":"sql-manual/basic-element/sql-data-types/semi-structured/MAP","title":"MAP","description":"Type Description","source":"@site/docs/sql-manual/basic-element/sql-data-types/semi-structured/MAP.md","sourceDirName":"sql-manual/basic-element/sql-data-types/semi-structured","slug":"/sql-manual/basic-element/sql-data-types/semi-structured/MAP","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/semi-structured/MAP","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"MAP","language":"en"},"sidebar":"docs","previous":{"title":"GEO","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/semi-structured/GEO"},"next":{"title":"STRUCT","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/semi-structured/STRUCT"}}'),l=a("785893"),t=a("250065");let c={title:"MAP",language:"en"},i=void 0,r={},d=[{value:"Type Description",id:"type-description",level:2},{value:"Type Constraints",id:"type-constraints",level:2},{value:"Type Construction",id:"type-construction",level:2},{value:"Modifying Type",id:"modifying-type",level:2},{value:"Element Access",id:"element-access",level:2},{value:"Examples",id:"examples",level:2}];function o(e){let n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"type-description",children:"Type Description"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["The ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," type is used to represent a composite type of key-value pairs, where each key uniquely corresponds to a value.\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"key_type"})," represents the type of the keys, supporting types such as ",(0,l.jsx)(n.code,{children:"BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, DECIMAL, DATE, DATETIME, CHAR, VARCHAR, STRING, IPV4, IPV6"}),". Keys are nullable and cannot be specified as NOT NULL."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"value_type"})," represents the type of the values, supporting ",(0,l.jsx)(n.code,{children:"BOOLEAN, TINYINT, SMALLINT, INT, BIGINT, LARGEINT, FLOAT, DOUBLE, DECIMAL, DATE, DATETIME, CHAR, VARCHAR, STRING, IPV4, IPV6, ARRAY, MAP, STRUCT"}),". Values are nullable and cannot be specified as NOT NULL."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"type-constraints",children:"Type Constraints"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["The ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," type allows a maximum nesting depth of 9."]}),"\n",(0,l.jsxs)(n.li,{children:["In ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"}),", keys can be NULL, and identical keys are allowed (NULL and NULL are considered the same key)."]}),"\n",(0,l.jsxs)(n.li,{children:["Conversion between ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," types depends on whether ",(0,l.jsx)(n.code,{children:"key_type"})," and ",(0,l.jsx)(n.code,{children:"value_type"})," can be converted. ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," cannot be converted to other types.\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["For example: ",(0,l.jsx)(n.code,{children:"MAP<INT, INT>"})," can be converted to ",(0,l.jsx)(n.code,{children:"MAP<BIGINT, BIGINT>"})," because ",(0,l.jsx)(n.code,{children:"INT"})," and ",(0,l.jsx)(n.code,{children:"BIGINT"})," can be converted."]}),"\n",(0,l.jsxs)(n.li,{children:["String types can be converted to ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," (through parsing, returning NULL if parsing fails)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["In the ",(0,l.jsx)(n.code,{children:"AGGREGATE"})," table model, ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," only supports ",(0,l.jsx)(n.code,{children:"REPLACE"})," and ",(0,l.jsx)(n.code,{children:"REPLACE_IF_NOT_NULL"}),". ",(0,l.jsx)(n.strong,{children:"In any table model, it cannot be used as a KEY column, nor as a partition or bucket column"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Columns of type ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," do not support comparison or arithmetic operations, ",(0,l.jsxs)(n.strong,{children:["do not support ",(0,l.jsx)(n.code,{children:"ORDER BY"})," and ",(0,l.jsx)(n.code,{children:"GROUP BY"})," operations, cannot be used as ",(0,l.jsx)(n.code,{children:"JOIN KEY"}),", and cannot be used in ",(0,l.jsx)(n.code,{children:"DELETE"})," statements"]}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Columns of type ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," do not support creating any indexes."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"type-construction",children:"Type Construction"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"MAP()"})," function can return a value of type ",(0,l.jsx)(n.code,{children:"MAP"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-SQL",children:"SELECT MAP('Alice', 21, 'Bob', 23);\n\n+-----------------------------+\n| map('Alice', 21, 'Bob', 23) |\n+-----------------------------+\n| {\"Alice\":21, \"Bob\":23}      |\n+-----------------------------+\n"})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"{}"})," can be used to construct a value of type ",(0,l.jsx)(n.code,{children:"MAP"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-SQL",children:"SELECT {'Alice': 20};\n\n+---------------+\n| {'Alice': 20} |\n+---------------+\n| {\"Alice\":20}  |\n+---------------+\n"})}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"modifying-type",children:"Modifying Type"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["Modification is allowed only when ",(0,l.jsx)(n.code,{children:"key_type"})," or ",(0,l.jsx)(n.code,{children:"value_type"})," of ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," is ",(0,l.jsx)(n.code,{children:"VARCHAR"}),"."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["Only allows changing the parameter of ",(0,l.jsx)(n.code,{children:"VARCHAR"})," from smaller to larger, not the other way around."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-SQL",children:'CREATE TABLE `map_table` (\n  `k` INT NOT NULL,\n  `map_varchar_int` MAP<VARCHAR(10), INT>,\n  `map_int_varchar` MAP<INT, VARCHAR(10)>,\n  `map_varchar_varchar` MAP<VARCHAR(10), VARCHAR(10)>\n) ENGINE=OLAP\nDUPLICATE KEY(`k`)\nDISTRIBUTED BY HASH(`k`) BUCKETS 1\nPROPERTIES (\n    "replication_num" = "1"\n);\n\nALTER TABLE map_table MODIFY COLUMN map_varchar_int MAP<VARCHAR(20), INT>;\n\nALTER TABLE map_table MODIFY COLUMN map_int_varchar MAP<INT, VARCHAR(20)>;\n\nALTER TABLE map_table MODIFY COLUMN map_varchar_varchar MAP<VARCHAR(20), VARCHAR(20)>;\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["The default value for columns of type ",(0,l.jsx)(n.code,{children:"MAP<key_type, value_type>"})," can only be specified as NULL, and once specified, it cannot be modified."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"element-access",children:"Element Access"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["Use ",(0,l.jsx)(n.code,{children:"[key]"})," to access the value corresponding to the key in the ",(0,l.jsx)(n.code,{children:"MAP"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-SQL",children:"SELECT {'Alice': 20}['Alice'];\n\n+------------------------+\n| {'Alice': 20}['Alice'] |\n+------------------------+\n|                     20 |\n+------------------------+\n"})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["Use ",(0,l.jsx)(n.code,{children:"ELEMENT_AT(MAP, Key)"})," to access the value corresponding to the key in the ",(0,l.jsx)(n.code,{children:"MAP"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-SQL",children:"SELECT ELEMENT_AT({'Alice': 20}, 'Alice');\n\n+------------------------------------+\n| ELEMENT_AT({'Alice': 20}, 'Alice') |\n+------------------------------------+\n|                                 20 |\n+------------------------------------+\n"})}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Nested MAPs"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-SQL",children:"-- Create table\nCREATE TABLE IF NOT EXISTS map_table (\n    id INT,\n    map_nested MAP<STRING, MAP<STRING, INT>>\n) ENGINE=OLAP\nDUPLICATE KEY(id)\nDISTRIBUTED BY HASH(id) BUCKETS 1\nPROPERTIES (\n    \"replication_allocation\" = \"tag.location.default: 1\"\n);\n\n-- Insert\nINSERT INTO map_table VALUES (1, MAP('key1', MAP('key2', 1, 'key3', 2)));\nINSERT INTO map_table VALUES (2, MAP('key1', MAP('key2', 3, 'key3', 4)));\n\n-- Query\nSELECT map_nested['key1']['key2'] FROM map_table ORDER BY id;\n+----------------------------+\n| map_nested['key1']['key2'] |\n+----------------------------+\n|                          1 |\n|                          3 |\n+----------------------------+\n"})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Nested Complex Types"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-SQL",children:"-- Create table\nCREATE TABLE IF NOT EXISTS map_table (\n    id INT,\n    map_array MAP<STRING, ARRAY<INT>>\n) ENGINE=OLAP\nDUPLICATE KEY(id)\nDISTRIBUTED BY HASH(id) BUCKETS 1\nPROPERTIES (\n    \"replication_allocation\" = \"tag.location.default: 1\"\n);\n\n-- Insert\nINSERT INTO map_table VALUES (1, MAP('key1', [1, 2, 3])), (2, MAP('key1', [4, 5, 6]));\n\n-- Query\nSELECT map_array['key1'][1] FROM map_table ORDER BY id;\n+----------------------+\n| map_array['key1'][1] |\n+----------------------+\n|                    1 |\n|                    4 |\n+----------------------+\n\n-- Create table\nCREATE TABLE IF NOT EXISTS map_table (\n    id INT,\n    map_struct MAP<STRING, STRUCT<id: INT, name: STRING>>\n) ENGINE=OLAP\nDUPLICATE KEY(id)\nDISTRIBUTED BY HASH(id) BUCKETS 1\nPROPERTIES (\n    \"replication_allocation\" = \"tag.location.default: 1\"\n);\n\n-- Insert\nINSERT INTO map_table VALUES (1, MAP('key1', STRUCT(1, 'John'), 'key2', STRUCT(3, 'Jane')));\n\n-- Query\nSELECT STRUCT_ELEMENT(map_struct['key1'], 1), STRUCT_ELEMENT(map_struct['key1'], 'name') FROM map_table ORDER BY id;\n+---------------------------------------+--------------------------------------------+\n| STRUCT_ELEMENT(map_struct['key1'], 1) | STRUCT_ELEMENT(map_struct['key1'], 'name') |\n+---------------------------------------+--------------------------------------------+\n|                                     1 | John                                       |\n+---------------------------------------+--------------------------------------------+\n"})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Modifying Type"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-SQL",children:'-- Create table\nCREATE TABLE `map_table` (\n  `k` INT NOT NULL,\n  `map_varchar_int` MAP<VARCHAR(10), INT>,\n  `map_int_varchar` MAP<INT, VARCHAR(10)>,\n  `map_varchar_varchar` MAP<VARCHAR(10), VARCHAR(10)>\n) ENGINE=OLAP\nDUPLICATE KEY(`k`)\nDISTRIBUTED BY HASH(`k`) BUCKETS 1\nPROPERTIES (\n    "replication_num" = "1"\n);\n\n-- Modify KEY\nALTER TABLE map_table MODIFY COLUMN map_varchar_int MAP<VARCHAR(20), INT>;\n\n-- Modify VALUE\nALTER TABLE map_table MODIFY COLUMN map_int_varchar MAP<INT, VARCHAR(20)>;\n\n-- Modify KEY and VALUE\nALTER TABLE map_table MODIFY COLUMN map_varchar_varchar MAP<VARCHAR(20), VARCHAR(20)>;\n\n-- Check column types\nDESC map_table;\n+---------------------+------------------------------+------+-------+---------+-------+\n| Field               | Type                         | Null | Key   | Default | Extra |\n+---------------------+------------------------------+------+-------+---------+-------+\n| k                   | int                          | No   | true  | NULL    |       |\n| map_varchar_int     | map<varchar(20),int>         | Yes  | false | NULL    | NONE  |\n| map_int_varchar     | map<int,varchar(20)>         | Yes  | false | NULL    | NONE  |\n| map_varchar_varchar | map<varchar(20),varchar(20)> | Yes  | false | NULL    | NONE  |\n+---------------------+------------------------------+------+-------+---------+-------+\n'})}),"\n"]}),"\n"]})]})}function p(e={}){let{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},250065:function(e,n,a){a.d(n,{Z:function(){return i},a:function(){return c}});var s=a(667294);let l={},t=s.createContext(l);function c(e){let n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);