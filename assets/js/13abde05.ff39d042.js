"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["990912"],{568317:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>l,metadata:()=>i,assets:()=>a,toc:()=>c,contentTitle:()=>d});var i=JSON.parse('{"id":"sql-manual/basic-element/sql-data-types/conversion/map-conversion","title":"Cast to MAP Types","description":"MAP type is used to store and process key-value pair data, which can contain various basic types of keys and values,","source":"@site/versioned_docs/version-4.x/sql-manual/basic-element/sql-data-types/conversion/map-conversion.md","sourceDirName":"sql-manual/basic-element/sql-data-types/conversion","slug":"/sql-manual/basic-element/sql-data-types/conversion/map-conversion","permalink":"/docs/4.x/sql-manual/basic-element/sql-data-types/conversion/map-conversion","draft":false,"unlisted":false,"tags":[],"version":"4.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Cast to MAP Types","language":"en","description":"MAP type is used to store and process key-value pair data, which can contain various basic types of keys and values,"},"sidebar":"docs","previous":{"title":"Cast to/from JSON","permalink":"/docs/4.x/sql-manual/basic-element/sql-data-types/conversion/json-conversion"},"next":{"title":"Cast to STRUCT Types","permalink":"/docs/4.x/sql-manual/basic-element/sql-data-types/conversion/struct-conversion"}}'),s=t("785893"),r=t("250065");let l={title:"Cast to MAP Types",language:"en",description:"MAP type is used to store and process key-value pair data, which can contain various basic types of keys and values,"},d=void 0,a={},c=[{value:"Cast to MAP",id:"cast-to-map",level:2},{value:"FROM String",id:"from-string",level:3},{value:"Strict Mode",id:"strict-mode",level:4},{value:"BNF Definition",id:"bnf-definition",level:5},{value:"Rule Description",id:"rule-description",level:5},{value:"Examples",id:"examples",level:5},{value:"Non-Strict Mode",id:"non-strict-mode",level:4},{value:"BNF Definition",id:"bnf-definition-1",level:5},{value:"Rule Description",id:"rule-description-1",level:5},{value:"Examples",id:"examples-1",level:5},{value:"FROM MAP&lt;Other Type&gt;",id:"from-mapother-type",level:3},{value:"Strict Mode",id:"strict-mode-1",level:4},{value:"Rule Description",id:"rule-description-2",level:5},{value:"Examples",id:"examples-2",level:5},{value:"Non-Strict Mode",id:"non-strict-mode-1",level:4},{value:"Rule Description",id:"rule-description-3",level:5},{value:"Examples",id:"examples-3",level:5}];function o(e){let n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"MAP type is used to store and process key-value pair data, which can contain various basic types of keys and values, and can also nest other complex types."}),"\n",(0,s.jsx)(n.h2,{id:"cast-to-map",children:"Cast to MAP"}),"\n",(0,s.jsx)(n.h3,{id:"from-string",children:"FROM String"}),"\n",(0,s.jsx)(n.admonition,{title:"Behavior Change",type:"caution",children:(0,s.jsx)(n.p,{children:"Before version 4.0, some strings that didn't meet the MAP format might be converted normally (for example, '{1:1,2}').\nStarting from version 4.0, strings that don't meet the MAP format will report an error in strict mode and return NULL in non-strict mode."})}),"\n",(0,s.jsx)(n.h4,{id:"strict-mode",children:"Strict Mode"}),"\n",(0,s.jsx)(n.h5,{id:"bnf-definition",children:"BNF Definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<map>          ::= "{" <map-content>? "}" | <empty-map> \n\n<empty-map>    ::= "{}"\n\n<map-content>  ::=  <key-token> <map_key_delimiter> <value-token>\n                     (<collection-delim> <key-token> <map_key_delimiter> <value-token>)*\n\n<key-token>    ::= <whitespace>* "\\"" <inner-sequence> "\\"" <whitespace>*\n                   | <whitespace>* "\'" <inner-sequence> "\'" <whitespace>*\n                   | <whitespace>* <inner-sequence> <whitespace>*\n<value-token>  ::= <key-token>\n\n<inner-sequence>    ::= .*\n<collection-delim>  ::= "," \n<map_key_delimiter> ::= ":"\n'})}),"\n",(0,s.jsx)(n.h5,{id:"rule-description",children:"Rule Description"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The textual representation of a MAP must begin with a left brace ",(0,s.jsx)(n.code,{children:"{"})," and end with a right brace ",(0,s.jsx)(n.code,{children:"}"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Empty MAPs are directly represented as ",(0,s.jsx)(n.code,{children:"{}"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Key-value pairs within the MAP are separated by commas ",(0,s.jsx)(n.code,{children:","}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Each key-value pair consists of a key, a colon ",(0,s.jsx)(n.code,{children:":"}),', and a value, in the order "key:value".']}),"\n",(0,s.jsxs)(n.li,{children:["Keys and values can optionally be enclosed in matching single quotes (",(0,s.jsx)(n.code,{children:"'"}),") or double quotes (",(0,s.jsx)(n.code,{children:'"'}),"). The content inside the quotes is treated as a single entity."]}),"\n",(0,s.jsx)(n.li,{children:"Whitespace is allowed before and after elements within the MAP."}),"\n",(0,s.jsxs)(n.li,{children:["During parsing, parts that match ",(0,s.jsx)(n.code,{children:"<key-token>"})," continue to apply the parsing rules of type K; parts that match ",(0,s.jsx)(n.code,{children:"<value-token>"})," continue to apply the parsing rules of type V. These applied BNF rules and parsing logic are still considered part of the current MAP<K, V>'s BNF and parsing logic, with corresponding error handling and result transfer to the current MAP<K, V>'s behavior and results."]}),"\n",(0,s.jsx)(n.li,{children:'Elements can use "null" to represent a null value.'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If the MAP format is not met, or if the key/value in key-value pairs does not meet the format of the corresponding type, an error is reported."}),"\n",(0,s.jsx)(n.h5,{id:"examples",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Input String"}),(0,s.jsx)(n.th,{children:"Conversion Result"}),(0,s.jsx)(n.th,{children:"Comment"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'"{}"'}),(0,s.jsx)(n.td,{children:"{}"}),(0,s.jsx)(n.td,{children:"Valid empty MAP"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'"  {}"'}),(0,s.jsx)(n.td,{children:"Error"}),(0,s.jsx)(n.td,{children:"Does not start with a brace, parsing fails"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"'{123:456}'"}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:456}"}),(0,s.jsx)(n.td,{children:"Valid MAP"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"'{123:null}'"}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:null}"}),(0,s.jsx)(n.td,{children:"Valid MAP containing null value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"'{   123   :   456    }'"}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:456}"}),(0,s.jsx)(n.td,{children:"Valid MAP with whitespace"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'\'{"123":"456"}\''}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:456}"}),(0,s.jsx)(n.td,{children:"Valid MAP using quotes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'\'{   "123":"abc"  }\''}),(0,s.jsx)(n.td,{children:"Error"}),(0,s.jsx)(n.td,{children:'"abc" cannot be converted to int type'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"'{ 1:2 ,34, 5:6}'"}),(0,s.jsx)(n.td,{children:"Error"}),(0,s.jsx)(n.td,{children:"Does not meet MAP format"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"non-strict-mode",children:"Non-Strict Mode"}),"\n",(0,s.jsx)(n.h5,{id:"bnf-definition-1",children:"BNF Definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<map>          ::= "{" <map-content>? "}" | <empty-map> \n\n<empty-map>    ::= "{}"\n\n<map-content>  ::=  <key-token> <map_key_delimiter> <value-token>\n                     (<collection-delim> <key-token> <map_key_delimiter> <value-token>)*\n\n<key-token>    ::= <whitespace>* "\\"" <inner-sequence> "\\"" <whitespace>*\n                   | <whitespace>* "\'" <inner-sequence> "\'" <whitespace>*\n                   | <whitespace>* <inner-sequence> <whitespace>*\n<value-token>  ::= <key-token>\n\n<inner-sequence>    ::= .*\n<collection-delim>  ::= "," \n<map_key_delimiter> ::= ":"\n'})}),"\n",(0,s.jsx)(n.h5,{id:"rule-description-1",children:"Rule Description"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The textual representation of a MAP must begin with a left brace ",(0,s.jsx)(n.code,{children:"{"})," and end with a right brace ",(0,s.jsx)(n.code,{children:"}"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Empty MAPs are directly represented as ",(0,s.jsx)(n.code,{children:"{}"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Key-value pairs within the MAP are separated by commas ",(0,s.jsx)(n.code,{children:","}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Each key-value pair consists of a key, a colon ",(0,s.jsx)(n.code,{children:":"}),', and a value, in the order "key:value".']}),"\n",(0,s.jsxs)(n.li,{children:["Keys and values can optionally be enclosed in matching single quotes (",(0,s.jsx)(n.code,{children:"'"}),") or double quotes (",(0,s.jsx)(n.code,{children:'"'}),"). The content inside the quotes is treated as a single entity."]}),"\n",(0,s.jsx)(n.li,{children:"Whitespace is allowed before and after elements within the MAP."}),"\n",(0,s.jsxs)(n.li,{children:["During parsing, parts that match ",(0,s.jsx)(n.code,{children:"<key-token>"})," continue to apply the parsing rules of type K; parts that match ",(0,s.jsx)(n.code,{children:"<value-token>"})," continue to apply the parsing rules of type V. These applied BNF rules and parsing logic are still considered part of the current MAP<K, V>'s BNF and parsing logic, with corresponding error handling and result transfer to the current MAP<K, V>'s behavior and results."]}),"\n",(0,s.jsx)(n.li,{children:'Elements can use "null" to represent a null value.'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If the MAP format does not meet the BNF format above, NULL is returned.\nIf key/value in key-value pairs does not meet the format of the corresponding type, the corresponding position is set to null."}),"\n",(0,s.jsx)(n.h5,{id:"examples-1",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Input String"}),(0,s.jsx)(n.th,{children:"Conversion Result"}),(0,s.jsx)(n.th,{children:"Comment"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'"{}"'}),(0,s.jsx)(n.td,{children:"{}"}),(0,s.jsx)(n.td,{children:"Valid empty MAP"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'"  {}"'}),(0,s.jsx)(n.td,{children:"NULL"}),(0,s.jsx)(n.td,{children:"Does not start with a brace, parsing fails"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"'{123:456}'"}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:456}"}),(0,s.jsx)(n.td,{children:"Valid MAP"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"'{123:null}'"}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:null}"}),(0,s.jsx)(n.td,{children:"Valid MAP containing null value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"'{   123   :   456    }'"}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:456}"}),(0,s.jsx)(n.td,{children:"Valid MAP with whitespace"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'\'{"123":"456"}\''}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:456}"}),(0,s.jsx)(n.td,{children:"Valid MAP using quotes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'\'{   "123":"abc"  }\''}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:null}"}),(0,s.jsx)(n.td,{children:'"abc" cannot be converted to int type, converted to null'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"'{ 1:2 ,34, 5:6}'"}),(0,s.jsx)(n.td,{children:"NULL"}),(0,s.jsx)(n.td,{children:"Does not meet MAP format"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"from-mapother-type",children:"FROM MAP<Other Type>"}),"\n",(0,s.jsx)(n.h4,{id:"strict-mode-1",children:"Strict Mode"}),"\n",(0,s.jsx)(n.h5,{id:"rule-description-2",children:"Rule Description"}),"\n",(0,s.jsx)(n.p,{children:"For each element in the MAP, a Cast from Other Type To Type is performed. The Cast is also in strict mode."}),"\n",(0,s.jsx)(n.h5,{id:"examples-2",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Input MAP"}),(0,s.jsx)(n.th,{children:"Conversion Result"}),(0,s.jsx)(n.th,{children:"Comment"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'{"123":"456"}'}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:456}"}),(0,s.jsx)(n.td,{children:'"123" and "456" can be converted to Int'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'{"abc":"123"}'}),(0,s.jsx)(n.td,{children:"Error"}),(0,s.jsx)(n.td,{children:'"abc" cannot be converted to Int'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'{"123":null}'}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:null}"}),(0,s.jsx)(n.td,{children:"The Cast result of null is still null"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"non-strict-mode-1",children:"Non-Strict Mode"}),"\n",(0,s.jsx)(n.h5,{id:"rule-description-3",children:"Rule Description"}),"\n",(0,s.jsx)(n.p,{children:"For each element in the MAP, a Cast from Other Type To Type is performed. The Cast is also in non-strict mode."}),"\n",(0,s.jsx)(n.h5,{id:"examples-3",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Input MAP"}),(0,s.jsx)(n.th,{children:"Conversion Result"}),(0,s.jsx)(n.th,{children:"Comment"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'{"123":"456"}'}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:456}"}),(0,s.jsx)(n.td,{children:'"123" and "456" can be converted to Int'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'{"abc":"123"}'}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {null:123}"}),(0,s.jsx)(n.td,{children:'"abc" cannot be converted to Int, converted to null'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'{"123":null}'}),(0,s.jsx)(n.td,{children:"Cast to MAP<int,int>: {123:null}"}),(0,s.jsx)(n.td,{children:"The Cast result of null is still null"})]})]})]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return d},a:function(){return l}});var i=t(667294);let s={},r=i.createContext(s);function l(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);