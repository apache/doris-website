"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["599944"],{999989:function(e,n,s){s.r(n),s.d(n,{default:()=>h,frontMatter:()=>d,metadata:()=>t,assets:()=>a,toc:()=>c,contentTitle:()=>l});var t=JSON.parse('{"id":"sql-manual/basic-element/sql-data-types/semi-structured/VARIANT","title":"VARIANT","description":"The VARIANT type stores semi-structured JSON data. It can contain different primitive types (integers, strings, booleans, etc.), one-dimensional arrays, and nested objects. On write, Doris infers the structure and type of sub-paths based on JSON paths and materializes frequent paths as independent subcolumns, leveraging columnar storage and vectorized execution for both flexibility and performance.","source":"@site/versioned_docs/version-3.x/sql-manual/basic-element/sql-data-types/semi-structured/VARIANT.md","sourceDirName":"sql-manual/basic-element/sql-data-types/semi-structured","slug":"/sql-manual/basic-element/sql-data-types/semi-structured/VARIANT","permalink":"/docs/3.x/sql-manual/basic-element/sql-data-types/semi-structured/VARIANT","draft":false,"unlisted":false,"tags":[],"version":"3.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"VARIANT","language":"en","description":"The VARIANT type stores semi-structured JSON data. It can contain different primitive types (integers, strings, booleans, etc.), one-dimensional arrays, and nested objects. On write, Doris infers the structure and type of sub-paths based on JSON paths and materializes frequent paths as independent subcolumns, leveraging columnar storage and vectorized execution for both flexibility and performance."},"sidebar":"docs","previous":{"title":"JSON","permalink":"/docs/3.x/sql-manual/basic-element/sql-data-types/semi-structured/JSON"},"next":{"title":"HLL (HyperLogLog)","permalink":"/docs/3.x/sql-manual/basic-element/sql-data-types/aggregate/HLL"}}'),i=s("785893"),r=s("250065");let d={title:"VARIANT",language:"en",description:"The VARIANT type stores semi-structured JSON data. It can contain different primitive types (integers, strings, booleans, etc.), one-dimensional arrays, and nested objects. On write, Doris infers the structure and type of sub-paths based on JSON paths and materializes frequent paths as independent subcolumns, leveraging columnar storage and vectorized execution for both flexibility and performance."},l=void 0,a={},c=[{value:"VARIANT",id:"variant",level:2},{value:"Overview",id:"overview",level:2},{value:"Using VARIANT",id:"using-variant",level:2},{value:"Create table syntax",id:"create-table-syntax",level:3},{value:"Query syntax",id:"query-syntax",level:3},{value:"Primitive types",id:"primitive-types",level:2},{value:"Extended types (Schema Template)",id:"extended-types-schema-template",level:2},{value:"Type conflicts and promotion rules",id:"type-conflicts-and-promotion-rules",level:2},{value:"Variant indexes",id:"variant-indexes",level:2},{value:"Choosing indexes",id:"choosing-indexes",level:3},{value:"Index by subpath",id:"index-by-subpath",level:3},{value:"When indexes don\u2019t work",id:"when-indexes-dont-work",level:3},{value:"Nested type",id:"nested-type",level:2},{value:"INSERT and load",id:"insert-and-load",level:2},{value:"INSERT INTO VALUES",id:"insert-into-values",level:3},{value:"Load (Stream Load)",id:"load-stream-load",level:3},{value:"Supported operations and CAST rules",id:"supported-operations-and-cast-rules",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Inspect number of columns and types",id:"inspect-number-of-columns-and-types",level:2},{value:"Compared with JSON type",id:"compared-with-json-type",level:2},{value:"FAQ",id:"faq",level:2}];function o(e){let n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"variant",children:"VARIANT"}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The VARIANT type stores semi-structured JSON data. It can contain different primitive types (integers, strings, booleans, etc.), one-dimensional arrays, and nested objects. On write, Doris infers the structure and type of sub-paths based on JSON paths and materializes frequent paths as independent subcolumns, leveraging columnar storage and vectorized execution for both flexibility and performance."}),"\n",(0,i.jsx)(n.h2,{id:"using-variant",children:"Using VARIANT"}),"\n",(0,i.jsx)(n.h3,{id:"create-table-syntax",children:"Create table syntax"}),"\n",(0,i.jsx)(n.p,{children:"Declare a VARIANT column when creating a table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS ${table_name} (\n    k BIGINT,\n    v VARIANT\n)\nPROPERTIES("replication_num" = "1");\n'})}),"\n",(0,i.jsx)(n.p,{children:"Constrain certain paths with a Schema Template (see \u201CExtended types\u201D):"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"This feature has been supported since version 3.1.0."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS ${table_name} (\n    k BIGINT,\n    v VARIANT <\n        'id' : INT,            -- restrict path id to INT\n        'message*' : STRING,   -- restrict message* prefix to STRING\n        'tags*' : ARRAY<TEXT>  -- restrict tags* prefix to ARRAY<TEXT>\n    >\n)\nPROPERTIES(\"replication_num\" = \"1\");\n"})}),"\n",(0,i.jsx)(n.h3,{id:"query-syntax",children:"Query syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Access nested fields (returns VARIANT; explicit or implicit CAST is required for aggregation/comparison)\nSELECT v['properties']['title'] FROM ${table_name};\n\n-- CAST to a concrete type before aggregation\nSELECT CAST(v['properties']['title'] AS STRING) AS title\nFROM ${table_name}\nGROUP BY title;\n\n-- Query arrays\nSELECT *\nFROM ${table_name}\nWHERE ARRAY_CONTAINS(CAST(v['tags'] AS ARRAY<TEXT>), 'Doris');\n"})}),"\n",(0,i.jsx)(n.h2,{id:"primitive-types",children:"Primitive types"}),"\n",(0,i.jsx)(n.p,{children:"VARIANT infers subcolumn types automatically. Supported types include:"}),"\n",(0,i.jsx)(n.table,{children:(0,i.jsxs)(n.tbody,{children:[(0,i.jsx)(n.tr,{children:(0,i.jsxs)(n.td,{children:["Supported types",(0,i.jsx)(n.br,{})]})}),(0,i.jsx)(n.tr,{children:(0,i.jsxs)(n.td,{children:["TinyInt",(0,i.jsx)(n.br,{})]})}),(0,i.jsx)(n.tr,{children:(0,i.jsxs)(n.td,{children:["NULL (equivalent to JSON null)",(0,i.jsx)(n.br,{})]})}),(0,i.jsx)(n.tr,{children:(0,i.jsxs)(n.td,{children:["BigInt (64 bit)",(0,i.jsx)(n.br,{}),"Double",(0,i.jsx)(n.br,{})]})}),(0,i.jsx)(n.tr,{children:(0,i.jsxs)(n.td,{children:["String (Text)",(0,i.jsx)(n.br,{})]})}),(0,i.jsx)(n.tr,{children:(0,i.jsxs)(n.td,{children:["Jsonb",(0,i.jsx)(n.br,{})]})}),(0,i.jsx)(n.tr,{children:(0,i.jsxs)(n.td,{children:["Variant (nested object)",(0,i.jsx)(n.br,{})]})}),(0,i.jsx)(n.tr,{children:(0,i.jsxs)(n.td,{children:["Array<T> (one-dimensional only)",(0,i.jsx)(n.br,{})]})})]})}),"\n",(0,i.jsx)(n.p,{children:"Simple INSERT example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"INSERT INTO vartab VALUES\n  (1, 'null'),\n  (2, NULL),\n  (3, 'true'),\n  (4, '-17'),\n  (5, '123.12'),\n  (6, '1.912'),\n  (7, '\"A quote\"'),\n  (8, '[-1, 12, false]'),\n  (9, '{ \"x\": \"abc\", \"y\": false, \"z\": 10 }'),\n  (10, '\"2021-01-01\"');\n"})}),"\n",(0,i.jsx)(n.p,{children:"Tip: Non-standard JSON types such as date/time will be stored as strings unless a Schema Template is provided. For better computation efficiency, consider extracting them to static columns or declaring their types via a Schema Template."}),"\n",(0,i.jsx)(n.h2,{id:"extended-types-schema-template",children:"Extended types (Schema Template)"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"This feature has been supported since version 3.1.0."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Besides primitive types, VARIANT supports the following extended types via Schema Template:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Number (extended)\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Decimal: Decimal32 / Decimal64 / Decimal128 / Decimal256"}),"\n",(0,i.jsx)(n.li,{children:"LargeInt"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Datetime"}),"\n",(0,i.jsx)(n.li,{children:"Date"}),"\n",(0,i.jsx)(n.li,{children:"IPV4 / IPV6"}),"\n",(0,i.jsx)(n.li,{children:"Boolean"}),"\n",(0,i.jsx)(n.li,{children:"ARRAY<T> (T can be any of the above, one-dimensional only)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Note: Predefined Schema can only be specified at table creation. ALTER is currently not supported (future versions may support adding new subcolumn definitions, but changing an existing subcolumn type is not supported)."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE test_var_schema (\n    id BIGINT NOT NULL,\n    v1 VARIANT<\n        \'large_int_val\': LARGEINT,\n        \'string_val\': STRING,\n        \'decimal_val\': DECIMAL(38, 9),\n        \'datetime_val\': DATETIME,\n        \'ip_val\': IPV4\n    > NULL\n)\nPROPERTIES ("replication_num" = "1");\n\nINSERT INTO test_var_schema VALUES (1, \'{\n    "large_int_val" : "123222222222222222222222",\n    "string_val" : "Hello World",\n    "decimal_val" : 1.11111111,\n    "datetime_val" : "2025-05-16 11:11:11",\n    "ip_val" : "127.0.0.1"\n}\');\n\nSELECT variant_type(v1) FROM test_var_schema;\n\n+----------------------------------------------------------------------------------------------------------------------------+\n| variant_type(v1)                                                                                                           |\n+----------------------------------------------------------------------------------------------------------------------------+\n| {"datetime_val":"datetimev2","decimal_val":"decimal128i","ip_val":"ipv4","large_int_val":"largeint","string_val":"string"} |\n+----------------------------------------------------------------------------------------------------------------------------+\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'{"date": 2020-01-01}'})," and ",(0,i.jsx)(n.code,{children:'{"ip": 127.0.0.1}'})," are invalid JSON texts; the correct format is ",(0,i.jsx)(n.code,{children:'{"date": "2020-01-01"}'})," and ",(0,i.jsx)(n.code,{children:'{"ip": "127.0.0.1"}'}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Once a Schema Template is specified, if a JSON value conflicts with the declared type and cannot be converted, it will be stored as NULL. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'INSERT INTO test_var_schema VALUES (1, \'{\n  "decimal_val" : "1.11111111",\n  "ip_val" : "127.xxxxxx.xxxx",\n  "large_int_val" : "aaabbccc"\n}\');\n\n-- Only decimal_val remains\nSELECT * FROM test_var_schema;\n\n+------+-----------------------------+\n| id   | v1                          |\n+------+-----------------------------+\n|    1 | {"decimal_val":1.111111110} |\n+------+-----------------------------+\n'})}),"\n",(0,i.jsx)(n.p,{children:"Schema only guides the persisted storage type. During query execution, the effective type depends on actual data at runtime:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- At runtime v['a'] may still be STRING\nSELECT variant_type(CAST('{\"a\" : \"12345\"}' AS VARIANT<'a' : INT>)['a']);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Wildcard matching and order:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE test_var_schema (\n    id BIGINT NOT NULL,\n    v1 VARIANT<\n        'enumString*' : STRING,\n        'enum*' : ARRAY<TEXT>,\n        'ip*' : IPV6\n    > NULL\n)\nPROPERTIES (\"replication_num\" = \"1\");\n\n-- If enumString1 matches both patterns, the first matching pattern in definition order (STRING) is used\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If a column name contains ",(0,i.jsx)(n.code,{children:"*"})," and you want to match it by its literal name (not as a prefix wildcard), use:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"v1 VARIANT<\n    MATCH_NAME 'enumString*' : STRING\n> NULL\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Matched subpaths are materialized as columns by default. If too many paths match and generate excessive columns, consider enabling ",(0,i.jsx)(n.code,{children:"variant_enable_typed_paths_to_sparse"})," (see \u201CConfiguration\u201D)."]}),"\n",(0,i.jsx)(n.h2,{id:"type-conflicts-and-promotion-rules",children:"Type conflicts and promotion rules"}),"\n",(0,i.jsx)(n.p,{children:"When incompatible types appear on the same path (e.g., the same field shows up as both integer and string), the type is promoted to JSONB to avoid information loss:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'{"a" : 12345678}\n{"a" : "HelloWorld"}\n-- a will be promoted to JSONB\n'})}),"\n",(0,i.jsx)(n.p,{children:"Promotion rules:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Source type"}),(0,i.jsx)(n.th,{children:"Current type"}),(0,i.jsx)(n.th,{children:"Final type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TinyInt"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BigInt"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BigInt"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TinyInt"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Double"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Double"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TinyInt"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JSONB"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TinyInt"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Array"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JSONB"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BigInt"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Double"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JSONB"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BigInt"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JSONB"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BigInt"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Array"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JSONB"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Double"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JSONB"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Double"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Array"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JSONB"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Array<Double>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Array<String>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Array<Jsonb>"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"If you need strict types (for stable indexing and storage), declare them via Schema Template."}),"\n",(0,i.jsx)(n.h2,{id:"variant-indexes",children:"Variant indexes"}),"\n",(0,i.jsx)(n.h3,{id:"choosing-indexes",children:"Choosing indexes"}),"\n",(0,i.jsx)(n.p,{children:"VARIANT supports BloomFilter and Inverted Index on subpaths."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"High-cardinality equality/IN filters: prefer BloomFilter (sparser index, better write performance)."}),"\n",(0,i.jsxs)(n.li,{children:["Tokenization/phrase/range search: use Inverted Index and set proper ",(0,i.jsx)(n.code,{children:"parser"}),"/",(0,i.jsx)(n.code,{children:"analyzer"})," properties."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'...  \nPROPERTIES("replication_num" = "1", "bloom_filter_columns" = "v");\n\n-- Use BloomFilter for equality/IN filters\nSELECT * FROM tbl WHERE v[\'id\'] = 12345678;\nSELECT * FROM tbl WHERE v[\'id\'] IN (1, 2, 3);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Once an inverted index is created on a VARIANT column, all subpaths inherit the same index properties (e.g., parser):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS tbl (\n    k BIGINT,\n    v VARIANT,\n    INDEX idx_v(v) USING INVERTED PROPERTIES(\"parser\" = \"english\")\n);\n\n-- All subpaths inherit the english parser\nSELECT * FROM tbl WHERE v['id_1'] MATCH 'Doris';\nSELECT * FROM tbl WHERE v['id_2'] MATCH 'Apache';\n"})}),"\n",(0,i.jsx)(n.h3,{id:"index-by-subpath",children:"Index by subpath"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"This feature has been supported since version 3.1.0."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In 3.1.x/4.0 and later, you can specify index properties for certain VARIANT subpaths, and even configure both tokenized and non-tokenized inverted indexes for the same path. Path-specific indexes require the path type to be declared via Schema Template."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'-- Common properties: field_pattern (target path), analyzer, parser, support_phrase, etc.\nCREATE TABLE IF NOT EXISTS tbl (\n    k BIGINT,\n    v VARIANT<\'content\' : STRING>,\n    INDEX idx_tokenized(v) USING INVERTED PROPERTIES("parser" = "english", "field_pattern" = "content"),\n    INDEX idx_v(v) USING INVERTED PROPERTIES("field_pattern" = "content")\n);\n\n-- v.content has both tokenized and non-tokenized inverted indexes\nSELECT * FROM tbl WHERE v[\'content\'] MATCH \'Doris\';\nSELECT * FROM tbl WHERE v[\'content\'] = \'Doris\';\n'})}),"\n",(0,i.jsx)(n.p,{children:"Wildcard path indexing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS tbl (\n    k BIGINT,\n    v VARIANT<'pattern_*' : STRING>,\n    INDEX idx_tokenized(v) USING INVERTED PROPERTIES(\"parser\" = \"english\", \"field_pattern\" = \"pattern_*\"),\n    INDEX idx_v(v) USING INVERTED -- global non-tokenized inverted index\n);\n\nSELECT * FROM tbl WHERE v['pattern_1'] MATCH 'Doris';\nSELECT * FROM tbl WHERE v['pattern_1'] = 'Doris';\n"})}),"\n",(0,i.jsx)(n.p,{children:"Note: 2.1.7+ supports only InvertedIndex V2 properties (fewer files, lower write IOPS; suitable for disaggregated storage/compute). 2.1.8+ removes offline Build Index."}),"\n",(0,i.jsx)(n.h3,{id:"when-indexes-dont-work",children:"When indexes don\u2019t work"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Type changes cause index loss: if a subpath changes to an incompatible type (e.g., INT \u2192 JSONB), the index is lost. Fix by pinning types and indexes via Schema Template."}),"\n",(0,i.jsxs)(n.li,{children:["Query type mismatch:\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- v['id'] is actually STRING; using INT equality causes index not to be used\nSELECT * FROM tbl WHERE v['id'] = 123456;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Misconfigured index: indexes apply to subpaths, not the entire VARIANT column.\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- VARIANT itself cannot be indexed as a whole\nSELECT * FROM tbl WHERE v MATCH 'Doris';\n\n-- If whole-JSON search is needed, store a duplicate STRING column and index it\nCREATE TABLE IF NOT EXISTS tbl (\n    k BIGINT,\n    v VARIANT,\n    v_str STRING,\n    INDEX idx_v_str(v_str) USING INVERTED PROPERTIES(\"parser\" = \"english\")\n);\nSELECT * FROM tbl WHERE v_str MATCH 'Doris';\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"nested-type",children:"Nested type"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"This feature is experimental."}),". To use it, you need to set the session variable ",(0,i.jsx)(n.code,{children:"set enable_variant_flatten_nested = true"})," when creating the table."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "nested" : [{"field1" : 123, "field11" : "123"}, {"field2" : 456, "field22" : "456"}]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"In the JSON above, the objects contained in the array nested are referred to as nested array types.\nNote that currently only one level of array expansion is supported, and the top-level array cannot be expanded."}),"\n",(0,i.jsx)(n.p,{children:"Top-level array"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:' [{"field1" : 123, "field11" : "123"}, {"field2" : 456, "field22" : "456"}]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Multi-level arrays"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "nested" : [{"field1" : 123, "field11" : "123"}, {"field2" : 456, "nested2" : []}]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Multi-level nesting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "nested" : [{"field1" : 123, "field11" : "123"}, {"field2" : 456, "nested2" : [{"a" : 123}]}]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The above data cannot be expanded at the moment."}),"\n",(0,i.jsx)(n.p,{children:"Table creation sql"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE `simple_nested_test` (\n  `k` bigint NULL,\n  `v` variant NULL\n) ENGINE=OLAP\nDUPLICATE KEY(`k`)\nDISTRIBUTED BY HASH(`k`) BUCKETS 8\nPROPERTIES (\n  "variant_enable_flatten_nested" = "true"\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"insert-and-load",children:"INSERT and load"}),"\n",(0,i.jsx)(n.h3,{id:"insert-into-values",children:"INSERT INTO VALUES"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS variant_tbl (\n    k BIGINT,\n    v VARIANT\n) PROPERTIES(\"replication_num\" = \"1\");\n\nINSERT INTO variant_tbl VALUES (1, '{\"a\" : 123}');\n\nselect * from variant_tbl;\n+------+-----------+\n| k    | v         |\n+------+-----------+\n|    1 | {\"a\":123} |\n+------+-----------+\n\n-- v['a'] is a VARIANT\nselect v['a'] from variant_tbl;\n+--------+\n| v['a'] |\n+--------+\n| 123    |\n+--------+\n\n-- Accessing a non-existent key returns NULL\nselect v['a']['no_such_key'] from variant_tbl;;\n+-----------------------+\n| v['a']['no_such_key'] |\n+-----------------------+\n| NULL                  |\n+-----------------------+\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"load-stream-load",children:"Load (Stream Load)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Line-delimited JSON (one JSON record per line)\ncurl --location-trusted -u root: -T gh_2022-11-07-3.json \\\n  -H "read_json_by_line:true" -H "format:json" \\\n  http://127.0.0.1:8030/api/test_variant/github_events/_stream_load\n'})}),"\n",(0,i.jsxs)(n.p,{children:["See also: ",(0,i.jsx)(n.code,{children:"https://doris.apache.org/docs/dev/data-operate/import/complex-types/variant"})]}),"\n",(0,i.jsxs)(n.p,{children:["After loading, verify with ",(0,i.jsx)(n.code,{children:"SELECT count(*)"})," or sample with ",(0,i.jsx)(n.code,{children:"SELECT * ... LIMIT 1"}),". For high-throughput ingestion, prefer RANDOM bucketing and enable Group Commit."]}),"\n",(0,i.jsx)(n.h2,{id:"supported-operations-and-cast-rules",children:"Supported operations and CAST rules"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"VARIANT cannot be compared/operated directly with other types; comparisons between two VARIANTs are not supported either."}),"\n",(0,i.jsx)(n.li,{children:"For comparison, filtering, aggregation, and ordering, CAST subpaths to concrete types (explicitly or implicitly)."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Explicit CAST\nSELECT CAST(v['arr'] AS ARRAY<TEXT>) FROM tbl;\nSELECT * FROM tbl WHERE CAST(v['decimal'] AS DECIMAL(27, 9)) = 1.111111111;\nSELECT * FROM tbl WHERE CAST(v['date'] AS DATE) = '2021-01-02';\n\n-- Implicit CAST\nSELECT * FROM tbl WHERE v['bool'];\nSELECT * FROM tbl WHERE v['str'] MATCH 'Doris';\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"VARIANT itself cannot be used directly in ORDER BY, GROUP BY, as a JOIN KEY, or as an aggregate argument; CAST subpaths instead."}),"\n",(0,i.jsx)(n.li,{children:"Strings can be implicitly converted to VARIANT."}),"\n"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"VARIANT"}),(0,i.jsx)(n.th,{children:"Castable"}),(0,i.jsx)(n.th,{children:"Coercible"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ARRAY"})}),(0,i.jsx)(n.td,{children:"\u2714"}),(0,i.jsx)(n.td,{children:"\u274C"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BOOLEAN"})}),(0,i.jsx)(n.td,{children:"\u2714"}),(0,i.jsx)(n.td,{children:"\u2714"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"DATE/DATETIME"})}),(0,i.jsx)(n.td,{children:"\u2714"}),(0,i.jsx)(n.td,{children:"\u2714"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"FLOAT"})}),(0,i.jsx)(n.td,{children:"\u2714"}),(0,i.jsx)(n.td,{children:"\u2714"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"IPV4/IPV6"})}),(0,i.jsx)(n.td,{children:"\u2714"}),(0,i.jsx)(n.td,{children:"\u2714"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"DECIMAL"})}),(0,i.jsx)(n.td,{children:"\u2714"}),(0,i.jsx)(n.td,{children:"\u2714"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"MAP"})}),(0,i.jsx)(n.td,{children:"\u274C"}),(0,i.jsx)(n.td,{children:"\u274C"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TIMESTAMP"})}),(0,i.jsx)(n.td,{children:"\u2714"}),(0,i.jsx)(n.td,{children:"\u2714"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"VARCHAR"})}),(0,i.jsx)(n.td,{children:"\u2714"}),(0,i.jsx)(n.td,{children:"\u2714"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"JSON"})}),(0,i.jsx)(n.td,{children:"\u2714"}),(0,i.jsx)(n.td,{children:"\u2714"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"variant_max_subcolumns_count"}),"(only versions above 3.1 support this): default 0 (no limit). In production, set to 2048 (tablet level) to control the number of materialized paths. Above the threshold, low-frequency/sparse paths are moved to a shared data structure; reading from it may be slower (see \u201CConfiguration\u201D)."]}),"\n",(0,i.jsxs)(n.li,{children:["If a path type is specified via Schema Template((only versions above 3.1 support this)), that path will be forced to be materialized; when ",(0,i.jsx)(n.code,{children:"variant_enable_typed_paths_to_sparse = true"}),", it also counts toward the threshold and may be moved to the shared structure."]}),"\n",(0,i.jsx)(n.li,{children:"JSON key length \u2264 255."}),"\n",(0,i.jsx)(n.li,{children:"Cannot be a primary key or sort key."}),"\n",(0,i.jsxs)(n.li,{children:["Cannot be nested within other types (e.g., ",(0,i.jsx)(n.code,{children:"Array<Variant>"}),", ",(0,i.jsx)(n.code,{children:"Struct<Variant>"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Reading the entire VARIANT column scans all subpaths. If a column has many subpaths, consider storing the original JSON string in an extra STRING/JSONB column for whole-object searches like ",(0,i.jsx)(n.code,{children:"LIKE"}),":"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE example_table (\n  id INT,\n  data_variant VARIANT\n);\nSELECT * FROM example_table WHERE data_variant LIKE '%doris%';\n\n-- Better: keep the original JSON string for whole-object matching\nCREATE TABLE example_table (\n  id INT,\n  data_string STRING,\n  data_variant VARIANT\n);\nSELECT * FROM example_table WHERE data_string LIKE '%doris%';\n"})}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Since version 3.1.0, the properties ",(0,i.jsx)(n.code,{children:"variant_max_subcolumns_count"})," and ",(0,i.jsx)(n.code,{children:"variant_enable_typed_paths_to_sparse"})," are supported, and they cannot be modified using ",(0,i.jsx)(n.code,{children:"ALTER"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE example_table (\n  id INT,\n  data_variant VARIANT<\n      'path_1' : INT,\n      'path_2' : STRING,\n      properties(\n          'variant_max_subcolumns_count' = '2048',\n          'variant_enable_typed_paths_to_sparse' = 'true'\n      )\n  >\n);\n"})}),"\n",(0,i.jsx)(n.table,{children:(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Property"}),(0,i.jsx)(n.td,{children:"Description"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"`variant_max_subcolumns_count` (only versions above 3.1 support this)"}),(0,i.jsx)(n.td,{children:"Max number of materialized paths. Above the threshold, new paths may be stored in a shared data structure. Default: 2048 (Recommended). 0 means no limit; do not exceed 10000."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"`variant_enable_typed_paths_to_sparse` (only versions above 3.1 support this)"}),(0,i.jsx)(n.td,{children:"By default, typed paths are always materialized (and do not count against `variant_max_subcolumns_count`). When set to `true`, typed paths also count toward the threshold and may be moved to the shared structure."})]})]})}),"\n",(0,i.jsx)(n.p,{children:"Behavior at limits and tuning suggestions:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"After exceeding the threshold, new paths are written into the shared structure; Rowset merges may also recycle some paths into the shared structure (only versions above 3.1 support this)."}),"\n",(0,i.jsx)(n.li,{children:"The system prefers to keep paths with higher non-null ratios and higher access frequencies materialized (only versions above 3.1 support this)."}),"\n",(0,i.jsx)(n.li,{children:"Close to 10,000 materialized paths requires strong hardware (\u2265128G RAM, \u226532C per node recommended) (only versions above 3.1 support this)."}),"\n",(0,i.jsxs)(n.li,{children:["Ingestion tuning: increase client ",(0,i.jsx)(n.code,{children:"batch_size"})," appropriately, or use Group Commit (increase ",(0,i.jsx)(n.code,{children:"group_commit_interval_ms"}),"/",(0,i.jsx)(n.code,{children:"group_commit_data_bytes"})," as needed)."]}),"\n",(0,i.jsx)(n.li,{children:"If partition pruning is not needed, consider RANDOM bucketing and enabling single-tablet loading to reduce compaction write amplification."}),"\n",(0,i.jsxs)(n.li,{children:["BE tuning knobs: ",(0,i.jsx)(n.code,{children:"max_cumu_compaction_threads"})," (\u22658), ",(0,i.jsx)(n.code,{children:"vertical_compaction_num_columns_per_group=500"})," (improves vertical compaction but increases memory), ",(0,i.jsx)(n.code,{children:"segment_cache_memory_percentage=20"})," (improves metadata cache efficiency)."]}),"\n",(0,i.jsx)(n.li,{children:"Watch Compaction Score; if it keeps rising, compaction is lagging\u2014reduce ingestion pressure."}),"\n",(0,i.jsxs)(n.li,{children:["Avoid large ",(0,i.jsx)(n.code,{children:"SELECT *"})," on VARIANT; prefer specific projections like ",(0,i.jsx)(n.code,{children:"SELECT v['path']"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Note: If you see Stream Load error ",(0,i.jsx)(n.code,{children:"[DATA_QUALITY_ERROR]Reached max column size limit 2048"})," (only on 2.1.x and 3.0.x), it means the merged tablet schema reached its column limit. You may increase ",(0,i.jsx)(n.code,{children:"variant_max_merged_tablet_schema_size"})," (not recommended beyond 4096; requires strong hardware)."]}),"\n",(0,i.jsx)(n.h2,{id:"inspect-number-of-columns-and-types",children:"Inspect number of columns and types"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Solution 1 is supported starting from version 3.1.0. For earlier versions, it is recommended to use DESC."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Approach 1: use ",(0,i.jsx)(n.code,{children:"variant_type"})," to inspect per-row schema (more precise, higher cost):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT variant_type(v) FROM variant_tbl;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Approach 2: extended ",(0,i.jsx)(n.code,{children:"DESC"})," to show materialized subpaths (only those extracted):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SET describe_extend_variant_column = true;\nDESC variant_tbl;\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"DESCRIBE ${table_name} PARTITION ($partition_name);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Use both: Approach 1 is precise; Approach 2 is efficient."}),"\n",(0,i.jsx)(n.h2,{id:"compared-with-json-type",children:"Compared with JSON type"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Storage: JSON is stored as JSONB (row-oriented). VARIANT is inferred and materialized into columns on write (higher compression, smaller size)."}),"\n",(0,i.jsx)(n.li,{children:"Query: JSON requires parsing. VARIANT scans columns directly and is usually much faster."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"ClickBench (43 queries):"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Storage: VARIANT saves ~65% vs JSON."}),"\n",(0,i.jsx)(n.li,{children:"Query: VARIANT is 8x+ faster than JSON, close to predefined static columns."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Storage space"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Size"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Predefined columns"}),(0,i.jsx)(n.td,{children:"12.618 GB"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"VARIANT"}),(0,i.jsx)(n.td,{children:"12.718 GB"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"JSON"}),(0,i.jsx)(n.td,{children:"35.711 GB"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"~65% space savings"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Run"}),(0,i.jsx)(n.th,{children:"Predefined"}),(0,i.jsx)(n.th,{children:"VARIANT"}),(0,i.jsx)(n.th,{children:"JSON"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"First (cold)"}),(0,i.jsx)(n.td,{children:"233.79s"}),(0,i.jsx)(n.td,{children:"248.66s"}),(0,i.jsx)(n.td,{children:"Most timed out"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Second (hot)"}),(0,i.jsx)(n.td,{children:"86.02s"}),(0,i.jsx)(n.td,{children:"94.82s"}),(0,i.jsx)(n.td,{children:"789.24s"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Third (hot)"}),(0,i.jsx)(n.td,{children:"83.03s"}),(0,i.jsx)(n.td,{children:"92.29s"}),(0,i.jsx)(n.td,{children:"743.69s"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Are ",(0,i.jsx)(n.code,{children:"null"})," in VARIANT and SQL ",(0,i.jsx)(n.code,{children:"NULL"})," different?\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No. They are equivalent."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Why doesn\u2019t my query/index work?\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Check whether you CAST paths to the correct types; whether the type was promoted to JSONB due to conflicts; or whether you mistakenly expect an index on the whole VARIANT instead of on subpaths."}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},250065:function(e,n,s){s.d(n,{Z:function(){return l},a:function(){return d}});var t=s(667294);let i={},r=t.createContext(i);function d(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);