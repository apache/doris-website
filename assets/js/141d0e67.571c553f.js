"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["444897"],{741657:function(e,n,r){r.r(n),r.d(n,{default:()=>h,frontMatter:()=>d,metadata:()=>s,assets:()=>a,toc:()=>l,contentTitle:()=>o});var s=JSON.parse('{"id":"ecosystem/spark-doris-connector","title":"Spark Doris Connector","description":"Spark Doris Connector can support reading data stored in Doris and writing data to Doris through Spark.","source":"@site/versioned_docs/version-2.0/ecosystem/spark-doris-connector.md","sourceDirName":"ecosystem","slug":"/ecosystem/spark-doris-connector","permalink":"/docs/2.0/ecosystem/spark-doris-connector","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Spark Doris Connector","language":"en"},"sidebar":"docs","previous":{"title":"TPC-DS Benchmark","permalink":"/docs/2.0/benchmark/tpcds"},"next":{"title":"Flink Doris Connector","permalink":"/docs/2.0/ecosystem/flink-doris-connector"}}'),i=r("785893"),t=r("250065");let d={title:"Spark Doris Connector",language:"en"},o="Spark Doris Connector",a={},l=[{value:"Version Compatibility",id:"version-compatibility",level:2},{value:"How To Use",id:"how-to-use",level:2},{value:"Maven",id:"maven",level:3},{value:"Compile",id:"compile",level:3},{value:"Example",id:"example",level:2},{value:"Read",id:"read",level:3},{value:"SQL",id:"sql",level:4},{value:"DataFrame",id:"dataframe",level:4},{value:"RDD",id:"rdd",level:4},{value:"pySpark",id:"pyspark",level:4},{value:"Write",id:"write",level:3},{value:"SQL",id:"sql-1",level:4},{value:"DataFrame(batch/stream)",id:"dataframebatchstream",level:4},{value:"Configuration",id:"configuration",level:2},{value:"General",id:"general",level:3},{value:"SQL &amp; Dataframe Configuration",id:"sql--dataframe-configuration",level:3},{value:"Structured Streaming Configuration",id:"structured-streaming-configuration",level:3},{value:"RDD Configuration",id:"rdd-configuration",level:3},{value:"Doris &amp; Spark Column Type Mapping",id:"doris--spark-column-type-mapping",level:2},{value:"FAQ",id:"faq",level:2}];function c(e){let n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",sup:"sup",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"spark-doris-connector",children:"Spark Doris Connector"})}),"\n",(0,i.jsx)(n.p,{children:"Spark Doris Connector can support reading data stored in Doris and writing data to Doris through Spark."}),"\n",(0,i.jsxs)(n.p,{children:["Github: ",(0,i.jsx)(n.a,{href:"https://github.com/apache/doris-spark-connector",children:"https://github.com/apache/doris-spark-connector"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Support reading data from ",(0,i.jsx)(n.code,{children:"Doris"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Support ",(0,i.jsx)(n.code,{children:"Spark DataFrame"})," batch/stream writing data to ",(0,i.jsx)(n.code,{children:"Doris"})]}),"\n",(0,i.jsxs)(n.li,{children:["You can map the ",(0,i.jsx)(n.code,{children:"Doris"})," table to",(0,i.jsx)(n.code,{children:" DataFrame"})," or ",(0,i.jsx)(n.code,{children:"RDD"}),", it is recommended to use",(0,i.jsx)(n.code,{children:" DataFrame"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Support the completion of data filtering on the ",(0,i.jsx)(n.code,{children:"Doris"})," side to reduce the amount of data transmission."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"version-compatibility",children:"Version Compatibility"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Connector"}),(0,i.jsx)(n.th,{children:"Spark"}),(0,i.jsx)(n.th,{children:"Doris"}),(0,i.jsx)(n.th,{children:"Java"}),(0,i.jsx)(n.th,{children:"Scala"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1.3.2"}),(0,i.jsx)(n.td,{children:"3.4 ~ 3.1, 2.4, 2.3"}),(0,i.jsx)(n.td,{children:"1.0 +"}),(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:"2.12, 2.11"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1.2.0"}),(0,i.jsx)(n.td,{children:"3.2, 3.1, 2.3"}),(0,i.jsx)(n.td,{children:"1.0 +"}),(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:"2.12, 2.11"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1.1.0"}),(0,i.jsx)(n.td,{children:"3.2, 3.1, 2.3"}),(0,i.jsx)(n.td,{children:"1.0 +"}),(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:"2.12, 2.11"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1.0.1"}),(0,i.jsx)(n.td,{children:"3.1, 2.3"}),(0,i.jsx)(n.td,{children:"0.12 - 0.15"}),(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:"2.12, 2.11"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"how-to-use",children:"How To Use"}),"\n",(0,i.jsx)(n.h3,{id:"maven",children:"Maven"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"<dependency>\n    <groupId>org.apache.doris</groupId>\n    <artifactId>spark-doris-connector-3.4_2.12</artifactId>\n    <version>1.3.2</version>\n</dependency>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Note"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Please replace the corresponding Connector version according to different Spark and Scala versions."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["You can also download the relevant version jar package from ",(0,i.jsx)(n.a,{href:"https://repo.maven.apache.org/maven2/org/apache/doris/",children:"here"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"compile",children:"Compile"}),"\n",(0,i.jsxs)(n.p,{children:["When compiling, you can directly run ",(0,i.jsx)(n.code,{children:"sh build.sh"}),", for details, please refer to here."]}),"\n",(0,i.jsxs)(n.p,{children:["After successful compilation, the target jar package will be generated in the ",(0,i.jsx)(n.code,{children:"dist"})," directory, such as: spark-doris-connector-3.2_2.12-1.2.0-SNAPSHOT.jar. Copy this file to the ",(0,i.jsx)(n.code,{children:"ClassPath"})," of ",(0,i.jsx)(n.code,{children:"Spark"})," to use ",(0,i.jsx)(n.code,{children:"Spark-Doris-Connector"}),". For example, for ",(0,i.jsx)(n.code,{children:"Spark"})," running in ",(0,i.jsx)(n.code,{children:"Local"})," mode, put this file in the ",(0,i.jsx)(n.code,{children:"jars/"})," folder. For ",(0,i.jsx)(n.code,{children:"Spark"})," running in ",(0,i.jsx)(n.code,{children:"Yarn"})," cluster mode, put this file in the pre-deployment package.\nYou can also"]}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Execute in the source code directory:"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"sh build.sh"}),"\nEnter the Scala and Spark versions you need to compile according to the prompts."]}),"\n",(0,i.jsxs)(n.p,{children:["After successful compilation, the target jar package will be generated in the ",(0,i.jsx)(n.code,{children:"dist"})," directory, such as: ",(0,i.jsx)(n.code,{children:"spark-doris-connector-3.2_2.12-1.2.0-SNAPSHOT.jar"}),".\nCopy this file to the ",(0,i.jsx)(n.code,{children:"ClassPath"})," of ",(0,i.jsx)(n.code,{children:"Spark"})," to use ",(0,i.jsx)(n.code,{children:"Spark-Doris-Connector"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, if ",(0,i.jsx)(n.code,{children:"Spark"})," is running in ",(0,i.jsx)(n.code,{children:"Local"})," mode, put this file in the ",(0,i.jsx)(n.code,{children:"jars/"})," folder. If ",(0,i.jsx)(n.code,{children:"Spark"})," is running in ",(0,i.jsx)(n.code,{children:"Yarn"})," cluster mode, put this file in the pre-deployment package."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, upload ",(0,i.jsx)(n.code,{children:"spark-doris-connector-3.2_2.12-1.2.0-SNAPSHOT.jar"})," to hdfs and add the Jar package path on hdfs to the ",(0,i.jsx)(n.code,{children:"spark.yarn.jars"})," parameter"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"1. Upload `spark-doris-connector-3.2_2.12-1.2.0-SNAPSHOT.jar` to hdfs.\n\nhdfs dfs -mkdir /spark-jars/\nhdfs dfs -put /your_local_path/spark-doris-connector-3.2_2.12-1.2.0-SNAPSHOT.jar /spark-jars/\n\n2. Add the `spark-doris-connector-3.2_2.12-1.2.0-SNAPSHOT.jar` dependency in the cluster.\nspark.yarn.jars=hdfs:///spark-jars/spark-doris-connector-3.2_2.12-1.2.0-SNAPSHOT.jar\n\n"})}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.h3,{id:"read",children:"Read"}),"\n",(0,i.jsx)(n.h4,{id:"sql",children:"SQL"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE\nTEMPORARY VIEW spark_doris\nUSING doris\nOPTIONS(\n  "table.identifier"="$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME",\n  "fenodes"="$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT",\n  "user"="$YOUR_DORIS_USERNAME",\n  "password"="$YOUR_DORIS_PASSWORD"\n);\n\nSELECT *\nFROM spark_doris;\n'})}),"\n",(0,i.jsx)(n.h4,{id:"dataframe",children:"DataFrame"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'val dorisSparkDF = spark.read.format("doris")\n  .option("doris.table.identifier", "$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME")\n  .option("doris.fenodes", "$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT")\n  .option("user", "$YOUR_DORIS_USERNAME")\n  .option("password", "$YOUR_DORIS_PASSWORD")\n  .load()\n\ndorisSparkDF.show(5)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"rdd",children:"RDD"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import org.apache.doris.spark._\n\nval dorisSparkRDD = sc.dorisRDD(\n  tableIdentifier = Some("$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME"),\n  cfg = Some(Map(\n    "doris.fenodes" -> "$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT",\n    "doris.request.auth.user" -> "$YOUR_DORIS_USERNAME",\n    "doris.request.auth.password" -> "$YOUR_DORIS_PASSWORD"\n  ))\n)\n\ndorisSparkRDD.collect()\n'})}),"\n",(0,i.jsx)(n.h4,{id:"pyspark",children:"pySpark"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'dorisSparkDF = spark.read.format("doris")\n  .option("doris.table.identifier", "$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME")\n  .option("doris.fenodes", "$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT")\n  .option("user", "$YOUR_DORIS_USERNAME")\n  .option("password", "$YOUR_DORIS_PASSWORD")\n  .load()\n// show 5 lines data \ndorisSparkDF.show(5)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"write",children:"Write"}),"\n",(0,i.jsx)(n.h4,{id:"sql-1",children:"SQL"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE\nTEMPORARY VIEW spark_doris\nUSING doris\nOPTIONS(\n  "table.identifier"="$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME",\n  "fenodes"="$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT",\n  "user"="$YOUR_DORIS_USERNAME",\n  "password"="$YOUR_DORIS_PASSWORD"\n);\n\nINSERT INTO spark_doris\nVALUES ("VALUE1", "VALUE2", ...);\n# or\nINSERT INTO spark_doris\nSELECT *\nFROM YOUR_TABLE\n# or\nINSERT OVERWRITE \nSELECT *\nFROM YOUR_TABLE \n'})}),"\n",(0,i.jsx)(n.h4,{id:"dataframebatchstream",children:"DataFrame(batch/stream)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// batch sink\nval mockDataDF = List(\n  (3, "440403001005", "21.cn"),\n  (1, "4404030013005", "22.cn"),\n  (33, null, "23.cn")\n).toDF("id", "mi_code", "mi_name")\nmockDataDF.show(5)\n\nmockDataDF.write.format("doris")\n  .option("doris.table.identifier", "$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME")\n  .option("doris.fenodes", "$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT")\n  .option("user", "$YOUR_DORIS_USERNAME")\n  .option("password", "$YOUR_DORIS_PASSWORD")\n  //other options\n  //specify the fields to write\n  .option("doris.write.fields", "$YOUR_FIELDS_TO_WRITE")\n  // Support setting Overwrite mode to overwrite data\n  // .option("save_mode", SaveMode.Overwrite)\n  .save()\n\n// stream sink(StructuredStreaming)\n\n// Result DataFrame with structured data, the configuration method is the same as the batch mode.\nval sourceDf = spark.readStream.\n       .format("your_own_stream_source")\n       .load()\n\nval resultDf = sourceDf.<transformations>\n\nresultDf.writeStream\n      .format("doris")\n      .option("checkpointLocation", "$YOUR_CHECKPOINT_LOCATION")\n      .option("doris.table.identifier", "$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME")\n      .option("doris.fenodes", "$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT")\n      .option("user", "$YOUR_DORIS_USERNAME")\n      .option("password", "$YOUR_DORIS_PASSWORD")\n      .start()\n      .awaitTermination()\n\n// There is a column value in the Result DataFrame that can be written directly, such as the value in the kafka message that conforms to the import format\n\nval kafkaSource = spark.readStream\n  .format("kafka")\n  .option("kafka.bootstrap.servers", "$YOUR_KAFKA_SERVERS")\n  .option("startingOffsets", "latest")\n  .option("subscribe", "$YOUR_KAFKA_TOPICS")\n  .load()\nkafkaSource.selectExpr("CAST(key AS STRING)", "CAST(value as STRING)")\n  .writeStream\n  .format("doris")\n  .option("checkpointLocation", "$YOUR_CHECKPOINT_LOCATION")\n  .option("doris.table.identifier", "$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME")\n  .option("doris.fenodes", "$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT")\n  .option("user", "$YOUR_DORIS_USERNAME")\n  .option("password", "$YOUR_DORIS_PASSWORD")\n  // Set this option to true, and the value column in the Kafka message will be written directly without processing.\n  .option("doris.sink.streaming.passthrough", "true")\n  .option("doris.sink.properties.format", "json")\n  //other options\n  .start()\n  .awaitTermination()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"general",children:"General"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Key"}),(0,i.jsx)(n.th,{children:"Default Value"}),(0,i.jsx)(n.th,{children:"Comment"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.fenodes"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"Doris FE http address, support multiple addresses, separated by commas"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.table.identifier"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"Doris table identifier, eg, db1.tbl1"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.request.retries"}),(0,i.jsx)(n.td,{children:"3"}),(0,i.jsx)(n.td,{children:"Number of retries to send requests to Doris"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.request.connect.timeout.ms"}),(0,i.jsx)(n.td,{children:"30000"}),(0,i.jsx)(n.td,{children:"Connection timeout for sending requests to Doris"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.request.read.timeout.ms"}),(0,i.jsx)(n.td,{children:"30000"}),(0,i.jsx)(n.td,{children:"Read timeout for sending request to Doris"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.request.query.timeout.s"}),(0,i.jsx)(n.td,{children:"3600"}),(0,i.jsx)(n.td,{children:"Query the timeout time of doris, the default is 1 hour, -1 means no timeout limit"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.request.tablet.size"}),(0,i.jsx)(n.td,{children:"Integer.MAX_VALUE"}),(0,i.jsx)(n.td,{children:"The number of Doris Tablets corresponding to an RDD Partition. The smaller this value is set, the more partitions will be generated. This will increase the parallelism on the Spark side, but at the same time will cause greater pressure on Doris."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.read.field"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"List of column names in the Doris table, separated by commas"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.batch.size"}),(0,i.jsx)(n.td,{children:"4064"}),(0,i.jsx)(n.td,{children:"The maximum number of rows to read data from BE at one time. Increasing this value can reduce the number of connections between Spark and Doris. Thereby reducing the extra time overhead caused by network delay."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.exec.mem.limit"}),(0,i.jsx)(n.td,{children:"2147483648"}),(0,i.jsx)(n.td,{children:"Memory limit for a single query. The default is 2GB, in bytes."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.deserialize.arrow.async"}),(0,i.jsx)(n.td,{children:"false"}),(0,i.jsx)(n.td,{children:"Whether to support asynchronous conversion of Arrow format to RowBatch required for spark-doris-connector iteration"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.deserialize.queue.size"}),(0,i.jsx)(n.td,{children:"64"}),(0,i.jsx)(n.td,{children:"Asynchronous conversion of the internal processing queue in Arrow format takes effect when doris.deserialize.arrow.async is true"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.write.fields"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsxs)(n.td,{children:["Specifies the fields (or the order of the fields) to write to the Doris table, fileds separated by commas.",(0,i.jsx)(n.br,{}),"By default, all fields are written in the order of Doris table fields."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.batch.size"}),(0,i.jsx)(n.td,{children:"100000"}),(0,i.jsx)(n.td,{children:"Maximum number of lines in a single write BE"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.max-retries"}),(0,i.jsx)(n.td,{children:"0"}),(0,i.jsxs)(n.td,{children:["Number of retries after writing BE, Since version 1.3.0, the default value is 0, which means no retries are performed by default. When this parameter is set greater than 0, batch-level failure retries will be performed, and data of the configured size of ",(0,i.jsx)(n.code,{children:"doris.sink.batch.size"})," will be cached in the Spark Executor memory. The memory allocation may need to be appropriately increased."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.properties.format"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsxs)(n.td,{children:["Data format of the stream load.",(0,i.jsx)(n.br,{}),"Supported formats: csv, json, arrow ",(0,i.jsx)(n.br,{})," ",(0,i.jsx)(n.a,{href:"../data-operate/import/import-way/stream-load-manual",children:"More Multi-parameter details"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.properties.*"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsxs)(n.td,{children:["Import parameters for Stream Load. ",(0,i.jsx)(n.br,{}),"For example:",(0,i.jsx)(n.br,{}),"Specify column separator: ",(0,i.jsx)(n.code,{children:"'doris.sink.properties.column_separator' = ','"}),".",(0,i.jsx)(n.br,{}),(0,i.jsx)(n.a,{href:"../data-operate/import/import-way/stream-load-manual",children:"More parameter details"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.task.partition.size"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"The number of partitions corresponding to the Writing task. After filtering and other operations, the number of partitions written in Spark RDD may be large, but the number of records corresponding to each Partition is relatively small, resulting in increased writing frequency and waste of computing resources. The smaller this value is set, the less Doris write frequency and less Doris merge pressure. It is generally used with doris.sink.task.use.repartition."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.task.use.repartition"}),(0,i.jsx)(n.td,{children:"false"}),(0,i.jsx)(n.td,{children:"Whether to use repartition mode to control the number of partitions written by Doris. The default value is false, and coalesce is used (note: if there is no Spark action before the write, the whole computation will be less parallel). If it is set to true, then repartition is used (note: you can set the final number of partitions at the cost of shuffle)."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.batch.interval.ms"}),(0,i.jsx)(n.td,{children:"50"}),(0,i.jsx)(n.td,{children:"The interval time of each batch sink, unit ms."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.enable-2pc"}),(0,i.jsx)(n.td,{children:"false"}),(0,i.jsx)(n.td,{children:"Whether to enable two-stage commit. When enabled, transactions will be committed at the end of the job, and all pre-commit transactions will be rolled back when some tasks fail."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.auto-redirect"}),(0,i.jsx)(n.td,{children:"true"}),(0,i.jsx)(n.td,{children:"Whether to redirect StreamLoad requests. After being turned on, StreamLoad will write through FE and no longer obtain BE information explicitly."})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"sql--dataframe-configuration",children:"SQL & Dataframe Configuration"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Key"}),(0,i.jsx)(n.th,{children:"Default Value"}),(0,i.jsx)(n.th,{children:"Comment"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"user"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"Doris username"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"password"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"Doris password"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.filter.query.in.max.count"}),(0,i.jsx)(n.td,{children:"100"}),(0,i.jsx)(n.td,{children:"In the predicate pushdown, the maximum number of elements in the in expression value list. If this number is exceeded, the in-expression conditional filtering is processed on the Spark side."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.ignore-type"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsxs)(n.td,{children:["In a temporary view, specify the field types to ignore when reading the schema. ",(0,i.jsx)(n.br,{})," eg: when 'doris.ignore-type'='bitmap,hll'"]})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"structured-streaming-configuration",children:"Structured Streaming Configuration"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Key"}),(0,i.jsx)(n.th,{children:"Default Value"}),(0,i.jsx)(n.th,{children:"Comment"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.sink.streaming.passthrough"}),(0,i.jsx)(n.td,{children:"false"}),(0,i.jsx)(n.td,{children:"Write the value of the first column directly without processing."})]})})]}),"\n",(0,i.jsx)(n.h3,{id:"rdd-configuration",children:"RDD Configuration"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Key"}),(0,i.jsx)(n.th,{children:"Default Value"}),(0,i.jsx)(n.th,{children:"Comment"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.request.auth.user"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"Doris username"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.request.auth.password"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"Doris password"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"doris.filter.query"}),(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"Filter expression of the query, which is transparently transmitted to Doris. Doris uses this expression to complete source-side data filtering."})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"doris--spark-column-type-mapping",children:"Doris & Spark Column Type Mapping"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Doris Type"}),(0,i.jsx)(n.th,{children:"Spark Type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"NULL_TYPE"}),(0,i.jsx)(n.td,{children:"DataTypes.NullType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BOOLEAN"}),(0,i.jsx)(n.td,{children:"DataTypes.BooleanType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TINYINT"}),(0,i.jsx)(n.td,{children:"DataTypes.ByteType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SMALLINT"}),(0,i.jsx)(n.td,{children:"DataTypes.ShortType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"INT"}),(0,i.jsx)(n.td,{children:"DataTypes.IntegerType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BIGINT"}),(0,i.jsx)(n.td,{children:"DataTypes.LongType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"FLOAT"}),(0,i.jsx)(n.td,{children:"DataTypes.FloatType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DOUBLE"}),(0,i.jsx)(n.td,{children:"DataTypes.DoubleType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DATE"}),(0,i.jsx)(n.td,{children:"DataTypes.DateType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DATETIME"}),(0,i.jsxs)(n.td,{children:["DataTypes.StringType",(0,i.jsx)(n.sup,{children:"1"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DECIMAL"}),(0,i.jsx)(n.td,{children:"DecimalType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"CHAR"}),(0,i.jsx)(n.td,{children:"DataTypes.StringType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"LARGEINT"}),(0,i.jsx)(n.td,{children:"DecimalType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"VARCHAR"}),(0,i.jsx)(n.td,{children:"DataTypes.StringType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TIME"}),(0,i.jsx)(n.td,{children:"DataTypes.DoubleType"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"HLL"}),(0,i.jsx)(n.td,{children:"Unsupported datatype"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Bitmap"}),(0,i.jsx)(n.td,{children:"Unsupported datatype"})]})]})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Note: In Connector, ",(0,i.jsx)(n.code,{children:" DATETIME"})," is mapped to ",(0,i.jsx)(n.code,{children:"String"}),". Due to the processing logic of the Doris underlying storage engine, when the time type is used directly, the time range covered cannot meet the demand. So use ",(0,i.jsx)(n.code,{children:"String"})," type to directly return the corresponding time readable text."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"How to write Bitmap type"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In Spark SQL, when writing data through insert into, if the target table of doris contains data of type ",(0,i.jsx)(n.code,{children:"BITMAP"})," or ",(0,i.jsx)(n.code,{children:"HLL"}),", you need to set the parameter ",(0,i.jsx)(n.code,{children:"doris.ignore-type"})," to the corresponding type and map the columns through ",(0,i.jsx)(n.code,{children:"doris.write.fields"}),". The usage is as follows:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"BITMAP"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE TEMPORARY VIEW spark_doris\nUSING doris\nOPTIONS(\n"table.identifier"="$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME",\n"fenodes"="$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT",\n"user"="$YOUR_DORIS_USERNAME",\n"password"="$YOUR_DORIS_PASSWORD"\n"doris.ignore-type"="bitmap",\n"doris.write.fields"="col1,col2,col3,bitmap_col2=to_bitmap(col2),bitmap_col3=bitmap_hash(col3)"\n);\n'})}),"\n",(0,i.jsx)(n.p,{children:"HLL"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE TEMPORARY VIEW spark_doris\nUSING doris\nOPTIONS(\n"table.identifier"="$YOUR_DORIS_DATABASE_NAME.$YOUR_DORIS_TABLE_NAME",\n"fenodes"="$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT",\n"user"="$YOUR_DORIS_USERNAME",\n"password"="$YOUR_DORIS_PASSWORD"\n"doris.ignore-type"="hll",\n"doris.write.fields"="col1,hll_col1=hll_hash(col1)"\n);\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"How to use overwrite to write?"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Starting from version 1.3.0, overwrite mode writing is supported (only supports data overwriting at the full table level). The specific usage is as follows:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"DataFrame"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'resultDf.format("doris")\n  .option("doris.fenodes","$YOUR_DORIS_FE_HOSTNAME:$YOUR_DORIS_FE_RESFUL_PORT")\n  // your own options\n  .option("save_mode", SaveMode.Overwrite)\n  .save()\n'})}),"\n",(0,i.jsx)(n.p,{children:"SQL"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"INSERT OVERWRITE your_target_table\nSELECT * FROM your_source_table\n"})}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},250065:function(e,n,r){r.d(n,{Z:function(){return o},a:function(){return d}});var s=r(667294);let i={},t=s.createContext(i);function d(e){let n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);