"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["466864"],{132675:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>a,metadata:()=>i,assets:()=>o,toc:()=>d,contentTitle:()=>r});var i=JSON.parse('{"id":"sql-manual/sql-statements/table-and-view/table/CREATE-TABLE","title":"CREATE TABLE","description":"Description","source":"@site/versioned_docs/version-3.x/sql-manual/sql-statements/table-and-view/table/CREATE-TABLE.md","sourceDirName":"sql-manual/sql-statements/table-and-view/table","slug":"/sql-manual/sql-statements/table-and-view/table/CREATE-TABLE","permalink":"/docs/3.x/sql-manual/sql-statements/table-and-view/table/CREATE-TABLE","draft":false,"unlisted":false,"tags":[],"version":"3.x","frontMatter":{"title":"CREATE TABLE","language":"en","toc_min_heading_level":2,"toc_max_heading_level":4},"sidebar":"docs","previous":{"title":"SHOW DATABASE ID","permalink":"/docs/3.x/sql-manual/sql-statements/database/SHOW-DATABASE-ID"},"next":{"title":"DESCRIBE","permalink":"/docs/3.x/sql-manual/sql-statements/table-and-view/table/DESC-TABLE"}}'),l=t("785893"),s=t("250065");let a={title:"CREATE TABLE",language:"en",toc_min_heading_level:2,toc_max_heading_level:4},r=void 0,o={},d=[{value:"Description",id:"description",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Varaint Syntax",id:"varaint-syntax",level:2},{value:"CREATE TABLE ... AS SELECT (Also Referred to as CTAS)",id:"create-table--as-select-also-referred-to-as-ctas",level:3},{value:"CREATE TABLE ... LIKE",id:"create-table--like",level:3},{value:"Required Parameters",id:"required-parameters",level:2},{value:"Optional Parameters",id:"optional-parameters",level:2},{value:"Data Model Related Parameters",id:"data-model-related-parameters",level:3},{value:"Bucketing Related Parameters",id:"bucketing-related-parameters",level:3},{value:"Column Default Value Related Parameters",id:"column-default-value-related-parameters",level:3},{value:"Index Related Parameters",id:"index-related-parameters",level:3},{value:"Auto Partition Related Parameters",id:"auto-partition-related-parameters",level:3},{value:"Manual Partitioning Related Parameters",id:"manual-partitioning-related-parameters",level:3},{value:"Synchronized Materialized View Related",id:"synchronized-materialized-view-related",level:3},{value:"Table Property Related Parameters",id:"table-property-related-parameters",level:3},{value:"Access Control Requirements",id:"access-control-requirements",level:2},{value:"Usage Notes",id:"usage-notes",level:2},{value:"Examples",id:"examples",level:2},{value:"Basic Examples",id:"basic-examples",level:3},{value:"CTAS Example",id:"ctas-example",level:3},{value:"CREATE TABLE ... LIKE Example",id:"create-table--like-example",level:3}];function c(e){let n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",defaultvalueprecision:"defaultvalueprecision",h2:"h2",h3:"h3",li:"li",n:"n",name:"name",ol:"ol",p:"p",pre:"pre",query:"query",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,l.jsx)(n.p,{children:"Create a new table in the current or specified database. A table can have multiple columns, and each column definition includes the name, data type, and optionally the following attributes:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Whether it is a key"}),"\n",(0,l.jsx)(n.li,{children:"Whether it has aggregation semantics"}),"\n",(0,l.jsx)(n.li,{children:"Whether it is a generated column"}),"\n",(0,l.jsx)(n.li,{children:"Whether it requires a value (NOT NULL)"}),"\n",(0,l.jsx)(n.li,{children:"Whether it is an auto-increment column"}),"\n",(0,l.jsx)(n.li,{children:"Whether there is a default value upon insertion"}),"\n",(0,l.jsx)(n.li,{children:"Whether there is a default value upon update"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Furthermore, this command also supports the following variations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"CREATE TABLE \u2026 AS SELECT (to create a table pre-populated with data; also known as CTAS)"}),"\n",(0,l.jsx)(n.li,{children:"CREATE TABLE \u2026 LIKE (to create an empty copy of an existing table)"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE [ EXTERNAL ] TABLE [ IF NOT EXISTS ] <table_name>\n    (<columns_definition> [ <indexes_definition> ])\n    [ ENGINE = <table_engine_type> ]\n    [ <key_type> KEY (<key_cols>)\n        [ CLUSTER BY (<cluster_cols>) ]\n    ]\n    [ COMMENT '<table_comment>' ]\n    [ <partitions_definition> ]\n    [ DISTRIBUTED BY { HASH (<distribute_cols>) | RANDOM }\n        [ BUCKETS { <bucket_count> | AUTO } ]\n    ]\n    [ <roll_up_definition> ]\n    [ PROPERTIES (\n          -- Table property\n          <table_property>\n          -- Additional table properties\n          [ , ... ]) \n    ]\n"})}),"\n",(0,l.jsx)(n.p,{children:"Where:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"columns_definition\n  : -- Column definition\n    <col_name> <col_type>\n      [ KEY ]\n      [ <col_aggregate_type> ]\n      [ [ GENERATED ALWAYS ] AS (<col_generate_expression>) ]\n      [ [NOT] NULL ]\n      [ AUTO_INCREMENT(<col_auto_increment_start_value>) ]\n      [ DEFAULT <col_default_value> ]\n      [ ON UPDATE CURRENT_TIMESTAMP (<col_on_update_precision>) ]\n      [ COMMENT '<col_comment>' ]\n    -- Additional column definitions\n    [ , <col_name> <col_type> [ ... ] ]\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"indexes_definition\n  : -- Index definition\n    INDEX [ IF NOT EXISTS ]\n      <index_name> (<index_cols>)\n      [ USING <index_type> ]\n      [ PROPERTIES (\n            -- Table property\n            <index_property>\n            -- Additional table properties\n            [ , ... ]) \n      ]\n      [ COMMENT '<index_comment>' ]\n    -- Additional index definitions\n    [ , <index_name> (<index_cols>) [ ... ] ]\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"partitions_definition\n  : AUTO PARTITION BY RANGE(<auto_partition_function>(<auto_partition_arguments>))\n    <origin_partitions_definition>\n  | AUTO PARTITION BY LIST(<partition_cols>)\n    <origin_partitions_definition>\n  | PARTITION BY <partition_type> (<partition_cols>)\n    <origin_partitions_definition>\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"\u5176\u4E2D\uFF1A"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"<origin_partitions_definition>\n: (\n    -- Partition definition\n    <one_partition_definition>\n    -- Additional partition definition\n    [ , ... ]\n  )\n\n<one_partition_definition>\n: PARTITION [ IF NOT EXISTS ] <partition_name>\n    VALUES LESS THAN <partition_value_list>\n| PARTITION [ IF NOT EXISTS ] <partition_name>\n    VALUES [ <partition_lower_bound>, <partition_upper_bound>)\n| FROM <partition_lower_bound> TO <partition_upper_bound>\n    INTERVAL <n> [ <datetime_unit> ]\n| PARTITION [ IF NOT EXISTS ] <partition_name>\n    VALUES IN {\n        (<partition_value> [, <partition_value> [ ... ] ])\n        | <partition_value>\n    }\n"})}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"roll_up_definition\n  : ROLLUP (\n        -- Rollup definition\n        <rollup_name> (<rollup_cols>)\n        [ DUPLICATE KEY (<duplicate_cols>) ]\n        -- Additional rollup definition\n        [ , <rollup_name> (<rollup_cols>) [ ... ] ]\n    )\n"})}),"\n",(0,l.jsx)(n.h2,{id:"varaint-syntax",children:"Varaint Syntax"}),"\n",(0,l.jsx)(n.h3,{id:"create-table--as-select-also-referred-to-as-ctas",children:"CREATE TABLE ... AS SELECT (Also Referred to as CTAS)"}),"\n",(0,l.jsxs)(n.p,{children:["Generates a table and populates it with data returned from the ",(0,l.jsx)(n.code,{children:"query"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE\n    [ EXTERNAL ]\n    TABLE [ IF NOT EXISTS ] <table_name>\n    [ ( <column_definitions> ) ]\n    [ <index_definitions> ]\n    [ ENGINE = <storage_engine_type> ]\n    [ <partitioning_key_type> KEY ( <key_columns> )\n        [ CLUSTER BY ( <clustering_columns> ) ]\n    ]\n    [ COMMENT '<table_description>' ]\n    [ <partition_definitions> ]\n    [ DISTRIBUTED BY { HASH ( <distribution_columns> ) | RANDOM }\n        [ BUCKETS { <number_of_buckets> | AUTO } ]\n    ]\n    [ <rollup_definitions> ]\n    [ PROPERTIES (\n          \"<table_properties>\"\n          [ , ... ] \n    ) ]\nAS <query>;\n"})}),"\n",(0,l.jsx)(n.h3,{id:"create-table--like",children:"CREATE TABLE ... LIKE"}),"\n",(0,l.jsxs)(n.p,{children:["Creates a new table with the same column definitions as an existing table, without copying data from the existing table. All properties of the columns will be replicated in the new table. If a list of ",(0,l.jsx)(n.code,{children:"rollup"})," names is specified, the corresponding ",(0,l.jsx)(n.code,{children:"rollup"})," from the original table will also be replicated:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE <new_table_name> LIKE <existing_table_name>\n[ WITH ROLLUP ( <rollup_list> ) ];\n"})}),"\n",(0,l.jsx)(n.h2,{id:"required-parameters",children:"Required Parameters"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.name,{})})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Specifies the identifier (i.e., name) of the table; it must be unique within the database where the table is created."}),"\n",(0,l.jsxs)(n.p,{children:["The identifier must start with a letter (any language character if Unicode name support is enabled) and cannot contain spaces or special characters unless the entire identifier string is enclosed in backticks (e.g., ",(0,l.jsx)(n.code,{children:"My Object"}),")."]}),"\n",(0,l.jsx)(n.p,{children:"Identifiers cannot use reserved keywords."}),"\n",(0,l.jsxs)(n.p,{children:["For more details, see ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/object-identifiers",children:"Identifier Requirements"})," and ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/reserved-keywords",children:"Reserved Keywords"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<col_name>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Specifies the column identifier (i.e., name). It must be unique within the created table."}),"\n",(0,l.jsxs)(n.p,{children:["The identifier must start with a letter (any language character if Unicode name support is enabled), a digit, or the symbol ",(0,l.jsx)(n.code,{children:"@"}),", and cannot contain spaces or special characters unless the entire identifier string is enclosed in backticks (e.g., ",(0,l.jsx)(n.code,{children:"My Object"}),")."]}),"\n",(0,l.jsxs)(n.p,{children:["For more details, see ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/object-identifiers",children:"Identifier Requirements"})," and ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/reserved-keywords",children:"Reserved Keywords"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<col_type>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"Specifies the data type of the column."}),"\n",(0,l.jsxs)(n.p,{children:["For details on the data types that can be specified for table columns, see the ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/sql-data-types/data-type-overview",children:"Data Types"})," section."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.query,{})})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"A required parameter in CTAS. Specifies the SELECT statement that populates the data."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<source_table>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"A required parameter in CREATE TABLE ... LIKE. Specifies the original table to be copied."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"optional-parameters",children:"Optional Parameters"}),"\n",(0,l.jsx)(n.h3,{id:"data-model-related-parameters",children:"Data Model Related Parameters"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<key_type>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["The data model of the table. Optional values are DUPLICATE (detail model), UNIQUE (primary key model), AGGREGATE (aggregation model). For details on data models, see the ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/data-model/overview",children:"Data Model"})," section."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<key_cols>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["The key columns of the table. In Doris, Key columns must be the first K columns of the table. Data in a single tablet will be kept in order by these columns. For restrictions on Keys and how to choose Key columns, see the various subsections in the ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/data-model/overview",children:"Data Model"})," section."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<cluster_cols>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Data local sort columns, can only be used when the data model is UNIQUE (primary key model). When ",(0,l.jsx)(n.code,{children:"<cluster_cols>"})," is specified, data is sorted by ",(0,l.jsx)(n.code,{children:"<cluster_cols>"})," instead of using ",(0,l.jsx)(n.code,{children:"<key_cols>"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<col_aggregate_type>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["The aggregation method of the column. Can only be used when the table is an aggregation model. For details on aggregation methods, see the ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/data-model/aggregate",children:"Aggregation Model"})," section."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"bucketing-related-parameters",children:"Bucketing Related Parameters"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<distribute_cols> and <bucket_count>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Bucketing columns and bucket counts. Detail model bucket columns can be any columns, aggregation model and primary key model bucket columns must be consistent with key columns. Bucket count is any positive integer. For details on bucketing, see the ",(0,l.jsx)(n.a,{href:"../../../../table-design/data-partitioning/data-bucketing#manual-setting-bucket-count",children:"Manual Bucketing"})," and ",(0,l.jsx)(n.a,{href:"../../../../table-design/data-partitioning/data-bucketing#automatic-setting-bucket-count",children:"Automatic Bucketing"})," sections."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"column-default-value-related-parameters",children:"Column Default Value Related Parameters"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"[ GENERATED ALWAYS ] AS (<col_generate_expression>)"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Generated column. Uses the columns before the current column to generate data for the current column through the expression ",(0,l.jsx)(n.code,{children:"<col_generate_expression>"}),". A generated column is a special type of database table column whose value is calculated from the values of other columns, rather than being directly inserted or updated by the user. This feature supports pre-calculating the results of expressions and storing them in the database, suitable for scenarios that require frequent querying or complex calculations."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"AUTO_INCREMENT(<col_auto_increment_start_value>)"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["When importing data, Doris will assign a unique value within the table to rows of data in the auto-increment column that do not specify a value. ",(0,l.jsx)(n.code,{children:"<col_auto_increment_start_value>"})," specifies the starting value for the auto-increment column. For more details on auto-increment columns, see the ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/auto-increment",children:"Auto-Increment Columns"})," section."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"DEFAULT <col_default_value>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"The default value for the column. When writing without including this column, this default value is used. If the default value is not explicitly set, NULL is used. Available default values include:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"NULL: Available for all types, using NULL as the default value."}),"\n",(0,l.jsx)(n.li,{children:"Numeric literals: Can only be used for numeric types."}),"\n",(0,l.jsx)(n.li,{children:"String literals: Can only be used for string types."}),"\n",(0,l.jsx)(n.li,{children:"CURRENT_DATE: Can only be used for date types. Uses the current date as the default value."}),"\n",(0,l.jsxs)(n.li,{children:["CURRENT_TIMESTAMP [ ",(0,l.jsxs)(n.defaultvalueprecision,{children:[" ]: Can only be used for datetime types. Uses the current timestamp as the default value. ",(0,l.jsx)(n.code,{children:"<defaultValuePrecision>"})," can specify the time precision."]})]}),"\n",(0,l.jsx)(n.li,{children:"PI: Can only be used for double types. Uses pi as the default value."}),"\n",(0,l.jsx)(n.li,{children:"E: Can only be used for double types. Uses the mathematical constant e as the default value."}),"\n",(0,l.jsx)(n.li,{children:"BITMAP_EMPTY: Can only be used when the column is of bitmap type. Fills an empty bitmap."}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"ON UPDATE CURRENT_TIMESTAMP (<col_on_update_precision>)"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"When data is updated, if no value is specified for this column, the current timestamp is used to update the data in this column. Can only be used on tables with a UNIQUE (primary key model)."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"index-related-parameters",children:"Index Related Parameters"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<index_name>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Specifies the index identifier (i.e., name). It must be unique within the created table. For more details on identifiers, see ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/object-identifiers",children:"Identifier Requirements"})," and ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/reserved-keywords",children:"Reserved Keywords"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<index_cols>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"A list of columns to add an index to. Must be existing columns in the table."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<index_type>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"The type of index. Currently, only INVERTED is supported."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<index_property>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["The properties of the index. For detailed explanations, refer to the ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/index/inverted-index",children:"Inverted Index"})," section."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"auto-partition-related-parameters",children:"Auto Partition Related Parameters"}),"\n",(0,l.jsxs)(n.p,{children:["For a detailed introduction to partitioning, see the ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/data-partitioning/auto-partitioning",children:"Automatic Partitioning"})," section."]}),"\n",(0,l.jsx)(n.h3,{id:"manual-partitioning-related-parameters",children:"Manual Partitioning Related Parameters"}),"\n",(0,l.jsx)(n.p,{children:'For a detailed introduction to partitioning, see the "Manual Partitioning" section.'}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<partition_type>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["Doris supports RANGE partitioning and LIST partitioning. For details, see the ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/data-partitioning/manual-partitioning",children:"Manual Partitioning"})," section."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<partition_name>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["The partition identifier (i.e., name). It must be unique within the created table. For more details on identifiers, see ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/object-identifiers",children:"Identifier Requirements"})," and ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/reserved-keywords",children:"Reserved Keywords"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"VALUES LESS THAN <partition_value_list>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["RANGE partitioning. The partition data range is from the lower bound to ",(0,l.jsx)(n.code,{children:"<partition_value_list>"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["If it represents the upper bound, ",(0,l.jsx)(n.code,{children:"<partition_value_list>"})," can be simplified to ",(0,l.jsx)(n.code,{children:"MAX_VALUE"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["The format of ",(0,l.jsx)(n.code,{children:"<partition_value_list>"})," is as follows: ",(0,l.jsx)(n.code,{children:"((col_1_value, ...), (col_1_value, ...), ...)"})]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"VALUES [ <partition_lower_bound>, <partition_upper_bound>)"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["RANGE partitioning. The partition data range is from ",(0,l.jsx)(n.code,{children:"<partition_lower_bound>"})," to ",(0,l.jsx)(n.code,{children:"<partition_upper_bound>"}),". Only one partition is created."]}),"\n",(0,l.jsxs)(n.p,{children:["The format of ",(0,l.jsx)(n.code,{children:"<partition_lower_bound>"})," and ",(0,l.jsx)(n.code,{children:"<partition_upper_bound>"})," is as follows: ",(0,l.jsx)(n.code,{children:"(col_1_value, ...)"})]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"FROM <partition_lower_bound> TO <partition_upper_bound>"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsxs)(n.strong,{children:["INTERVAL ",(0,l.jsx)(n.n,{children:" [ <datetime_unit> ]"})]})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["RANGE partitioning. The partition data range is from ",(0,l.jsx)(n.code,{children:"<partition_lower_bound>"})," to ",(0,l.jsx)(n.code,{children:"<partition_value_list>"}),". A partition is created every ",(0,l.jsx)(n.code,{children:"<n>"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["The format of ",(0,l.jsx)(n.code,{children:"<partition_lower_bound>"})," and ",(0,l.jsx)(n.code,{children:"<partition_upper_bound>"})," is as follows: ",(0,l.jsx)(n.code,{children:"(col_1_value, ...)"})]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"VALUES IN {"})}),"\n",(0,l.jsxs)(n.p,{children:["\u200B          ",(0,l.jsx)(n.strong,{children:"(<partition_value> [, <partition_value> [ ... ] ])"})]}),"\n",(0,l.jsxs)(n.p,{children:["\u200B          ",(0,l.jsx)(n.strong,{children:"| <partition_value>"})]}),"\n",(0,l.jsxs)(n.p,{children:["\u200B      ",(0,l.jsx)(n.strong,{children:"}"})]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["LIST partitioning. Rows where the partition column equals ",(0,l.jsx)(n.code,{children:"<partition_value>"})," belong to this partition."]}),"\n",(0,l.jsxs)(n.p,{children:["The format of ",(0,l.jsx)(n.code,{children:"<partition_value>"})," is as follows: ",(0,l.jsx)(n.code,{children:"(col_1_value, ...)"})]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"synchronized-materialized-view-related",children:"Synchronized Materialized View Related"}),"\n",(0,l.jsx)(n.admonition,{title:"Note",type:"caution",children:(0,l.jsxs)(n.p,{children:["The functionality of creating synchronized materialized views with rollup is limited and no longer recommended. It is advised to use separate statements to create synchronized materialized views. For details, please refer to the ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/sql-statements/table-and-view/sync-materialized-view/CREATE-MATERIALIZED-VIEW",children:"CREATE MATERIALIZED VIEW"})," statement and the ",(0,l.jsx)(n.a,{href:"/docs/3.x/query-acceleration/materialized-view/sync-materialized-view",children:"Synchronized Materialized View"})," section."]})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<rollup_name>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["The identifier (i.e., name) of the synchronized materialized view. It must be unique within the created table. For more details on identifiers, see ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/object-identifiers",children:"Identifier Requirements"})," and ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/reserved-keywords",children:"Reserved Keywords"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<rollup_cols>"})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"The columns included in the synchronized materialized view."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"table-property-related-parameters",children:"Table Property Related Parameters"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"<table_property>"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Property Name"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Function"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"replication_num"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["The number of replicas. The default number of replicas is 3. If the number of BE nodes is less than 3, you must specify a number of replicas less than or equal to the number of BE nodes. After version 0.15, this property will automatically convert to the ",(0,l.jsx)(n.code,{children:"replication_allocation"})," property, e.g., ",(0,l.jsx)(n.code,{children:'"replication_num" = "3"'})," will automatically convert to ",(0,l.jsx)(n.code,{children:'"replication_allocation" = "tag.location.default:3"'}),"."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"replication_allocation"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Sets the distribution of replicas based on Tags. This property can completely override the functionality of the ",(0,l.jsx)(n.code,{children:"replication_num"})," property."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"min_load_replica_num"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Sets the minimum number of replicas required for a successful data import, with a default value of -1. When this property is less than or equal to 0, it indicates that the majority of replicas must still succeed for the data import."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"is_being_synced"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Used to identify whether this table is being replicated by CCR and is currently being synchronized by the syncer, with a default value of ",(0,l.jsx)(n.code,{children:"false"}),". If set to ",(0,l.jsx)(n.code,{children:"true"}),", the ",(0,l.jsx)(n.code,{children:"colocate_with"})," and ",(0,l.jsx)(n.code,{children:"storage_policy"})," properties will be cleared. The ",(0,l.jsx)(n.code,{children:"dynamic partition and"})," ",(0,l.jsx)(n.code,{children:"auto bucket"})," features will become ineffective. That is, they will appear enabled in ",(0,l.jsx)(n.code,{children:"show create table"})," but will not actually take effect. When ",(0,l.jsx)(n.code,{children:"is_being_synced"})," is set to ",(0,l.jsx)(n.code,{children:"false"}),", these features will resume. This property is for use only by the CCR peripheral module and should not be manually set during the CCR synchronization process."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"storage_medium"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Declares the initial storage medium for table data."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"storage_cooldown_time"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Sets the expiration time for the initial storage medium of the table data. After this time, it will automatically downgrade to the first-level storage medium."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"colocate_with"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"When the Colocation Join feature is needed, use this parameter to set the Colocation Group."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"bloom_filter_columns"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["A list of column names specified by the user that require the addition of a Bloom Filter index. Each column's Bloom Filter index is independent and not a composite index. For example: ",(0,l.jsx)(n.code,{children:'"bloom_filter_columns" = "k1, k2, k3"'})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"compression"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"The default compression method for Doris tables is LZ4. After version 1.1, support for specifying ZSTD as the compression method is available for higher compression ratios."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"function_column.sequence_col"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["When using the Unique Key model, you can specify a Sequence column. When Key columns are the same, REPLACE will be performed according to the Sequence column (the larger value replaces the smaller value; otherwise, it cannot be replaced). ",(0,l.jsx)(n.code,{children:"function_column.sequence_col"})," is used to map the sequence column to a specific column in the table, which can be of integer or date/time types (DATE, DATETIME). The type of this column cannot be changed after creation. If ",(0,l.jsx)(n.code,{children:"function_column.sequence_col"})," is set, ",(0,l.jsx)(n.code,{children:"function_column.sequence_type"})," will be ignored."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"function_column.sequence_type"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"When using the Unique Key model, you can specify a Sequence column. When Key columns are the same, REPLACE will be performed according to the Sequence column (the larger value replaces the smaller value; otherwise, it cannot be replaced). Here, you only need to specify the type of the sequence column, which supports date/time types or integers. Doris will create a hidden sequence column."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"enable_unique_key_merge_on_write"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Whether the Unique table uses the Merge-on-Write implementation. This property was default disabled before version 2.1 and default enabled from version 2.1 onwards."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"light_schema_change"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Whether to use the Light Schema Change optimization. If set to ",(0,l.jsx)(n.code,{children:"true"}),", addition and subtraction operations on value columns can be completed faster and synchronously. This feature is enabled by default in versions 2.0.0 and later."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"disable_auto_compaction"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Whether to disable automatic compaction for this table. If this property is set to ",(0,l.jsx)(n.code,{children:"true"}),", the background automatic compaction process will skip all tablets of this table."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"enable_single_replica_compaction"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Whether to enable single-replica compaction for this table. If this property is set to ",(0,l.jsx)(n.code,{children:"true"}),", only one replica of all replicas of the table's tablets will perform the actual compaction action, and other replicas will pull the compacted rowset from that replica."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"enable_duplicate_without_keys_by_default"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["When set to ",(0,l.jsx)(n.code,{children:"true"}),", if no Unique, Aggregate, or Duplicate is specified when creating a table, a Duplicate model table without sort columns and prefix indexes will be created by default."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"skip_write_index_on_load"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Whether to enable not writing indexes during data import for this table. If this property is set to ",(0,l.jsx)(n.code,{children:"true"}),", indexes will not be written during data import (currently only effective for inverted indexes), but will be delayed until compaction. This can avoid the CPU and IO resource consumption of writing indexes repeatedly during the first write and compaction, improving the performance of high-throughput imports."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"compaction_policy"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Configures the compaction merge policy for this table, supporting only time_series or size_basedtime_series: When the disk volume of rowsets accumulates to a certain size, version merging is performed. The merged rowset is directly promoted to the base compaction phase. This effectively reduces the write amplification of compact in scenarios with continuous imports. This policy will use parameters prefixed with time_series_compaction to adjust the execution of compaction."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"time_series_compaction_goal_size_mbytes"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"When the compaction merge policy is time_series, this parameter is used to adjust the size of the input files for each compaction, with the output file size being comparable to the input."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"time_series_compaction_file_count_threshold"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"When the compaction merge policy is time_series, this parameter is used to adjust the minimum number of input files for each compaction. If the number of files in a tablet exceeds this configuration, compaction will be triggered."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"time_series_compaction_time_threshold_seconds"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"When the compaction merge policy is time_series, this parameter is used to adjust the longest interval between compactions, i.e., a compaction will be triggered if it has not been executed for a long time, in seconds."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"time_series_compaction_level_threshold"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"When the compaction merge policy is time_series, this parameter defaults to 1. When set to 2, it is used to control that segments merged once are merged again to ensure that the segment size reaches time_series_compaction_goal_size_mbytes, achieving the effect of reducing the number of segments."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"group_commit_interval_ms"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Configures the Group Commit batch interval for this table. The unit is ms, with a default value of 10000ms, i.e., 10s. The timing of Group Commit depends on which of ",(0,l.jsx)(n.code,{children:"group_commit_interval_ms"})," and ",(0,l.jsx)(n.code,{children:"group_commit_data_bytes"})," reaches the set value first."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"group_commit_data_bytes"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Configures the Group Commit batch data size for this table. The unit is bytes, with a default value of 134217728, i.e., 128MB. The timing of Group Commit depends on which of ",(0,l.jsx)(n.code,{children:"group_commit_interval_ms"})," and ",(0,l.jsx)(n.code,{children:"group_commit_data_bytes"})," reaches the set value first."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"enable_mow_light_delete"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Whether to enable writing Delete predicate with Delete statements on Unique tables with Mow. If enabled, it will improve the performance of Delete statements, but partial column updates after Delete may result in some data errors. If disabled, it will reduce the performance of Delete statements to ensure correctness. The default value of this property is ",(0,l.jsx)(n.code,{children:"false"}),". This property can only be enabled on Unique Merge-on-Write tables."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Dynamic Partitioning Related Properties"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["For dynamic partitioning, refer to ",(0,l.jsx)(n.a,{href:"../../../../table-design/data-partitioning/dynamic-partitioning",children:"Data Partitioning - Dynamic Partitioning"})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"enable_unique_key_skip_bitmap_column"}),(0,l.jsxs)(n.td,{style:{textAlign:"left"},children:["Whether to enable the ",(0,l.jsx)(n.a,{href:"/docs/3.x/data-operate/update/update-of-unique-model#flexible-partial-column-updates",children:"Flexible Column Update feature"})," on Unique Merge-on-Write tables. This property can only be enabled on Unique Merge-on-Write tables. (Supported since version 3.1.0)"]})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"access-control-requirements",children:"Access Control Requirements"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.a,{href:"/docs/3.x/admin-manual/auth/authentication-and-authorization",children:"user"})," executing this SQL command must have at least the following ",(0,l.jsx)(n.a,{href:"/docs/3.x/admin-manual/auth/authentication-and-authorization",children:"privileges"}),":"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Privilege"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Object"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"CREATE_PRIV"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Database"}),(0,l.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"SELECT_PRIV"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Table, View"}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:"Required when executing CTAS to have SELECT_PRIV on the queried table, view, or materialized view"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"usage-notes",children:"Usage Notes"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The database (Database) must not contain tables (Table) or views (View) with the same name."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["Table names, column names, and rollup names must not use ",(0,l.jsx)(n.a,{href:"/docs/3.x/sql-manual/basic-element/reserved-keywords",children:"Reserved Keywords"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"CREATE TABLE ... LIKE:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"This command can only be used on internal Doris tables."}),"\n",(0,l.jsx)(n.li,{children:"Only explicitly specified rollups will be copied."}),"\n",(0,l.jsx)(n.li,{children:"All synchronized materialized views will not be replicated."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"CREATE TABLE ... AS SELECT (CTAS):"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"If the alias of the column name in the SELECT list is a valid column, then column definitions are not required in the CTAS statement; if omitted, column names and data types will be inferred from the base query:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE <table_name> AS SELECT ...\n"})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Alternatively, you can explicitly specify names using the following syntax:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE <table_name> ( <col1_name>, <col2_name>, ... ) AS SELECT ...\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Partitioning and Bucketing"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["A table must specify bucketing columns but can opt out of specifying partitions. For detailed information on partitioning and bucketing, refer to the ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/data-partitioning/auto-partitioning",children:"Data Partitioning"})," documentation."]}),"\n",(0,l.jsx)(n.li,{children:"Tables in Doris can be either partitioned or non-partitioned. This attribute is determined at table creation and cannot be changed afterward. That is, for partitioned tables, partitions can be added or removed in subsequent use, while non-partitioned tables cannot have partitions added later."}),"\n",(0,l.jsx)(n.li,{children:"Partition and bucket columns cannot be altered after table creation; neither the types of partition and bucket columns can be changed nor can these columns be added or removed."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Dynamic Partitioning"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["The dynamic partitioning feature is primarily used to help users manage partitions automatically. By setting certain rules, the Doris system periodically adds new partitions or removes old ones. For more assistance, refer to the ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/data-partitioning/dynamic-partitioning",children:"Dynamic Partitioning"})," documentation."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Automatic Partitioning"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Documentation for automatic partitioning can be found in ",(0,l.jsx)(n.a,{href:"/docs/3.x/table-design/data-partitioning/auto-partitioning",children:"Automatic Partitioning"}),"."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Synchronized Materialized Views"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Users can create multiple synchronized materialized views (ROLLUP) while creating a table. Synchronized materialized views can also be added after the table is created. Including them in the table creation statement facilitates the one-time creation of all synchronized materialized views."}),"\n",(0,l.jsx)(n.li,{children:"If synchronized materialized views are created at the time of table creation, all subsequent data import operations will synchronously generate data for the materialized views. The number of materialized views may affect the efficiency of data import."}),"\n",(0,l.jsxs)(n.li,{children:["For an introduction to materialized views, please refer to the documentation on ",(0,l.jsx)(n.a,{href:"/docs/3.x/query-acceleration/materialized-view/sync-materialized-view",children:"Synchronized Materialized Views"}),"."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Indexes"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Users can create multiple column indexes while creating a table. Indexes can also be added after the table is created."}),"\n",(0,l.jsx)(n.li,{children:"If indexes are added during subsequent use and there is existing data in the table, all data will need to be rewritten; hence, the time to create an index depends on the current volume of data."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,l.jsx)(n.h3,{id:"basic-examples",children:"Basic Examples"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Detail Model"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t1\n(\n  c1 INT,\n  c2 STRING\n)\nDUPLICATE KEY(c1)\nDISTRIBUTED BY HASH(c1)\nPROPERTIES (\n  'replication_num' = '1'\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Aggregation Model"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t2\n(\n  c1 INT,\n  c2 INT MAX\n)\nAGGREGATE KEY(c1)\nDISTRIBUTED BY HASH(c1)\nPROPERTIES (\n  'replication_num' = '1'\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Primary Key Model"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t3\n(\n  c1 INT,\n  c2 INT\n)\nUNIQUE KEY(c1)\nDISTRIBUTED BY HASH(c1)\nPROPERTIES (\n  'replication_num' = '1'\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Using Generated Columns"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t4\n(\n  c1 INT,\n  c2 INT GENERATED ALWAYS AS (c1 + 1)\n)\nDUPLICATE KEY(c1)\nDISTRIBUTED BY HASH(c1)\nPROPERTIES (\n  'replication_num' = '1'\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Specifying Column Default Values"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t5\n(\n  c1 INT,\n  c2 INT DEFAULT 10\n)\nDUPLICATE KEY(c1)\nDISTRIBUTED BY HASH(c1)\nPROPERTIES (\n  'replication_num' = '1'\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Bucketing Method"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t6\n(\n  c1 INT,\n  c2 INT\n)\nDUPLICATE KEY(c1)\nDISTRIBUTED BY RANDOM\nPROPERTIES (\n  'replication_num' = '1'\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Automatic Partitioning"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t7\n(\n  c1 INT,\n  c2 DATETIME NOT NULL\n)\nDUPLICATE KEY(c1)\nAUTO PARTITION BY RANGE(date_trunc(c2, 'day')) ()\nDISTRIBUTED BY RANDOM\nPROPERTIES (\n  'replication_num' = '1'\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Range Partitioning"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t8\n(\n  c1 INT,\n  c2 DATETIME NOT NULL\n)\nDUPLICATE KEY(c1)\nPARTITION BY RANGE(c2) (\n  FROM ('2020-01-01') TO ('2020-01-10') INTERVAL 1 DAY\n)\nDISTRIBUTED BY RANDOM\nPROPERTIES (\n  'replication_num' = '1'\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"List Partitioning"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t9\n(\n  c1 INT,\n  c2 DATE NOT NULL\n)\nDUPLICATE KEY(c1)\nPARTITION BY LIST(c2) (\n  PARTITION p1 VALUES IN (('2020-01-01'),('2020-01-02'))\n)\nDISTRIBUTED BY RANDOM\nPROPERTIES (\n  'replication_num' = '1'\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Storage Medium and Cooldown Time"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE example_db.table_hash\n(\n    k1 BIGINT,\n    k2 LARGEINT,\n    v1 VARCHAR(2048),\n    v2 SMALLINT DEFAULT "10"\n)\nUNIQUE KEY(k1, k2)\nDISTRIBUTED BY HASH (k1, k2) BUCKETS 32\nPROPERTIES(\n    "storage_medium" = "SSD",\n    "storage_cooldown_time" = "2015-06-04 00:00:00"\n);\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsxs)(n.strong,{children:["Setting Table's Cold-Hot Tiered Data Migration Strategy with ",(0,l.jsx)(n.code,{children:"storage_policy"})," Property"]})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"You need to create an s3 resource and storage policy first for the table to successfully associate with the migration strategy."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'-- Non-partitioned table\nCREATE TABLE IF NOT EXISTS create_table_use_created_policy \n(\n    k1 BIGINT,\n    k2 LARGEINT,\n    v1 VARCHAR(2048)\n)\nUNIQUE KEY(k1)\nDISTRIBUTED BY HASH (k1) BUCKETS 3\nPROPERTIES(\n    "storage_policy" = "test_create_table_use_policy",\n    "replication_num" = "1"\n);\n\n-- Partitioned table\nCREATE TABLE create_table_partion_use_created_policy\n(\n    k1 DATE,\n    k2 INT,\n    V1 VARCHAR(2048) REPLACE\n) PARTITION BY RANGE (k1) (\n    PARTITION p1 VALUES LESS THAN ("2022-01-01") ("storage_policy" = "test_create_table_partition_use_policy_1" ,"replication_num"="1"),\n    PARTITION p2 VALUES LESS THAN ("2022-02-01") ("storage_policy" = "test_create_table_partition_use_policy_2" ,"replication_num"="1")\n) DISTRIBUTED BY HASH(k2) BUCKETS 1;\n'})}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Colocation Group"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE t1 (\n    id int(11) COMMENT "",\n    value varchar(8) COMMENT ""\n)\nDUPLICATE KEY(id)\nDISTRIBUTED BY HASH(id) BUCKETS 10\nPROPERTIES (\n    "colocate_with" = "group1"\n);\n\nCREATE TABLE t2 (\n    id int(11) COMMENT "",\n    value1 varchar(8) COMMENT "",\n    value2 varchar(8) COMMENT ""\n)\nDUPLICATE KEY(`id`)\nDISTRIBUTED BY HASH(`id`) BUCKETS 10\nPROPERTIES (\n    "colocate_with" = "group1"\n);\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Index"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE example_db.table_hash\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 CHAR(10) REPLACE,\n    v2 INT SUM,\n    INDEX k1_idx (k1) USING INVERTED COMMENT \'my first index\'\n)\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\nPROPERTIES (\n    "bloom_filter_columns" = "k2"\n);\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Setting Table's Replication Properties"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE example_db.table_hash\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5"\n)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\nPROPERTIES (\n    "replication_allocation"="tag.location.group_a:1, tag.location.group_b:2"\n);\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Dynamic Partitioning"})}),"\n",(0,l.jsxs)(n.p,{children:["This table creates partitions 3 days in advance and deletes partitions from 3 days ago. For example, if today is ",(0,l.jsx)(n.code,{children:"2020-01-08"}),", it will create partitions named ",(0,l.jsx)(n.code,{children:"p20200108"}),", ",(0,l.jsx)(n.code,{children:"p20200109"}),", ",(0,l.jsx)(n.code,{children:"p20200110"}),", ",(0,l.jsx)(n.code,{children:"p20200111"}),". The partition ranges are as follows:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-Plain",children:'[types: [DATE]; keys: [2020-01-08]; \u2025types: [DATE]; keys: [2020-01-09]; )\n[types: [DATE]; keys: [2020-01-09]; \u2025types: [DATE]; keys: [2020-01-10]; )\n[types: [DATE]; keys: [2020-01-10]; \u2025types: [DATE]; keys: [2020-01-11]; )\n[types: [DATE]; keys: [2020-01-11]; \u2025types: [DATE]; keys: [2020-01-12]; )\nCREATE TABLE example_db.dynamic_partition\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1) ()\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n    "dynamic_partition.time_unit" = "DAY",\n    "dynamic_partition.start" = "-3",\n    "dynamic_partition.end" = "3",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "32" \n);\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Setting Dynamic Partition's Replication Properties"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE example_db.dynamic_partition\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nPARTITION BY RANGE (k1) ()\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n    "dynamic_partition.time_unit" = "DAY",\n    "dynamic_partition.start" = "-3",\n    "dynamic_partition.end" = "3",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "32",\n    "dynamic_partition.replication_allocation" = "tag.location.group_a:3"\n );\n'})}),"\n",(0,l.jsx)(n.h3,{id:"ctas-example",children:"CTAS Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t10\nPROPERTIES (\n  'replication_num' = '1'\n)\nAS SELECT * FROM t1;\n"})}),"\n",(0,l.jsx)(n.h3,{id:"create-table--like-example",children:"CREATE TABLE ... LIKE Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t11 LIKE t10;\n"})})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return a}});var i=t(667294);let l={},s=i.createContext(l);function a(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);