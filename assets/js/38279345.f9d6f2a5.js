"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["372852"],{374020:function(e,n,i){i.r(n),i.d(n,{default:()=>h,frontMatter:()=>r,metadata:()=>t,assets:()=>l,toc:()=>d,contentTitle:()=>o});var t=JSON.parse('{"id":"table-design/storage-format","title":"Storage Format V3","description":"\x3c!--","source":"@site/versioned_docs/version-4.x/table-design/storage-format.md","sourceDirName":"table-design","slug":"/table-design/storage-format","permalink":"/docs/4.x/table-design/storage-format","draft":false,"unlisted":false,"tags":[],"version":"4.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Storage Format V3","language":"en"},"sidebar":"docs","previous":{"title":"Column Compression","permalink":"/docs/4.x/table-design/column-compression"},"next":{"title":"Index Overview","permalink":"/docs/4.x/table-design/index/index-overview"}}'),s=i("785893"),a=i("250065");let r={title:"Storage Format V3",language:"en"},o=void 0,l={},d=[{value:"Key Optimizations",id:"key-optimizations",level:2},{value:"External Column Meta",id:"external-column-meta",level:3},{value:"Integer Type Plain Encoding",id:"integer-type-plain-encoding",level:3},{value:"Binary Plain Encoding V2",id:"binary-plain-encoding-v2",level:3},{value:"Design Philosophy",id:"design-philosophy",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Usage",id:"usage",level:2},{value:"Enable When Creating a New Table",id:"enable-when-creating-a-new-table",level:3}];function c(e){let n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Doris Storage Format V3 is a major evolution from the Segment V2 format. Through metadata decoupling and encoding strategy optimization, it specifically improves performance for wide tables, complex data types (such as Variant), and cloud-native storage-compute separation scenarios."}),"\n",(0,s.jsx)(n.h2,{id:"key-optimizations",children:"Key Optimizations"}),"\n",(0,s.jsx)(n.h3,{id:"external-column-meta",children:"External Column Meta"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Background"}),": In Segment V2, metadata for all columns (",(0,s.jsx)(n.code,{children:"ColumnMetaPB"}),") is stored in the Footer of the Segment file. For wide tables with thousands of columns or auto-scaling Variant scenarios, the Footer can grow to several megabytes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimization"}),": V3 decouples ",(0,s.jsx)(n.code,{children:"ColumnMetaPB"})," from the Footer and stores it in a separate area within the file (External Column Meta Area)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ultra-fast Metadata Loading"}),": Significantly reduces Segment Footer size, speeding up initial file opening."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"On-demand Loading"}),": Metadata can be loaded on demand from the independent area, reducing memory usage and improving cold start query performance on object storage (like S3/OSS)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"integer-type-plain-encoding",children:"Integer Type Plain Encoding"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimization"}),": V3 defaults to ",(0,s.jsx)(n.code,{children:"PLAIN_ENCODING"})," (raw binary storage) for numerical types (such as ",(0,s.jsx)(n.code,{children:"INT"}),", ",(0,s.jsx)(n.code,{children:"BIGINT"}),"), instead of the traditional BitShuffle."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),": Combined with LZ4/ZSTD compression, ",(0,s.jsx)(n.code,{children:"PLAIN_ENCODING"}),' provides higher read throughput and lower CPU overhead. In modern high-speed IO environments, this "trading decompression for performance" strategy offers a clear advantage when scanning large volumes of data.']}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"binary-plain-encoding-v2",children:"Binary Plain Encoding V2"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimization"}),": Introduces ",(0,s.jsx)(n.code,{children:"BINARY_PLAIN_ENCODING_V2"}),", using a ",(0,s.jsx)(n.code,{children:"[length(varuint)][raw_data]"})," streaming layout, replacing the old format that relied on trailing offset tables."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),": Eliminates large trailing offset tables, making data storage more compact and significantly reducing storage consumption for string and JSONB types."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,s.jsxs)(n.p,{children:["The design philosophy of V3 can be summarized as: ",(0,s.jsx)(n.strong,{children:'"Metadata Decoupling, Encoding Simplification, and Streaming Layout"'}),". By reducing metadata processing bottlenecks and leveraging the high efficiency of modern CPUs in processing simple encodings, it achieves high-performance analysis under complex schemas."]}),"\n",(0,s.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Wide Tables"}),": Tables with more than 2000 columns or long column names."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Semi-structured Data"}),": Heavy use of ",(0,s.jsx)(n.code,{children:"VARIANT"})," or ",(0,s.jsx)(n.code,{children:"JSON"})," types."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tiered Storage/Cloud Native"}),": Scenarios sensitive to object storage loading latency."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High-performance Scanning"}),": Analytical tasks with extreme requirements for scan throughput."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.h3,{id:"enable-when-creating-a-new-table",children:"Enable When Creating a New Table"}),"\n",(0,s.jsxs)(n.p,{children:["Specify ",(0,s.jsx)(n.code,{children:"storage_format"})," as ",(0,s.jsx)(n.code,{children:"V3"})," in the ",(0,s.jsx)(n.code,{children:"PROPERTIES"})," of the ",(0,s.jsx)(n.code,{children:"CREATE TABLE"})," statement:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE table_v3 (\n    id BIGINT,\n    data VARIANT\n)\nDISTRIBUTED BY HASH(id) BUCKETS 32\nPROPERTIES (\n    "storage_format" = "V3"\n);\n'})})]})}function h(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return o},a:function(){return r}});var t=i(667294);let s={},a=t.createContext(s);function r(e){let n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);