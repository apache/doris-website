"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["672637"],{50102:function(e,t,i){i.r(t),i.d(t,{default:()=>c,frontMatter:()=>s,metadata:()=>n,assets:()=>l,toc:()=>d,contentTitle:()=>o});var n=JSON.parse('{"id":"developer-guide/bitmap-hll-file-format","title":"Bitmap/HLL data format","description":"\x3c!--","source":"@site/community/developer-guide/bitmap-hll-file-format.md","sourceDirName":"developer-guide","slug":"/developer-guide/bitmap-hll-file-format","permalink":"/community/developer-guide/bitmap-hll-file-format","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Bitmap/HLL data format","language":"en"},"sidebar":"community","previous":{"title":"C++ Code Diagnostic","permalink":"/community/developer-guide/cpp-diagnostic-code"},"next":{"title":"Github Checks","permalink":"/community/developer-guide/github-checks"}}'),r=i("785893"),a=i("250065");let s={title:"Bitmap/HLL data format",language:"en"},o=void 0,l={},d=[{value:"Bitmap format",id:"bitmap-format",level:2},{value:"Format description",id:"format-description",level:3},{value:"HLL format description",id:"hll-format-description",level:2}];function h(e){let t={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"bitmap-format",children:"Bitmap format"}),"\n",(0,r.jsx)(t.h3,{id:"format-description",children:"Format description"}),"\n",(0,r.jsxs)(t.p,{children:["The bitmap in Doris uses roaring bitmap storage, and the be side uses CRoaring. The serialization format of ",(0,r.jsx)(t.code,{children:"Roaring"})," is compatible in languages \u200B\u200Bsuch as C++/java/go, while the serialization result of the format of C++ ",(0,r.jsx)(t.code,{children:"Roaring64Map"})," is the same as that of ",(0,r.jsx)(t.code,{children:"Roaring64NavigableMap"})," in Java. Not compatible. There are 5 types of Doris bimap, each of which is represented by one byte"]}),"\n",(0,r.jsx)(t.p,{children:"The bitmap serialization format in Doris is explained as follows:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:" | flag     | data .....|\n <--1Byte--\x3e<--n bytes--\x3e\n"})}),"\n",(0,r.jsx)(t.p,{children:"The Flag value description is as follows:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Value"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"0"}),(0,r.jsx)(t.td,{children:"EMPTY, empty bitmap, the following data part is empty, the whole serialization result is only one byte"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"1"}),(0,r.jsx)(t.td,{children:"SINGLE32, there is only one 32-bit unsigned integer value in the bitmap, and the next 4 bytes represent the 32-bit unsigned integer value"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"2"}),(0,r.jsxs)(t.td,{children:["BITMAP32, 32-bit bitmap corresponds to the type ",(0,r.jsx)(t.code,{children:"org.roaringbitmap.RoaringBitmap"})," in java. The type is ",(0,r.jsx)(t.code,{children:"roaring::Roaring"})," in C++, and the following data is the structure after the sequence of roaring::Roaring. You can use ",(0,r.jsx)(t.code,{children:"org in java. .roaringbitmap.RoaringBitmap"})," or ",(0,r.jsx)(t.code,{children:"roaring::Roaring"})," in c++ directly deserialize"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"3"}),(0,r.jsx)(t.td,{children:"SINGLE64, there is only one 64-bit unsigned integer value in the bitmap, and the next 8 bytes represent the 64-bit unsigned integer value"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"4"}),(0,r.jsxs)(t.td,{children:["BITMAP64, 64-bit bitmap corresponds to ",(0,r.jsx)(t.code,{children:"org.roaringbitmap.RoaringBitmap"})," in java; ",(0,r.jsx)(t.code,{children:"Roaring64Map"})," in doris in c++. The data structure is the same as the result in the roaring library, but the serialization and deserialization methods It is different, there will be 1-8 bytes of variable-length encoding uint64 in the bitmap representation of the size. The following data is a series of multiple high-order representations of 4 bytes and 32-bit roaring bitmap serialized data repeated"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"5"}),(0,r.jsx)(t.td,{children:"SET, When the number of values in the bitmap is greater than one and less than 32, the BitmapValue actually uses a hash set to store the values. The data structure: A uint8_t of one byte represents the number of values, followed by the values themselves (8 bytes each, uint64_t). \uFF5C"})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:["C++ serialization and deserialization examples are in the ",(0,r.jsx)(t.code,{children:"BitmapValue::write()"})," method in ",(0,r.jsx)(t.code,{children:"be/src/util/bitmap_value.h"})," and the Java examples are in the ",(0,r.jsx)(t.code,{children:"serialize()"})," ",(0,r.jsx)(t.code,{children:"deserialize()"})," method in ",(0,r.jsx)(t.code,{children:"fe/fe-common/src/main/java/org/apache/doris/common/io/BitmapValue.java"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"hll-format-description",children:"HLL format description"}),"\n",(0,r.jsx)(t.p,{children:"Serialized data in HLL format is implemented in Doris itself. Similar to the Bitmap type, the HLL format is composed of a 1-byte flag followed by multiple bytes of data. The meaning of the flag is as follows"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Value"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"0"}),(0,r.jsx)(t.td,{children:"HLL_DATA_EMPTY, empty HLL, the following data part is empty, the entire serialization result is only one byte"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"1"}),(0,r.jsx)(t.td,{children:"HLL_DATA_EXPLICIT, the next byte is explicit The number of data blocks, followed by multiple data blocks, each data block is composed of 8 bytes in length and data,"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"2"}),(0,r.jsx)(t.td,{children:"HLL_DATA_SPARSE, only non-zero values are stored, the next 4 bytes indicate the number of registers, and there are multiple register structures in the back. Each register is composed of the index of the first 2 bytes and the value of 1 byte"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"3"}),(0,r.jsx)(t.td,{children:"HLL_DATA_FULL, which means that all 16 * 1024 registers have values, followed by 16 * 1024 bytes of value data"})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:["C++ serialization and deserialization examples are in the ",(0,r.jsx)(t.code,{children:"serialize()"})," ",(0,r.jsx)(t.code,{children:"deserialize()"})," method of ",(0,r.jsx)(t.code,{children:"be/src/olap/hll.h"}),", and the Java examples are in the ",(0,r.jsx)(t.code,{children:"serialize()"})," ",(0,r.jsx)(t.code,{children:"deserialize()"})," method in ",(0,r.jsx)(t.code,{children:"fe/fe-common/src/main/java/org/apache/doris/common/io/hll.java"}),"."]})]})}function c(e={}){let{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},250065:function(e,t,i){i.d(t,{Z:function(){return o},a:function(){return s}});var n=i(667294);let r={},a=n.createContext(r);function s(e){let t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);