"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["121469"],{894106:function(e,n,s){s.r(n),s.d(n,{default:()=>h,frontMatter:()=>i,metadata:()=>r,assets:()=>l,toc:()=>d,contentTitle:()=>a});var r=JSON.parse('{"id":"data-operate/import/broker-load-manual","title":"Broker Load","description":"Why introduce Broker Load?","source":"@site/versioned_docs/version-2.0/data-operate/import/broker-load-manual.md","sourceDirName":"data-operate/import","slug":"/data-operate/import/broker-load-manual","permalink":"/docs/2.0/data-operate/import/broker-load-manual","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Broker Load","language":"en"},"sidebar":"docs","previous":{"title":"Stream Load","permalink":"/docs/2.0/data-operate/import/stream-load-manual"},"next":{"title":"Routine Load","permalink":"/docs/2.0/data-operate/import/routine-load-manual"}}'),o=s("785893"),t=s("250065");let i={title:"Broker Load",language:"en"},a=void 0,l={},d=[{value:"Why introduce Broker Load?",id:"why-introduce-broker-load",level:2},{value:"Basic Principles",id:"basic-principles",level:2},{value:"SQL syntax for importing",id:"sql-syntax-for-importing",level:2},{value:"Checking import status",id:"checking-import-status",level:2},{value:"Cancelling an Import",id:"cancelling-an-import",level:2},{value:"HDFS Load",id:"hdfs-load",level:2},{value:"Simple Authentication",id:"simple-authentication",level:3},{value:"Kerberos Authentication",id:"kerberos-authentication",level:3},{value:"HDFS HA Mode",id:"hdfs-ha-mode",level:3},{value:"Import Example",id:"import-example",level:3},{value:"S3 Load",id:"s3-load",level:2},{value:"Preparation",id:"preparation",level:3},{value:"Import example",id:"import-example-1",level:3},{value:"Common Issues",id:"common-issues",level:3},{value:"Broker Information",id:"broker-information",level:3},{value:"Broker Examples",id:"broker-examples",level:3},{value:"Related Configurations",id:"related-configurations",level:2},{value:"Common Issues",id:"common-issues-1",level:2},{value:"More Help",id:"more-help",level:2}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"why-introduce-broker-load",children:"Why introduce Broker Load?"}),"\n",(0,o.jsx)(n.p,{children:"Stream Load is a push-based method, where the data to be imported relies on the client to read and push it to Doris. Broker Load, on the other hand, involves sending an import request to Doris, and Doris actively pulls the data. Therefore, if the data is stored in systems like HDFS or object storage, using Broker Load is the most convenient. This way, the data doesn't need to pass through the client but is directly read and imported by Doris."}),"\n",(0,o.jsxs)(n.p,{children:["Direct reads from HDFS or S3 can also be imported through HDFS TVF or S3 TVF in the ",(0,o.jsx)(n.a,{href:"../../lakehouse/file",children:"Lakehouse/TVF"}),'. The current "Insert Into" based on TVF is a synchronous import, while Broker Load is an asynchronous import method.']}),"\n",(0,o.jsx)(n.p,{children:"Broker Load is suitable for scenarios where the source data is stored in remote storage systems, such as HDFS, and the data volume is relatively large."}),"\n",(0,o.jsx)(n.h2,{id:"basic-principles",children:"Basic Principles"}),"\n",(0,o.jsx)(n.p,{children:"After a user submits an import task, the Frontend (FE) generates a corresponding plan. Based on the current number of Backend (BE) nodes and the size of the file, the plan is distributed to multiple BE nodes for execution, with each BE node handling a portion of the import data."}),"\n",(0,o.jsx)(n.p,{children:"During execution, the BE nodes pull data from the Broker, perform necessary transformations, and then import the data into the system. Once all BE nodes have completed the import, the FE makes the final determination on whether the import was successful."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Broker Load",src:s(172029).Z+"",width:"2560",height:"1376"})}),"\n",(0,o.jsx)(n.p,{children:"As seen in the diagram, BE nodes rely on Broker processes to read data from corresponding remote storage systems. The introduction of Broker processes primarily aims to accommodate different remote storage systems. Users can develop their own Broker processes according to established standards. These Broker processes, which can be developed using Java, offer better compatibility with various storage systems in the big data ecosystem. The separation of Broker processes from BE nodes ensures error isolation between the two, enhancing the stability of the BE."}),"\n",(0,o.jsx)(n.p,{children:"Currently, BE nodes have built-in support for HDFS and S3 Brokers. Therefore, when importing data from HDFS or S3, there is no need to additionally start a Broker process. However, if a customized Broker implementation is required, the corresponding Broker process needs to be deployed."}),"\n",(0,o.jsx)(n.h2,{id:"sql-syntax-for-importing",children:"SQL syntax for importing"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL load_label\n(\ndata_desc1[, data_desc2, ...]\n)\nWITH [HDFS|S3|BROKER broker_name] \n[broker_properties]\n[load_properties]\n[COMMENT "comments"];\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For the specific syntax for usage, please refer to ",(0,o.jsx)(n.a,{href:"../../sql-manual/sql-reference/Data-Manipulation-Statements/Load/BROKER-LOAD",children:"BROKER LOAD"})," in the SQL manual."]}),"\n",(0,o.jsx)(n.h2,{id:"checking-import-status",children:"Checking import status"}),"\n",(0,o.jsxs)(n.p,{children:["Broker Load is an asynchronous import method, and the specific import results can be viewed through the ",(0,o.jsx)(n.a,{href:"../../sql-manual/sql-reference/Show-Statements/SHOW-LOAD",children:"SHOW LOAD"})," command."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'mysql> show load order by createtime desc limit 1\\G;\n*************************** 1. row ***************************\n         JobId: 41326624\n         Label: broker_load_2022_04_15\n         State: FINISHED\n      Progress: ETL:100%; LOAD:100%\n          Type: BROKER\n       EtlInfo: unselected.rows=0; dpp.abnorm.ALL=0; dpp.norm.ALL=27\n      TaskInfo: cluster:N/A; timeout(s):1200; max_filter_ratio:0.1\n      ErrorMsg: NULL\n    CreateTime: 2022-04-01 18:59:06\n  EtlStartTime: 2022-04-01 18:59:11\n EtlFinishTime: 2022-04-01 18:59:11\n LoadStartTime: 2022-04-01 18:59:11\nLoadFinishTime: 2022-04-01 18:59:11\n           URL: NULL\n    JobDetails: {"Unfinished backends":{"5072bde59b74b65-8d2c0ee5b029adc0":[]},"ScannedRows":27,"TaskNumber":1,"All backends":{"5072bde59b74b65-8d2c0ee5b029adc0":[36728051]},"FileNumber":1,"FileSize":5540}\n1 row in set (0.01 sec)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"cancelling-an-import",children:"Cancelling an Import"}),"\n",(0,o.jsxs)(n.p,{children:["When the status of a Broker Load job is not CANCELLED or FINISHED, it can be manually cancelled by the user. To cancel, the user needs to specify the label of the import task to be cancelled. The syntax for the cancel import command can be viewed by executing ",(0,o.jsx)(n.a,{href:"../../sql-manual/sql-reference/Data-Manipulation-Statements/Load/CANCEL-LOAD",children:"CANCEL LOAD"}),"."]}),"\n",(0,o.jsx)(n.p,{children:'For example: To cancel the import job with the label "broker_load_2022_03_23" on the DEMO database.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'CANCEL LOAD FROM demo WHERE LABEL = "broker_load_2022_03_23";\n'})}),"\n",(0,o.jsx)(n.h2,{id:"hdfs-load",children:"HDFS Load"}),"\n",(0,o.jsx)(n.h3,{id:"simple-authentication",children:"Simple Authentication"}),"\n",(0,o.jsx)(n.p,{children:'Simple authentication refers to the configuration of Hadoop where hadoop.security.authentication is set to "simple".'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Plain",children:'(\n    "username" = "user",\n    "password" = ""\n);\n'})}),"\n",(0,o.jsx)(n.p,{children:"The username should be configured as the user to be accessed, and the password can be left blank."}),"\n",(0,o.jsx)(n.h3,{id:"kerberos-authentication",children:"Kerberos Authentication"}),"\n",(0,o.jsx)(n.p,{children:"This authentication method requires the following information:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"hadoop.security.authentication:"})," Specifies the authentication method as Kerberos."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"hadoop.kerberos.principal:"})," Specifies the Kerberos principal."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"hadoop.kerberos.keytab:"})," Specifies the file path of the Kerberos keytab. The file must be an absolute path on the server where the Broker process is located and must be accessible by the Broker process."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"kerberos_keytab_content:"})," Specifies the content of the Kerberos keytab file after being encoded in base64. This can be used as an alternative to the kerberos_keytab configuration."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Example configuration:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Plain",children:'(\n    "hadoop.security.authentication" = "kerberos",\n    "hadoop.kerberos.principal" = "doris@YOUR.COM",\n    "hadoop.kerberos.keytab" = "/home/doris/my.keytab"\n)\n(\n    "hadoop.security.authentication" = "kerberos",\n    "hadoop.kerberos.principal" = "doris@YOUR.COM",\n    "kerberos_keytab_content" = "ASDOWHDLAWIDJHWLDKSALDJSDIWALD"\n)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["To use Kerberos authentication, the ",(0,o.jsx)(n.a,{href:"https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html",children:"krb5.conf (opens new window)"})," file is required. The krb5.conf file contains Kerberos configuration information. Typically, the krb5.conf file should be installed in the /etc directory. You can override the default location by setting the KRB5_CONFIG environment variable. An example of the krb5.conf file content is as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Plain",children:"[libdefaults]\n    default_realm = DORIS.HADOOP\n    default_tkt_enctypes = des3-hmac-sha1 des-cbc-crc\n    default_tgs_enctypes = des3-hmac-sha1 des-cbc-crc\n    dns_lookup_kdc = true\n    dns_lookup_realm = false\n\n[realms]\n    DORIS.HADOOP = {\n        kdc = kerberos-doris.hadoop.service:7005\n    }\n"})}),"\n",(0,o.jsx)(n.h3,{id:"hdfs-ha-mode",children:"HDFS HA Mode"}),"\n",(0,o.jsx)(n.p,{children:"This configuration is used to access HDFS clusters deployed in HA (High Availability) mode."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"dfs.nameservices:"}),' Specifies the name of the HDFS service, which can be customized. For example: "dfs.nameservices" = "my_ha".']}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"dfs.ha.namenodes.xxx:"}),' Customizes the names of the namenodes, with multiple names separated by commas. Here, xxx represents the custom name specified in dfs.nameservices. For example: "dfs.ha.namenodes.my_ha" = "my_nn".']}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"dfs.namenode.rpc-address.xxx.nn:"}),' Specifies the RPC address information for the namenode. In this context, nn represents the namenode name configured in dfs.ha.namenodes.xxx. For example: "dfs.namenode.rpc-address.my_ha.my_nn" = "host:port".']}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"dfs.client.failover.proxy.provider.[nameservice ID]:"})," Specifies the provider for client connections to the namenode. The default is org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"An example configuration is as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'(\n    "fs.defaultFS" = "hdfs://my_ha",\n    "dfs.nameservices" = "my_ha",\n    "dfs.ha.namenodes.my_ha" = "my_namenode1, my_namenode2",\n    "dfs.namenode.rpc-address.my_ha.my_namenode1" = "nn1_host:rpc_port",\n    "dfs.namenode.rpc-address.my_ha.my_namenode2" = "nn2_host:rpc_port",\n    "dfs.client.failover.proxy.provider.my_ha" = "org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider"\n)\n'})}),"\n",(0,o.jsx)(n.p,{children:"HA mode can be combined with the previous two authentication methods for cluster access. For example, accessing HA HDFS through simple authentication:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'(\n    "username"="user",\n    "password"="passwd",\n    "fs.defaultFS" = "hdfs://my_ha",\n    "dfs.nameservices" = "my_ha",\n    "dfs.ha.namenodes.my_ha" = "my_namenode1, my_namenode2",\n    "dfs.namenode.rpc-address.my_ha.my_namenode1" = "nn1_host:rpc_port",\n    "dfs.namenode.rpc-address.my_ha.my_namenode2" = "nn2_host:rpc_port",\n    "dfs.client.failover.proxy.provider.my_ha" = "org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider"\n)\n'})}),"\n",(0,o.jsx)(n.h3,{id:"import-example",children:"Import Example"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Importing TXT Files from HDFS"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL demo.label_20220402\n(\n    DATA INFILE("hdfs://host:port/tmp/test_hdfs.txt")\n    INTO TABLE `load_hdfs_file_test`\n    COLUMNS TERMINATED BY "\\t"            \n    (id,age,name)\n) \nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username" = "user"\n)\nPROPERTIES\n(\n    "timeout"="1200",\n    "max_filter_ratio"="0.1"\n);\n'})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"HDFS requires the configuration of NameNode HA (High Availability)"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL demo.label_20220402\n(\n    DATA INFILE("hdfs://hafs/tmp/test_hdfs.txt")\n    INTO TABLE `load_hdfs_file_test`\n    COLUMNS TERMINATED BY "\\t"            \n    (id,age,name)\n) \nwith HDFS\n(\n    "hadoop.username" = "user",\n    "fs.defaultFS"="hdfs://hafs"\uFF0C\n    "dfs.nameservices" = "hafs",\n    "dfs.ha.namenodes.hafs" = "my_namenode1, my_namenode2",\n    "dfs.namenode.rpc-address.hafs.my_namenode1" = "nn1_host:rpc_port",\n    "dfs.namenode.rpc-address.hafs.my_namenode2" = "nn2_host:rpc_port",\n    "dfs.client.failover.proxy.provider.hafs" = "org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider"\n)\nPROPERTIES\n(\n    "timeout"="1200",\n    "max_filter_ratio"="0.1"\n);\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Importing data from HDFS using wildcards to match two batches of files and importing them into two separate tables"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label2\n(\n    DATA INFILE("hdfs://host:port/input/file-10*")\n    INTO TABLE `my_table1`\n    PARTITION (p1)\n    COLUMNS TERMINATED BY ","\n    (k1, tmp_k2, tmp_k3)\n    SET (\n        k2 = tmp_k2 + 1,\n        k3 = tmp_k3 + 1\n    ),\n    DATA INFILE("hdfs://host:port/input/file-20*")\n    INTO TABLE `my_table2`\n    COLUMNS TERMINATED BY ","\n    (k1, k2, k3)\n)\nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username" = "user"\n);\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["To import two batches of files matching the wildcards ",(0,o.jsx)(n.code,{children:"file-10*"})," and ",(0,o.jsx)(n.code,{children:"file-20*"})," from HDFS and load them into two separate tables ",(0,o.jsx)(n.code,{children:"my_table1"})," and ",(0,o.jsx)(n.code,{children:"my_table2"}),". In this case, my_table1 specifies that the data should be imported into partition p1, and the values in the second and third columns of the source files should be incremented by 1 before being imported."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Import a batch of data from HDFS using wildcards"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label3\n(\n    DATA INFILE("hdfs://host:port/user/doris/data/*/*")\n    INTO TABLE `my_table`\n    COLUMNS TERMINATED BY "\\\\x01"\n)\nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username" = "user"\n);\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"To specify the delimiter as the commonly used default delimiter for Hive, which is \\x01, and to use the wildcard character * to refer to all files in all directories under the data directory."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Import Parquet format data and specify the FORMAT as ",(0,o.jsx)(n.code,{children:"parquet"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label4\n(\n    DATA INFILE("hdfs://host:port/input/file")\n    INTO TABLE `my_table`\n    FORMAT AS "parquet"\n    (k1, k2, k3)\n)\nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username" = "user"\n);\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The default method is to determine by file extension."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Import the data and extract the partition field from the file path"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label5\n(\n    DATA INFILE("hdfs://host:port/input/city=beijing/*/*")\n    INTO TABLE `my_table`\n    FORMAT AS "csv"\n    (k1, k2, k3)\n    COLUMNS FROM PATH AS (city, utc_date)\n)\nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username" = "user"\n);\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The columns in the ",(0,o.jsx)(n.code,{children:"my_table"})," are ",(0,o.jsx)(n.code,{children:"k1"}),", ",(0,o.jsx)(n.code,{children:"k2"}),", ",(0,o.jsx)(n.code,{children:"k3"}),", ",(0,o.jsx)(n.code,{children:"city"}),", and ",(0,o.jsx)(n.code,{children:"utc_date"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The directory ",(0,o.jsx)(n.code,{children:"hdfs://hdfs_host:hdfs_port/user/doris/data/input/dir/city=beijing"})," contains the following files:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Plain",children:"hdfs://hdfs_host:hdfs_port/input/city=beijing/utc_date=2020-10-01/0000.csv\nhdfs://hdfs_host:hdfs_port/input/city=beijing/utc_date=2020-10-02/0000.csv\nhdfs://hdfs_host:hdfs_port/input/city=tianji/utc_date=2020-10-03/0000.csv\nhdfs://hdfs_host:hdfs_port/input/city=tianji/utc_date=2020-10-04/0000.csv\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The file only contains three columns of data:",(0,o.jsx)(n.code,{children:"k1"}),",",(0,o.jsx)(n.code,{children:"k2"}),", and ",(0,o.jsx)(n.code,{children:"k3"}),". The other two columns,",(0,o.jsx)(n.code,{children:"city"})," and ",(0,o.jsx)(n.code,{children:"utc_date"}),", will be extracted from the file path."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Filter the imported data"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label6\n(\n    DATA INFILE("hdfs://host:port/input/file")\n    INTO TABLE `my_table`\n    (k1, k2, k3)\n    SET (\n        k2 = k2 + 1\n    )\n    PRECEDING FILTER k1 = 1\n    WHERE k1 > k2\n)\nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username" = "user"\n);\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Only the rows where k1 = 1 in the original data and k1 > k2 after transformation will be imported."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Import data and extract the time partition field from the file path."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label7\n(\n    DATA INFILE("hdfs://host:port/user/data/*/test.txt") \n    INTO TABLE `tbl12`\n    COLUMNS TERMINATED BY ","\n    (k2,k3)\n    COLUMNS FROM PATH AS (data_time)\n    SET (\n        data_time=str_to_date(data_time, \'%Y-%m-%d %H%%3A%i%%3A%s\')\n    )\n)\nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username" = "user"\n);\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{title:"Tip",type:"tip",children:(0,o.jsx)(n.p,{children:'The time contains "%3A". In HDFS paths, colons ":" are not allowed, so all colons are replaced with "%3A".'})}),"\n",(0,o.jsx)(n.p,{children:"There are the following files under the path:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Plain",children:"/user/data/data_time=2020-02-17 00%3A00%3A00/test.txt\n/user/data/data_time=2020-02-18 00%3A00%3A00/test.txt\n"})}),"\n",(0,o.jsx)(n.p,{children:"The table structure is as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS tbl12 (\n    data_time DATETIME,\n    k2        INT,\n    k3        INT\n) DISTRIBUTED BY HASH(data_time) BUCKETS 10\nPROPERTIES (\n    "replication_num" = "3"\n);\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Use Merge mode for import"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label8\n(\n    MERGE DATA INFILE("hdfs://host:port/input/file")\n    INTO TABLE `my_table`\n    (k1, k2, k3, v2, v1)\n    DELETE ON v2 > 100\n)\nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username"="user"\n)\nPROPERTIES\n(\n    "timeout" = "3600",\n    "max_filter_ratio" = "0.1"\n);\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:'To use Merge mode for import, the "my_table" must be a Unique Key table. When the value of the "v2" column in the imported data is greater than 100, that row will be considered a deletion row. The timeout for the import task is 3600 seconds, and an error rate of up to 10% is allowed.'}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:'Specify the "source_sequence" column during import to ensure the order of replacements.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label9\n(\n    DATA INFILE("hdfs://host:port/input/file")\n    INTO TABLE `my_table`\n    COLUMNS TERMINATED BY ","\n    (k1,k2,source_sequence,v1,v2)\n    ORDER BY source_sequence\n) \nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username"="user"\n);\nThe "my_table" must be a Unique Key model table and have a specified Sequence column. The data will maintain its order based on the values in the "source_sequence" column in the source data.\n'})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Import the specified file format as ",(0,o.jsx)(n.code,{children:"json"}),", and specify the ",(0,o.jsx)(n.code,{children:"json_root"})," and jsonpaths accordingly."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label10\n(\n    DATA INFILE("hdfs://host:port/input/file.json")\n    INTO TABLE `my_table`\n    FORMAT AS "json"\n    PROPERTIES(\n      "json_root" = "$.item",\n      "jsonpaths" = "[\\"$.id\\", \\"$.city\\", \\"$.code\\"]"\n    )       \n)\nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username"="user"\n);\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"jsonpaths"})," can also be used in conjunction with the column list and ",(0,o.jsx)(n.code,{children:"SET (column_mapping)"})," :"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'LOAD LABEL example_db.label10\n(\n    DATA INFILE("hdfs://host:port/input/file.json")\n    INTO TABLE `my_table`\n    FORMAT AS "json"\n    (id, code, city)\n    SET (id = id * 10)\n    PROPERTIES(\n      "json_root" = "$.item",\n      "jsonpaths" = "[\\"$.id\\", \\"$.city\\", \\"$.code\\"]"\n    )       \n)\nwith HDFS\n(\n  "fs.defaultFS"="hdfs://host:port",\n  "hadoop.username"="user"\n);\n'})}),"\n",(0,o.jsx)(n.h2,{id:"s3-load",children:"S3 Load"}),"\n",(0,o.jsx)(n.p,{children:"Doris supports importing data directly from object storage systems that support the S3 protocol through the S3 protocol. Here, we mainly introduce how to import data stored in AWS S3. For importing data from other object storage systems that support the S3 protocol, you can refer to the steps for AWS S3."}),"\n",(0,o.jsx)(n.h3,{id:"preparation",children:"Preparation"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["AK and SK: First, you need to find or regenerate your AWS ",(0,o.jsx)(n.code,{children:"Access Keys"}),". You can find instructions on how to generate them in the AWS console under ",(0,o.jsx)(n.code,{children:"My Security Credentials"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["REGION and ENDPOINT: The REGION can be selected when creating a bucket or viewed in the bucket list. The S3 ENDPOINT for each REGION can be found in the ",(0,o.jsx)(n.a,{href:"https://docs.aws.amazon.com/general/latest/gr/s3.html#s3_region",children:"AWS documentation"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"import-example-1",children:"Import example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'    LOAD LABEL example_db.example_label_1\n    (\n        DATA INFILE("s3://your_bucket_name/your_file.txt")\n        INTO TABLE load_test\n        COLUMNS TERMINATED BY ","\n    )\n    WITH S3\n    (\n        "AWS_ENDPOINT" = "AWS_ENDPOINT",\n        "AWS_ACCESS_KEY" = "AWS_ACCESS_KEY",\n        "AWS_SECRET_KEY"="AWS_SECRET_KEY",\n        "AWS_REGION" = "AWS_REGION"\n    )\n    PROPERTIES\n    (\n        "timeout" = "3600"\n    );\n'})}),"\n",(0,o.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["The S3 SDK defaults to using the virtual-hosted style method for accessing objects. However, some object storage systems may not have enabled or supported the virtual-hosted style access. In such cases, we can add the ",(0,o.jsx)(n.code,{children:"use_path_style"})," parameter to force the use of the path style method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'  WITH S3\n  (\n        "AWS_ENDPOINT" = "AWS_ENDPOINT",\n        "AWS_ACCESS_KEY" = "AWS_ACCESS_KEY",\n        "AWS_SECRET_KEY"="AWS_SECRET_KEY",\n        "AWS_REGION" = "AWS_REGION",\n        "use_path_style" = "true"\n  )\n'})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Support for accessing all object storage systems that support the S3 protocol using temporary credentials (TOKEN) is available. The usage is as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'  WITH S3\n  (\n        "AWS_ENDPOINT" = "AWS_ENDPOINT",\n        "AWS_ACCESS_KEY" = "AWS_TEMP_ACCESS_KEY",\n        "AWS_SECRET_KEY" = "AWS_TEMP_SECRET_KEY",\n        "AWS_TOKEN" = "AWS_TEMP_TOKEN",\n        "AWS_REGION" = "AWS_REGION"\n  )\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Importing Data Using Other Brokers"}),"\n",(0,o.jsx)(n.p,{children:"The Broker for other remote storage systems is an optional process in the Doris cluster, primarily used to support Doris in reading and writing files and directories on remote storage. Currently, the following storage system Broker implementations are provided:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Alibaba Cloud OSS"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Baidu Cloud BOS"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Tencent Cloud CHDFS"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Tencent Cloud GFS"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Huawei Cloud OBS"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"JuiceFS"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Google Cloud Storage (GCS)"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The Broker provides services through an RPC service port and operates as a stateless Java process. Its primary responsibility is to encapsulate POSIX-like file operations for remote storage, such as open, pread, pwrite, and more. Additionally, the Broker does not keep track of any other information, which means that all the connection details, file information, and permission details related to the remote storage must be passed to the Broker process through parameters during RPC calls. This ensures that the Broker can correctly read and write files."}),"\n",(0,o.jsx)(n.p,{children:"The Broker serves solely as a data pathway and does not involve any computational tasks, thus requiring minimal memory usage. Typically, a Doris system would deploy one or more Broker processes. Furthermore, Brokers of the same type are grouped together and assigned a unique name (Broker name)."}),"\n",(0,o.jsx)(n.p,{children:"This section primarily focuses on the parameters required by the Broker when accessing different remote storage systems, such as connection information, authentication details, and more. Understanding and correctly configuring these parameters is crucial for successful and secure data exchange between Doris and the remote storage systems."}),"\n",(0,o.jsx)(n.h3,{id:"broker-information",children:"Broker Information"}),"\n",(0,o.jsx)(n.p,{children:"The information of the Broker consists of two parts: the name (Broker name) and the authentication information. The usual syntax format is as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'WITH BROKER "broker_name" \n(\n    "username" = "xxx",\n    "password" = "yyy",\n    "other_prop" = "prop_value",\n    ...\n);\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Broker Name"})}),"\n",(0,o.jsxs)(n.p,{children:["Typically, users need to specify an existing Broker Name through the ",(0,o.jsx)(n.code,{children:'WITH BROKER "broker_name"'})," clause in the operation command. The Broker Name is a name designated by the user when adding a Broker process through the ",(0,o.jsx)(n.code,{children:"ALTER SYSTEM ADD BROKER"})," command. One name usually corresponds to one or more Broker processes. Doris will select an available Broker process based on the name. Users can view the Brokers that currently exist in the cluster through the ",(0,o.jsx)(n.code,{children:"SHOW BROKER"})," command."]}),"\n",(0,o.jsx)(n.admonition,{title:"Note",type:"info",children:(0,o.jsx)(n.p,{children:"The Broker Name is merely a user-defined name and does not represent the type of Broker."})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Authentication Information"}),"\nDifferent Broker types and access methods require different authentication information. The authentication information is usually provided in the Property Map in a Key-Value format after ",(0,o.jsx)(n.code,{children:'WITH BROKER "broker_name"'}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"broker-examples",children:"Broker Examples"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Alibaba Cloud OSS"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'(\n    "fs.oss.accessKeyId" = "",\n    "fs.oss.accessKeySecret" = "",\n    "fs.oss.endpoint" = ""\n)\n'})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"JuiceFS"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'(\n    "fs.defaultFS" = "jfs://xxx/",\n    "fs.jfs.impl" = "io.juicefs.JuiceFileSystem",\n    "fs.AbstractFileSystem.jfs.impl" = "io.juicefs.JuiceFS",\n    "juicefs.meta" = "xxx",\n    "juicefs.access-log" = "xxx"\n)\n'})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"GCS"}),"\n",(0,o.jsxs)(n.p,{children:["When using a Broker to access GCS, the Project ID is required, while other parameters are optional. Please refer to the ",(0,o.jsx)(n.a,{href:"https://github.com/GoogleCloudDataproc/hadoop-connectors/blob/branch-2.2.x/gcs/CONFIGURATION.md",children:"GCS Config"})," for all parameter configurations."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'(\n    "fs.gs.project.id" = "Your Project ID",\n    "fs.AbstractFileSystem.gs.impl" = "com.google.cloud.hadoop.fs.gcs.GoogleHadoopFS",\n    "fs.gs.impl" = "com.google.cloud.hadoop.fs.gcs.GoogleHadoopFileSystem",\n)\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"related-configurations",children:"Related Configurations"}),"\n",(0,o.jsxs)(n.p,{children:["The following configurations belong to the system-level settings for Broker load, which affect all Broker load import tasks. These configurations can be adjusted by modifying the ",(0,o.jsx)(n.code,{children:"fe.conf "}),"file."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"min_bytes_per_broker_scanner"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Default: 64MB."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The minimum amount of data processed by a single BE in a Broker Load job."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"max_bytes_per_broker_scanner"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Default: 500GB."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The maximum amount of data processed by a single BE in a Broker Load job."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Typically, the maximum supported data volume for an import job is ",(0,o.jsx)(n.code,{children:"max_bytes_per_broker_scanner * the number of BE nodes"}),". If you need to import a larger volume of data, you may need to adjust the size of the ",(0,o.jsx)(n.code,{children:"max_bytes_per_broker_scanner"})," parameter appropriately."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"max_broker_concurrency"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Default: 10."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Limits the maximum concurrency of imports for a job."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The minimum processed data volume, maximum concurrency, size of the source file, and the current number of BE nodes jointly determine the concurrency of this import."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Plain",children:"Import Concurrency = Math.min(Source File Size / min_bytes_per_broker_scanner, max_broker_concurrency, Current Number of BE Nodes * load_parallelism)\nProcessing Volume per BE for this Import = Source File Size / Import Concurrency\n"})}),"\n",(0,o.jsx)(n.h2,{id:"common-issues-1",children:"Common Issues"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["1. Import Error: ",(0,o.jsx)(n.code,{children:"Scan bytes per broker scanner exceed limit:xxx"})]})}),"\n",(0,o.jsxs)(n.p,{children:["Please refer to the best practices section in the documentation and modify the FE configuration items ",(0,o.jsx)(n.code,{children:"max_bytes_per_broker_scanner"})," and ",(0,o.jsx)(n.code,{children:"max_broker_concurrency."})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["2. Import Error: : ",(0,o.jsx)(n.code,{children:"failed to send batch"})," or ",(0,o.jsx)(n.code,{children:"TabletWriter add batch with unknown id"})]})}),"\n",(0,o.jsxs)(n.p,{children:["Appropriately adjust the ",(0,o.jsx)(n.code,{children:"query_timeout"})," and ",(0,o.jsx)(n.code,{children:"streaming_load_rpc_max_alive_time_sec"})," settings."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["3. Import Error: ",(0,o.jsx)(n.code,{children:"LOAD_RUN_FAIL; msg:Invalid Column Name:xxx"})]})}),"\n",(0,o.jsx)(n.p,{children:"For PARQUET or ORC format data, the column names in the file header must match the column names in the Doris table. For example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"(tmp_c1,tmp_c2)\nSET\n(\n    id=tmp_c2,\n    name=tmp_c1\n)\n"})}),"\n",(0,o.jsx)(n.p,{children:"This represents fetching columns named (tmp_c1, tmp_c2) in the parquet or orc file and mapping them to the (id, name) columns in the Doris table. If no set is specified, the columns in the file header will be used for mapping."}),"\n",(0,o.jsx)(n.admonition,{title:"Note",type:"info",children:(0,o.jsx)(n.p,{children:"If ORC files are generated directly using certain Hive versions, the column headers in the ORC file may not be the Hive metadata, but (_col0, _col1, _col2, ...), which may lead to the Invalid Column Name error. In this case, mapping using SET is necessary."})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["5. Import Error: ",(0,o.jsx)(n.code,{children:"Failed to get S3 FileSystem for bucket is null/empty"})]})}),"\n",(0,o.jsxs)(n.p,{children:["The bucket information is incorrect or does not exist. Or the bucket format is not supported. When creating a bucket name with an underscore using GCS, such as ",(0,o.jsx)(n.code,{children:"s3://gs_bucket/load_tbl"}),", the S3 Client may report an error when accessing GCS. It is recommended not to use underscores when creating bucket paths."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"6. Import Timeout"})}),"\n",(0,o.jsx)(n.p,{children:"The default timeout for imports is 4 hours. If a timeout occurs, it is not recommended to directly increase the maximum import timeout to solve the problem. If the single import time exceeds the default import timeout of 4 hours, it is best to split the file to be imported and perform multiple imports to solve the problem. Setting an excessively long timeout time can lead to high costs for retrying failed imports."}),"\n",(0,o.jsx)(n.p,{children:"You can calculate the expected maximum import file data volume for the Doris cluster using the following formula:"}),"\n",(0,o.jsx)(n.p,{children:"Expected Maximum Import File Data Volume = 14400s * 10M/s * Number of BEs"}),"\n",(0,o.jsx)(n.p,{children:"For example, if the cluster has 10 BEs:"}),"\n",(0,o.jsx)(n.p,{children:"Expected Maximum Import File Data Volume = 14400s * 10M/s * 10 = 1440000M \u2248 1440G"}),"\n",(0,o.jsx)(n.admonition,{title:"Note",type:"info",children:(0,o.jsx)(n.p,{children:"In general, user environments may not reach speeds of 10M/s, so it is recommended to split files exceeding 500G before importing."})}),"\n",(0,o.jsx)(n.h2,{id:"more-help",children:"More Help"}),"\n",(0,o.jsxs)(n.p,{children:["For more detailed syntax and best practices for using  ",(0,o.jsx)(n.a,{href:"../../sql-manual/sql-reference/Data-Manipulation-Statements/Load/BROKER-LOAD",children:"Broker Load"})," , please refer to the Broker Load command manual. You can also enter HELP BROKER LOAD in the MySQL client command line to obtain more help information."]})]})}function h(e={}){let{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},172029:function(e,n,s){s.d(n,{Z:function(){return r}});let r=s.p+"assets/images/broker-load-ad8c8c6f730de2066090371965f1ffd5.png"},250065:function(e,n,s){s.d(n,{Z:function(){return a},a:function(){return i}});var r=s(667294);let o={},t=r.createContext(o);function i(e){let n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);