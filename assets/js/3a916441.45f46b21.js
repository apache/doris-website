"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["915335"],{404338:function(e,n,i){i.r(n),i.d(n,{default:()=>h,frontMatter:()=>s,metadata:()=>t,assets:()=>l,toc:()=>d,contentTitle:()=>o});var t=JSON.parse('{"id":"query-acceleration/materialized-view/async-materialized-view/use-guide","title":"Best Practices","description":"Principles for Using Asynchronous Materialized Views","source":"@site/versioned_docs/version-2.1/query-acceleration/materialized-view/async-materialized-view/use-guide.md","sourceDirName":"query-acceleration/materialized-view/async-materialized-view","slug":"/query-acceleration/materialized-view/async-materialized-view/use-guide","permalink":"/docs/2.1/query-acceleration/materialized-view/async-materialized-view/use-guide","draft":false,"unlisted":false,"tags":[],"version":"2.1","frontMatter":{"title":"Best Practices","language":"en"},"sidebar":"docs","previous":{"title":"Creating, Querying, and Maintaining Asynchronous Materialized Views","permalink":"/docs/2.1/query-acceleration/materialized-view/async-materialized-view/functions-and-demands"},"next":{"title":"Use Advice","permalink":"/docs/2.1/query-acceleration/materialized-view/async-materialized-view/use-advice"}}'),a=i("785893"),r=i("250065");let s={title:"Best Practices",language:"en"},o=void 0,l={},d=[{value:"Principles for Using Asynchronous Materialized Views",id:"principles-for-using-asynchronous-materialized-views",level:2},{value:"Principles for Choosing Materialized View Refresh Methods",id:"principles-for-choosing-materialized-view-refresh-methods",level:2},{value:"Common Usage of Partitioned Materialized Views",id:"common-usage-of-partitioned-materialized-views",level:2},{value:"Creating Partitioned Materialized Views with UNION ALL",id:"creating-partitioned-materialized-views-with-union-all",level:2},{value:"Partitioned Materialized Views Retaining Only Recent Partition Data",id:"partitioned-materialized-views-retaining-only-recent-partition-data",level:2},{value:"How to Use Materialized Views to Accelerate Queries",id:"how-to-use-materialized-views-to-accelerate-queries",level:2},{value:"Usage Scenarios",id:"usage-scenarios",level:2},{value:"Scenario One: Query Acceleration",id:"scenario-one-query-acceleration",level:3},{value:"Use Case 1: Multi-table Join Aggregate Query Acceleration",id:"use-case-1-multi-table-join-aggregate-query-acceleration",level:4},{value:"Use Case 2: Log Query Acceleration",id:"use-case-2-log-query-acceleration",level:4},{value:"Scenario Two: Data Modeling (ETL)",id:"scenario-two-data-modeling-etl",level:3},{value:"Scenario Three: Lake-Warehouse Integration Federated Data Query",id:"scenario-three-lake-warehouse-integration-federated-data-query",level:3},{value:"Scenario Four: Improving Write Efficiency, Reducing Resource Contention",id:"scenario-four-improving-write-efficiency-reducing-resource-contention",level:3}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"principles-for-using-asynchronous-materialized-views",children:"Principles for Using Asynchronous Materialized Views"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Timeliness Consideration:"})," Asynchronous materialized views are typically used in scenarios where data timeliness is not critical, usually T+1 data. If high timeliness is required, consider using synchronous materialized views."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Acceleration Effect and Consistency Consideration:"})," In query acceleration scenarios, when creating materialized views, DBAs should group common query SQL patterns, aiming to minimize overlap between groups. The clearer the SQL pattern grouping, the higher the quality of the materialized view construction. A query may use multiple materialized views, and a materialized view may be used by multiple queries. Constructing materialized views requires comprehensive consideration of response time (acceleration effect), construction cost, and data consistency requirements."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Materialized View Definition and Construction Cost Consideration:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The closer the materialized view definition is to the original query, the better the query acceleration effect, but the lower the generality and reusability of the materialization, meaning higher construction costs."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The more general the materialized view definition (e.g., without WHERE conditions and more aggregation dimensions), the lower the query acceleration effect, but the better the generality and reusability of the materialization, meaning lower construction costs."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"caution",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Control of Materialized View Quantity:"})," More materialized views are not necessarily better. Constructing and refreshing materialized views requires resources. Materialized views participate in transparent rewriting, and the CBO cost model needs time to select the optimal materialized view. In theory, the more materialized views, the longer the transparent rewriting time."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Regularly Check the Usage Status of Materialized Views:"})," If not used, they should be deleted in time."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Base Table Data Update Frequency:"})," If the base table data of the materialized view is frequently updated, it may not be suitable to use materialized views, as this will cause the materialized view to frequently become invalid and not usable for transparent rewriting (direct query). If you need to use such materialized views for transparent rewriting, you need to allow a certain timeliness delay in the queried data and can set a ",(0,a.jsx)(n.code,{children:"grace_period"}),". See the applicable introduction of ",(0,a.jsx)(n.code,{children:"grace_period"})," for details."]}),"\n"]}),"\n"]})}),"\n",(0,a.jsx)(n.h2,{id:"principles-for-choosing-materialized-view-refresh-methods",children:"Principles for Choosing Materialized View Refresh Methods"}),"\n",(0,a.jsx)(n.p,{children:"When the following conditions are met, it is recommended to create partitioned materialized views:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The base table data volume of the materialized view is large, and the base table is a partitioned table."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The tables used by the materialized view, except for the partitioned table, do not change frequently."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["The definition SQL of the materialized view and the partition field meet the requirements of partition derivation, that is, meet the requirements of partition incremental update. Detailed requirements can be found in ",(0,a.jsx)(n.a,{href:"../../../sql-manual/sql-statements/table-and-view/async-materialized-view/CREATE-ASYNC-MATERIALIZED-VIEW#optional-parameters",children:"CREATE-ASYNC-MATERIALIZED-VIEW"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The number of partitions in the materialized view is not large, as too many partitions will lead to excessively long partition materialized view construction time."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"When some partitions of the materialized view become invalid, transparent rewriting can use the valid partitions of the materialized view UNION ALL base table to return data."}),"\n",(0,a.jsx)(n.p,{children:"If partitioned materialized views cannot be constructed, you can consider choosing fully refreshed materialized views."}),"\n",(0,a.jsx)(n.h2,{id:"common-usage-of-partitioned-materialized-views",children:"Common Usage of Partitioned Materialized Views"}),"\n",(0,a.jsxs)(n.p,{children:["When the materialized view's base table data volume is large and the base table is a partitioned table, if the materialized view's definition SQL and partition fields meet the requirements of partition derivation, this scenario is suitable for building partitioned materialized views. For detailed requirements of partition derivation, refer to ",(0,a.jsx)(n.a,{href:"../../../sql-manual/sql-statements/table-and-view/async-materialized-view/CREATE-ASYNC-MATERIALIZED-VIEW#optional-parameters",children:"CREATE-ASYNC-MATERIALIZED-VIEW"})," and ",(0,a.jsx)(n.a,{href:"../../../query-acceleration/materialized-view/async-materialized-view/faq#q12-error-when-building-partitioned-materialized-view",children:"Async Materialized View FAQ Building Question 12"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"The materialized view's partitions are created following the base table's partition mapping, generally having a 1:1 or 1:n relationship with the base table's partitions."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"If the base table's partitions undergo data changes, such as adding partitions or deleting partitions, the corresponding partitions in the materialized view will also become invalid. Invalid partitions cannot be used for transparent rewriting but can be directly queried. When transparent rewriting discovers that the materialized view's partition data is invalid, the invalid partitions will be handled by joining with the base table to respond to queries."}),"\n",(0,a.jsxs)(n.p,{children:["For commands to check materialized view partition status, see viewing materialized view status, mainly using the ",(0,a.jsx)(n.code,{children:"show partitions from mv_name"})," command."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["If non-partitioned tables referenced by the materialized view undergo data changes, it will trigger all partitions of the materialized view to become invalid, preventing the materialized view from being used for transparent rewriting. You need to refresh all partition data of the materialized view using the command ",(0,a.jsx)(n.code,{children:"REFRESH MATERIALIZED VIEW mv1 AUTO;"}),". This command will attempt to refresh all partitions of the materialized view where data has changed."]}),"\n",(0,a.jsx)(n.p,{children:"Therefore, it's generally recommended to place frequently changing data in partitioned tables referenced by the partitioned materialized view, and place infrequently changing dimension tables in non-referenced partition table positions."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["If non-partitioned tables referenced by the materialized view undergo data changes, and the non-partitioned table data is only being added without modifications, you can specify the attribute ",(0,a.jsx)(n.code,{children:"excluded_trigger_tables = 'non_partition_table_name1,non_partition_table_name2'"})," when creating the materialized view. This way, data changes in non-partitioned tables won't invalidate all partitions of the materialized view, and the next refresh will only refresh the invalid partitions of the materialized view corresponding to the partition table."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Transparent rewriting of partitioned materialized views is at the partition granularity. Even if some partitions of the materialized view become invalid, the materialized view can still be used for transparent rewriting. However, if only one partition is queried and that partition's data in the materialized view is invalid, then the materialized view cannot be used for transparent rewriting."}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS lineitem (\n    l_orderkey INTEGER NOT NULL, \n    l_partkey INTEGER NOT NULL, \n    l_suppkey INTEGER NOT NULL, \n    l_linenumber INTEGER NOT NULL, \n    l_ordertime DATETIME NOT NULL, \n    l_quantity DECIMALV3(15, 2) NOT NULL, \n    l_extendedprice DECIMALV3(15, 2) NOT NULL, \n    l_discount DECIMALV3(15, 2) NOT NULL, \n    l_tax DECIMALV3(15, 2) NOT NULL, \n    l_returnflag CHAR(1) NOT NULL, \n    l_linestatus CHAR(1) NOT NULL, \n    l_shipdate DATE NOT NULL, \n    l_commitdate DATE NOT NULL, \n    l_receiptdate DATE NOT NULL, \n    l_shipinstruct CHAR(25) NOT NULL, \n    l_shipmode CHAR(10) NOT NULL, \n    l_comment VARCHAR(44) NOT NULL\n  ) DUPLICATE KEY(\n    l_orderkey, l_partkey, l_suppkey, \n    l_linenumber\n  ) PARTITION BY RANGE(l_ordertime) (\n    FROM \n      ('2024-05-01') TO ('2024-06-30') INTERVAL 1 DAY\n  )\nDISTRIBUTED BY HASH(l_orderkey) BUCKETS 3;\n\nINSERT INTO lineitem VALUES      \n(1, 2, 3, 4, '2024-05-01 01:45:05', 5.5, 6.5, 0.1, 8.5, 'o', 'k', '2024-05-01', '2024-05-01', '2024-05-01', 'a', 'b', 'yyyyyyyyy'),    \n(1, 2, 3, 4, '2024-05-15 02:35:05', 5.5, 6.5, 0.15, 8.5, 'o', 'k', '2024-05-15', '2024-05-15', '2024-05-15', 'a', 'b', 'yyyyyyyyy'),     \n(2, 2, 3, 5, '2024-05-25 08:30:06', 5.5, 6.5, 0.2, 8.5, 'o', 'k', '2024-05-25', '2024-05-25', '2024-05-25', 'a', 'b', 'yyyyyyyyy'),     \n(3, 4, 3, 6, '2024-06-02 09:25:07', 5.5, 6.5, 0.3, 8.5, 'o', 'k', '2024-06-02', '2024-06-02', '2024-06-02', 'a', 'b', 'yyyyyyyyy'),     \n(4, 4, 3, 7, '2024-06-15 13:20:09', 5.5, 6.5, 0, 8.5, 'o', 'k', '2024-06-15', '2024-06-15', '2024-06-15', 'a', 'b', 'yyyyyyyyy'),     \n(5, 5, 6, 8, '2024-06-25 15:15:36', 5.5, 6.5, 0.12, 8.5, 'o', 'k', '2024-06-25', '2024-06-25', '2024-06-25', 'a', 'b', 'yyyyyyyyy'),     \n(5, 5, 6, 9, '2024-06-29 21:10:52', 5.5, 6.5, 0.1, 8.5, 'o', 'k', '2024-06-30', '2024-06-30', '2024-06-30', 'a', 'b', 'yyyyyyyyy'),     \n(5, 6, 5, 10, '2024-06-03 22:05:50', 7.5, 8.5, 0.1, 10.5, 'k', 'o', '2024-06-03', '2024-06-03', '2024-06-03', 'c', 'd', 'xxxxxxxxx');     \n  \nCREATE TABLE IF NOT EXISTS partsupp (\n    ps_partkey INTEGER NOT NULL, \n    ps_suppkey INTEGER NOT NULL, \n    ps_availqty INTEGER NOT NULL, \n    ps_supplycost DECIMALV3(15, 2) NOT NULL, \n    ps_comment VARCHAR(199) NOT NULL\n  )\nDUPLICATE KEY(ps_partkey, ps_suppkey)\nDISTRIBUTED BY HASH(ps_partkey) BUCKETS 3;\n\n\nINSERT INTO partsupp VALUES     \n(2, 3, 9, 10.01, 'supply1'),     \n(4, 3, 9, 10.01, 'supply2'),     \n(5, 6, 9, 10.01, 'supply3'),     \n(6, 5, 10, 11.01, 'supply4');\n"})}),"\n",(0,a.jsx)(n.p,{children:'In this example, the o_ordertime field in the orders table is the partition field, with type DATETIME, partitioned by day.\nThe main query is based on a "day" granularity:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT \n  l_linestatus, \n  sum(\n    l_extendedprice * (1 - l_discount)\n  ) AS revenue, \n  ps_partkey \nFROM \n  lineitem \n  LEFT JOIN partsupp ON l_partkey = ps_partkey \n  and l_suppkey = ps_suppkey \nWHERE \n  date_trunc(l_ordertime, 'day') <= DATE '2024-05-25' \n  AND date_trunc(l_ordertime, 'day') >= DATE '2024-05-05' \nGROUP BY \n  l_linestatus, \n  ps_partkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:'To avoid refreshing too many partitions each time in the materialized view, the partition granularity can be consistent with the base table orders, also partitioning by "day".'}),"\n",(0,a.jsx)(n.p,{children:'The materialized view\'s definition SQL can use "day" granularity and aggregate data by "day":'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW rollup_partition_mv \nBUILD IMMEDIATE REFRESH AUTO ON MANUAL \npartition by(order_date) \nDISTRIBUTED BY RANDOM BUCKETS 2 \nAS \nSELECT \n  l_linestatus, \n  sum(\n    l_extendedprice * (1 - l_discount)\n  ) AS revenue, \n  ps_partkey, \n  date_trunc(l_ordertime, 'day') as order_date \nFROM \n  lineitem \n  LEFT JOIN partsupp ON l_partkey = ps_partkey \n  and l_suppkey = ps_suppkey \nGROUP BY \n  l_linestatus, \n  ps_partkey, \n  date_trunc(l_ordertime, 'day');\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-partitioned-materialized-views-with-union-all",children:"Creating Partitioned Materialized Views with UNION ALL"}),"\n",(0,a.jsx)(n.p,{children:"Currently, Doris has a limitation where partitioned materialized view definitions cannot contain UNION ALL clauses.\nTo create a materialized view that includes UNION ALL, you can use the following approach: For each input part of the UNION ALL,\nattempt to create a partitioned materialized view, and then create a regular view for the entire UNION ALL result set."}),"\n",(0,a.jsx)(n.p,{children:"For example:\nThe materialized view definition below contains a UNION ALL clause, which cannot be directly used to create a partitioned materialized view."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\nSELECT\nl_linestatus,\nsum(\nl_extendedprice * (1 - l_discount)\n) AS revenue,\nps_partkey,\ndate_trunc(l_ordertime, 'day') as order_date\nFROM\nlineitem\nLEFT JOIN partsupp ON l_partkey = ps_partkey\nand l_suppkey = ps_suppkey\nGROUP BY\nl_linestatus,\nps_partkey,\ndate_trunc(l_ordertime, 'day')\nUNION ALL\nSELECT\nl_linestatus,\nl_extendedprice,\nps_partkey,\ndate_trunc(l_ordertime, 'day') as order_date\nFROM\nlineitem\nLEFT JOIN partsupp ON l_partkey = ps_partkey\nand l_suppkey = ps_suppkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can split the above SQL statement into two parts and create two partitioned materialized views separately."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"\nCREATE MATERIALIZED VIEW union_sub_mv1\nBUILD IMMEDIATE REFRESH AUTO ON MANUAL\npartition by(order_date)\nDISTRIBUTED BY RANDOM BUCKETS 2\nAS\nSELECT\nl_linestatus,\nsum(\nl_extendedprice * (1 - l_discount)\n) AS revenue,\nps_partkey,\ndate_trunc(l_ordertime, 'day') as order_date\nFROM\nlineitem\nLEFT JOIN partsupp ON l_partkey = ps_partkey\nand l_suppkey = ps_suppkey\nGROUP BY\nl_linestatus,\nps_partkey,\ndate_trunc(l_ordertime, 'day');\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW union_sub_mv2\nBUILD IMMEDIATE REFRESH AUTO ON MANUAL\npartition by(order_date)\nDISTRIBUTED BY RANDOM BUCKETS 2\nAS\nSELECT\nl_linestatus,\nl_extendedprice,\nps_partkey,\ndate_trunc(l_ordertime, 'day') as order_date\nFROM\nlineitem\nLEFT JOIN partsupp ON l_partkey = ps_partkey\nand l_suppkey = ps_suppkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then create a regular view that performs UNION ALL on the result sets of the two partitioned materialized views.\nThis view (union_all_view) can be exposed externally."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE VIEW union_all_view\nAS\nSELECT *\nFROM\nunion_sub_mv1\nUNION ALL\nSELECT *\nFROM\nunion_sub_mv2;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"partitioned-materialized-views-retaining-only-recent-partition-data",children:"Partitioned Materialized Views Retaining Only Recent Partition Data"}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"tip",children:(0,a.jsx)(n.p,{children:"This feature has been supported since Apache Doris version 2.1.1."})}),"\n",(0,a.jsx)(n.p,{children:"Materialized views can be configured to retain data only from the most recent partitions, automatically deleting expired partition data during each refresh.\nThis can be achieved by setting the following properties for the materialized view:\npartition_sync_limit, partition_sync_time_unit, and partition_sync_date_format."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"partition_sync_limit"}),": When the base table's partition field is time-based, this property configures the synchronization range for base table partitions, working in conjunction with partition_sync_time_unit. For example, setting it to 3 with partition_sync_time_unit as DAY means only partitions and data from the last 3 days of the base table will be synchronized."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"partition_sync_time_unit"}),": The time unit for partition refresh, supporting DAY/MONTH/YEAR (default is DAY)."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"partition_date_format"}),": When the base table's partition field is a string type, this property sets the date format if you want to use the partition_sync_limit capability."]}),"\n",(0,a.jsx)(n.p,{children:"Example:\nThe materialized view defined below will only retain data from the last 3 days. If there's no data in the recent 3 days, querying this materialized view directly will return no results."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'CREATE MATERIALIZED VIEW latest_partition_mv\nBUILD IMMEDIATE REFRESH AUTO ON MANUAL\nPARTITION BY(order_date)\nDISTRIBUTED BY RANDOM BUCKETS 2\nPROPERTIES (\n"partition_sync_limit" = "3",\n"partition_sync_time_unit" = "DAY",\n"partition_date_format" = "yyyy-MM-dd"\n)       \nAS\nSELECT\nl_linestatus,\nsum(\nl_extendedprice * (1 - l_discount)\n) AS revenue,\nps_partkey,\ndate_trunc(l_ordertime, \'day\') as order_date\nFROM\nlineitem\nLEFT JOIN partsupp ON l_partkey = ps_partkey\nAND l_suppkey = ps_suppkey\nGROUP BY\nl_linestatus,\nps_partkey,\ndate_trunc(l_ordertime, \'day\');\n'})}),"\n",(0,a.jsx)(n.h2,{id:"how-to-use-materialized-views-to-accelerate-queries",children:"How to Use Materialized Views to Accelerate Queries"}),"\n",(0,a.jsx)(n.p,{children:"To use materialized views for query acceleration, first check the profile file to find the operation that consumes the most time in a query, which usually appears in Join, Aggregate, Filter, or Calculated Expressions."}),"\n",(0,a.jsx)(n.p,{children:"For Join, Aggregate, Filters, and Calculated Expressions, building materialized views can help accelerate queries. If a Join operation in a query consumes a large amount of computing resources while Aggregate consumes relatively fewer resources, you can build materialized views targeting the Join operation."}),"\n",(0,a.jsx)(n.p,{children:"Next, we'll explain in detail how to build materialized views for these four operations:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"For Join"})}),"\n",(0,a.jsx)(n.p,{children:"You can extract common table join patterns used in queries to build materialized views. If transparent rewriting uses this materialized view, it can save Join computation. Remove the Filters from the query to create a more general Join materialized view."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"For Aggregate"})}),"\n",(0,a.jsx)(n.p,{children:"It is recommended to use low-cardinality fields as dimensions when building materialized views. If the dimensions are related, the number after aggregation can be reduced as much as possible."}),"\n",(0,a.jsxs)(n.p,{children:["For example, with table t1, if the original table has 1,000,000 records, and the SQL query has ",(0,a.jsx)(n.code,{children:"group by a, b, c"}),". If the cardinality of a, b, c is 100, 50, and 15 respectively, then the aggregated data would be around 75,000, indicating that this materialized view is effective. If a, b, c are correlated, the amount of aggregated data will be further reduced."]}),"\n",(0,a.jsx)(n.p,{children:"If a, b, c have high cardinality, it will cause the aggregated data to expand rapidly. If the aggregated data is more than the original table data, this scenario might not be suitable for building materialized views. For example, if c's cardinality is 3,500, then the aggregated data would be around 17,000,000, much larger than the original table data, making the performance acceleration benefit of building such a materialized view low."}),"\n",(0,a.jsx)(n.p,{children:"The aggregation granularity of the materialized view should be finer than the query, meaning the aggregation dimensions of the materialized view should include the query's aggregation dimensions to provide the data needed by the query. The query may not write Group By, and similarly, the aggregation functions of the materialized view should include the query's aggregation functions."}),"\n",(0,a.jsx)(n.p,{children:"Taking aggregate query acceleration as an example:"}),"\n",(0,a.jsx)(n.p,{children:"Query 1:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT \n  l_linestatus, \n  sum(\n    l_extendedprice * (1 - l_discount)\n  ) AS revenue, \n  o_shippriority \nFROM \n  orders \n  LEFT JOIN lineitem ON l_orderkey = o_orderkey \nWHERE \n  o_orderdate <= DATE '2024-06-30' \n  AND o_orderdate >= DATE '2024-05-01' \nGROUP BY \n  l_linestatus, \n  o_shippriority,\n  l_partkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Query 2:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT \n  l_linestatus, \n  sum(\n    l_extendedprice * (1 - l_discount)\n  ) AS revenue, \n  o_shippriority \nFROM \n  orders \n  LEFT JOIN lineitem ON l_orderkey = o_orderkey \nWHERE \n  o_orderdate <= DATE '2024-06-30' \n  AND o_orderdate >= DATE '2024-05-01' \nGROUP BY \n  l_linestatus, \n  o_shippriority,\n  l_suppkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Based on the above two SQL queries, we can build a more general materialized view that includes Aggregate. In this materialized view, we include both l_partkey and l_suppkey as group by dimensions for aggregation, and use o_orderdate as a filter condition. Note that o_orderdate is not only used in the materialized view's condition compensation but also needs to be included in the materialized view's aggregation group by dimensions."}),"\n",(0,a.jsx)(n.p,{children:"After building the materialized view this way, both Query 1 and Query 2 can hit this materialized view. The materialized view definition is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW common_agg_mv\nBUILD IMMEDIATE REFRESH AUTO ON MANUAL\nDISTRIBUTED BY RANDOM BUCKETS 2\nAS \nSELECT \n  l_linestatus, \n  sum(\n    l_extendedprice * (1 - l_discount)\n  ) AS revenue, \n  o_shippriority,\n  l_suppkey,\n  l_partkey,\n  o_orderdate\nFROM \n  orders \n  LEFT JOIN lineitem ON l_orderkey = o_orderkey \nGROUP BY \n  l_linestatus, \n  o_shippriority,\n  l_suppkey,\n  l_partkey,\n  o_orderdate;\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"For Filter"})}),"\n",(0,a.jsx)(n.p,{children:"If filters on the same fields frequently appear in queries, adding corresponding Filters in the materialized view can reduce the amount of data in the materialized view, thereby improving the performance when queries hit the materialized view."}),"\n",(0,a.jsxs)(n.p,{children:["Note that the materialized view should have fewer Filters than those appearing in queries, and the query's Filters should include the materialized view's Filters. For example, if the query is ",(0,a.jsx)(n.code,{children:"a > 10 and b > 5"}),", the materialized view can have no Filter, or if it has Filters, it should filter on a and b with a larger data range than the query, such as ",(0,a.jsx)(n.code,{children:"a > 5 and b > 5"}),", ",(0,a.jsx)(n.code,{children:"b > 0"}),", or just ",(0,a.jsx)(n.code,{children:"a > 5"}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"4. For Calculated Expressions"})}),"\n",(0,a.jsx)(n.p,{children:"Taking examples like case when and string processing functions, these expression calculations are very performance-intensive. If these can be pre-calculated in the materialized view, using the pre-calculated materialized view through transparent rewriting can improve query performance."}),"\n",(0,a.jsx)(n.p,{children:"It is recommended that the number of columns in the materialized view should not be too many. If a query uses multiple fields, you should build corresponding materialized views for different columns based on the initial SQL pattern grouping, avoiding too many columns in a single materialized view."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"usage-scenarios",children:"Usage Scenarios"}),"\n",(0,a.jsx)(n.h3,{id:"scenario-one-query-acceleration",children:"Scenario One: Query Acceleration"}),"\n",(0,a.jsx)(n.p,{children:"In BI reporting scenarios or other acceleration scenarios, users are sensitive to query response times and typically require results to be returned in seconds. Queries usually involve multiple table joins followed by aggregate calculations, which consume significant computing resources and sometimes make it difficult to guarantee timeliness. Asynchronous materialized views can handle this well, supporting both direct queries and transparent rewriting, where the optimizer automatically selects the optimal materialized view to respond to requests based on rewriting algorithms and cost models."}),"\n",(0,a.jsx)(n.h4,{id:"use-case-1-multi-table-join-aggregate-query-acceleration",children:"Use Case 1: Multi-table Join Aggregate Query Acceleration"}),"\n",(0,a.jsx)(n.p,{children:"Building more general materialized views can accelerate multi-table join aggregate queries."}),"\n",(0,a.jsx)(n.p,{children:"Taking the following three query SQLs as examples:"}),"\n",(0,a.jsx)(n.p,{children:"Query 1:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT \n  l_linestatus, \n  l_extendedprice * (1 - l_discount)\n  o_shippriority \nFROM \n  orders \n  LEFT JOIN lineitem ON l_orderkey = o_orderkey \nWHERE \n  o_orderdate <= DATE '2024-06-30' \n  AND o_orderdate >= DATE '2024-05-01';\n"})}),"\n",(0,a.jsx)(n.p,{children:"Query 2:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT \n  l_linestatus, \n  sum(\n    l_extendedprice * (1 - l_discount)\n  ) AS revenue, \n  o_orderdate, \n  o_shippriority \nFROM \n  orders \n  LEFT JOIN lineitem ON l_orderkey = o_orderkey \nWHERE \n  o_orderdate <= DATE '2024-06-30' \n  AND o_orderdate >= DATE '2024-05-01' \nGROUP BY \n  l_linestatus, \n  o_orderdate, \n  o_shippriority;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Query 3:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT \n  l_linestatus, \n  l_extendedprice * (1 - l_discount),\n  o_orderdate, \n  o_shippriority \nFROM \n  orders \n  LEFT JOIN lineitem ON l_orderkey = o_orderkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:"For the above queries, we can build the following materialized view to satisfy all the above queries."}),"\n",(0,a.jsxs)(n.p,{children:["The materialized view definition removes the filter conditions from Query 1 and Query 2 to get a more general Join, and pre-calculates the expression ",(0,a.jsx)(n.code,{children:"l_extendedprice * (1 - l_discount)"}),", so when queries hit the materialized view, it can save expression calculation:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW common_join_mv\nBUILD IMMEDIATE REFRESH AUTO ON MANUAL\nDISTRIBUTED BY RANDOM BUCKETS 2\nAS \nSELECT \n  l_linestatus, \n  l_extendedprice * (1 - l_discount),\n  o_orderdate, \n  o_shippriority \nFROM \n  orders \n  LEFT JOIN lineitem ON l_orderkey = o_orderkey;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If the above materialized view cannot meet the acceleration performance requirements of Query 2, we can build an aggregate materialized view. To maintain generality, we can remove the filter condition on the ",(0,a.jsx)(n.code,{children:"o_orderdate"})," field:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW target_agg_mv\nBUILD IMMEDIATE REFRESH AUTO ON MANUAL\nDISTRIBUTED BY RANDOM BUCKETS 2\nAS \nSELECT \n  l_linestatus, \n  sum(\n    l_extendedprice * (1 - l_discount)\n  ) AS revenue, \n  o_orderdate, \n  o_shippriority \nFROM \n  orders \n  LEFT JOIN lineitem ON l_orderkey = o_orderkey \nGROUP BY \n  l_linestatus, \n  o_orderdate, \n  o_shippriority;\n"})}),"\n",(0,a.jsx)(n.h4,{id:"use-case-2-log-query-acceleration",children:"Use Case 2: Log Query Acceleration"}),"\n",(0,a.jsx)(n.p,{children:"In log query acceleration scenarios, it is recommended not to limit yourself to using only asynchronous materialized views; they can be combined with synchronous materialized views."}),"\n",(0,a.jsx)(n.p,{children:"Generally, the base table is a partitioned table, mostly partitioned by hour, with single-table aggregate queries, and filter conditions are usually based on time and some flag bits. Sometimes when query response speed cannot meet requirements, synchronous materialized views can usually be built for acceleration."}),"\n",(0,a.jsx)(n.p,{children:"For example, the base table definition might be as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS test (\n`app_name` VARCHAR(64) NULL COMMENT 'identifier', \n`event_id` VARCHAR(128) NULL COMMENT 'identifier', \n`decision` VARCHAR(32) NULL COMMENT 'enum value', \n`time` DATETIME NULL COMMENT 'query time', \n`id` VARCHAR(35) NOT NULL COMMENT 'od', \n`code` VARCHAR(64) NULL COMMENT 'identifier', \n`event_type` VARCHAR(32) NULL COMMENT 'event type' \n)\nDUPLICATE KEY(app_name, event_id)\nPARTITION BY RANGE(time)                                    \n(                                                                                                                                      \n    FROM (\"2024-07-01 00:00:00\") TO (\"2024-07-15 00:00:00\") INTERVAL 1 HOUR                                                                     \n)     \nDISTRIBUTED BY HASH(event_id)\nBUCKETS 3;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The materialized view can aggregate data by minute, which can also achieve a certain aggregation effect. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW sync_mv\n    AS\n    SELECT \n      decision,\n      code, \n      app_name, \n      event_id, \n      event_type, \n      date_trunc(time, 'minute'), \n      DATE_FORMAT(\n        `time`, '%Y-%m-%d'\n      ), \n      cast(FLOOR(MINUTE(time) / 15) as decimal(9, 0)),\n      count(id) as cnt\n    from \n      test \n    group by \n      code, \n      app_name, \n      event_id, \n      event_type, \n      date_trunc(time, 'minute'), \n      decision, \n      DATE_FORMAT(time, '%Y-%m-%d'), \n      cast(FLOOR(MINUTE(`time`) / 15) as decimal(9, 0));\n"})}),"\n",(0,a.jsx)(n.p,{children:"The query statement might be as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT \n    decision, \n    CONCAT(\n        CONCAT(\n          DATE_FORMAT(\n            `time`, '%Y-%m-%d'\n          ), \n          '', \n          LPAD(\n            cast(FLOOR(MINUTE(`time`) / 15) as decimal(9, 0)) * 15, \n            5, \n            '00'\n          ), \n          ':00'\n        )\n      ) as time, \n      count(id) as cnt \n    from \n      test \n    where \n    date_trunc(time, 'minute') BETWEEN '2024-07-02 18:00:00' \n      AND '2024-07-03 20:00:00' \n    group by \n      decision, \n      DATE_FORMAT(\n        `time`, \"%Y-%m-%d\"\n      ), \n      cast(FLOOR(MINUTE(`time`) / 15) as decimal(9, 0));\n"})}),"\n",(0,a.jsx)(n.h3,{id:"scenario-two-data-modeling-etl",children:"Scenario Two: Data Modeling (ETL)"}),"\n",(0,a.jsx)(n.p,{children:"Data analysis work often requires joining and aggregating multiple tables, a process that typically involves complex and frequently repeated queries. These types of queries may lead to high query latency or high resource consumption issues. However, if using asynchronous materialized views to build layered data models, these problems can be well avoided. You can create higher-level materialized views based on existing materialized views (supported since version 2.1.3), flexibly meeting different requirements."}),"\n",(0,a.jsx)(n.p,{children:"Different levels of materialized views can be set with their own trigger methods, for example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The first layer of materialized views can be set to refresh periodically, and the second layer set to trigger refresh. This way, when the first layer of materialized views completes refreshing, it will automatically trigger the refresh of the second layer materialized views."}),"\n",(0,a.jsx)(n.li,{children:"If each layer of materialized views is set to refresh periodically, then when the second layer materialized view refreshes, it won't consider whether the first layer's materialized view data is synchronized with the base table, it will just process the first layer's materialized view data and synchronize it to the second layer."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Next, we'll use the TPC-H dataset to illustrate the application of asynchronous materialized views in data modeling, taking the analysis of monthly order quantities and profits by region and country as an example:"}),"\n",(0,a.jsx)(n.p,{children:"Original query (without using materialized views):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT\nn_name,\ndate_trunc(o.o_orderdate, 'month') as month,\ncount(distinct o.o_orderkey) as order_count,\nsum(l.l_extendedprice * (1 - l.l_discount)) as revenue\nFROM orders o\nJOIN lineitem l ON o.o_orderkey = l.l_orderkey\nJOIN customer c ON o.o_custkey = c.c_custkey\nJOIN nation n ON c.c_nationkey = n.n_nationkey\nJOIN region r ON n.n_regionkey = r.r_regionkey\nGROUP BY n_name, month;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Using asynchronous materialized views for layered modeling:"}),"\n",(0,a.jsx)(n.p,{children:"Build DWD layer (detailed data), process order detail wide table"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW dwd_order_detail\nBUILD IMMEDIATE REFRESH AUTO ON COMMIT\nDISTRIBUTED BY RANDOM BUCKETS 16\nAS\nselect\no.o_orderkey,\no.o_custkey,\no.o_orderstatus,\no.o_totalprice,\no.o_orderdate,\nc.c_name,\nc.c_nationkey,\nn.n_name as nation_name,\nr.r_name as region_name,\nl.l_partkey,\nl.l_quantity,\nl.l_extendedprice,\nl.l_discount,\nl.l_tax\nfrom orders o\njoin customer c on o.o_custkey = c.c_custkey\njoin nation n on c.c_nationkey = n.n_nationkey\njoin region r on n.n_regionkey = r.r_regionkey\njoin lineitem l on o.o_orderkey = l.l_orderkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Build DWS layer (summary data), perform daily order summary"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW dws_daily_sales\nBUILD IMMEDIATE REFRESH AUTO ON COMMIT\nDISTRIBUTED BY RANDOM BUCKETS 16\nAS\nselect\ndate_trunc(o_orderdate, 'month') as month,\nnation_name,\nregion_name,\nbitmap_union(to_bitmap(o_orderkey)) as order_count,\nsum(l_extendedprice * (1 - l_discount)) as net_revenue\nfrom dwd_order_detail\ngroup by\ndate_trunc(o_orderdate, 'month'),\nnation_name,\nregion_name;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The optimized query using materialized views is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT\nnation_name,\nmonth,\nbitmap_union_count(order_count),\nsum(net_revenue) as revenue\nFROM dws_daily_sales\nGROUP BY nation_name, month;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"scenario-three-lake-warehouse-integration-federated-data-query",children:"Scenario Three: Lake-Warehouse Integration Federated Data Query"}),"\n",(0,a.jsx)(n.p,{children:"In modern data architectures, enterprises often adopt a lake-warehouse integration design to balance data storage costs and query performance. Under this architecture, two key challenges are frequently encountered:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Limited Query Performance: When frequently querying data from data lakes, performance may be affected by network latency and third-party services, leading to query delays and impacting user experience."}),"\n",(0,a.jsx)(n.li,{children:"Complexity of Data Layer Modeling: In the data flow and transformation process from data lake to real-time data warehouse, complex ETL processes are usually required, which increases maintenance costs and development difficulty."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Using Doris asynchronous materialized views can effectively address these challenges:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Transparent Rewriting Accelerates Queries: Materialize commonly used data lake query results into Doris internal storage, using transparent rewriting to effectively improve query performance."}),"\n",(0,a.jsx)(n.li,{children:"Simplify Layer Modeling: Support creating materialized views based on tables in the data lake, enabling convenient transformation from data lake to real-time data warehouse, greatly simplifying the data modeling process."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For example, using Hive:"}),"\n",(0,a.jsx)(n.p,{children:"Create Catalog based on Hive, using TPC-H dataset"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE CATALOG hive_catalog PROPERTIES (\n'type'='hms', -- hive meta store address\n'hive.metastore.uris' = 'thrift://172.21.0.1:7004'\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Create materialized view based on Hive Catalog"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"-- Materialized views can only be created on internal catalog, switch to internal catalog\nswitch internal;\ncreate database hive_mv_db;\nuse hive_mv_db;\n\nCREATE MATERIALIZED VIEW external_hive_mv\nBUILD IMMEDIATE REFRESH AUTO ON MANUAL\nDISTRIBUTED BY RANDOM BUCKETS 12\nAS\nSELECT\nn_name,\no_orderdate,\nsum(l_extendedprice * (1 - l_discount)) AS revenue\nFROM\ncustomer,\norders,\nlineitem,\nsupplier,\nnation,\nregion\nWHERE\nc_custkey = o_custkey\nAND l_orderkey = o_orderkey\nAND l_suppkey = s_suppkey\nAND c_nationkey = s_nationkey\nAND s_nationkey = n_nationkey\nAND n_regionkey = r_regionkey\nAND r_name = 'ASIA'\nGROUP BY\nn_name,\no_orderdate;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Run the following query, which will automatically use the materialized view for acceleration through transparent rewriting."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT\nn_name,\nsum(l_extendedprice * (1 - l_discount)) AS revenue\nFROM\ncustomer,\norders,\nlineitem,\nsupplier,\nnation,\nregion\nWHERE\nc_custkey = o_custkey\nAND l_orderkey = o_orderkey\nAND l_suppkey = s_suppkey\nAND c_nationkey = s_nationkey\nAND s_nationkey = n_nationkey\nAND n_regionkey = r_regionkey\nAND r_name = 'ASIA'\nAND o_orderdate >= DATE '1994-01-01'\nAND o_orderdate < DATE '1994-01-01' + INTERVAL '1' YEAR\nGROUP BY\nn_name\nORDER BY\nrevenue DESC;\n"})}),"\n",(0,a.jsxs)(n.admonition,{title:"Note",type:"tip",children:[(0,a.jsx)(n.p,{children:"Doris currently cannot detect data changes in external tables other than Hive. When external table data is inconsistent, using materialized views may result in data inconsistency. The following switch indicates: whether materialized views participating in transparent rewriting are allowed to include external tables, default false. If you accept data inconsistency or ensure external table data consistency through periodic refresh, you can set this switch to true.\nSet whether materialized views containing external tables can be used for transparent rewriting, default not allowed, if you can accept data inconsistency or can ensure data consistency yourself, you can enable"}),(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"SET materialized_view_rewrite_enable_contain_external_table = true;"})}),(0,a.jsx)(n.p,{children:"If the materialized view is in MaterializedViewRewriteSuccessButNotChose status, it means the rewrite was successful but the plan was not chosen by CBO, possibly due to incomplete statistics of external tables.\nEnable getting row count from file list for statistics"}),(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"SET enable_get_row_count_from_file_list = true;"})}),(0,a.jsx)(n.p,{children:"View external table statistics to confirm if they are complete"}),(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"SHOW TABLE STATS external_table_name;"})})]}),"\n",(0,a.jsx)(n.h3,{id:"scenario-four-improving-write-efficiency-reducing-resource-contention",children:"Scenario Four: Improving Write Efficiency, Reducing Resource Contention"}),"\n",(0,a.jsx)(n.p,{children:"In high-throughput data write scenarios, system stability and efficient data processing are equally important. Through the flexible refresh strategies of asynchronous materialized views, users can choose appropriate refresh methods based on specific scenarios, thereby reducing write pressure and avoiding resource contention."}),"\n",(0,a.jsx)(n.p,{children:"Compared to synchronous materialized views, asynchronous materialized views provide three flexible refresh strategies: manual trigger, trigger-based, and periodic trigger. Users can choose suitable refresh strategies based on scenario requirements. When base table data changes, it won't immediately trigger materialized view refresh, and delayed refresh helps reduce resource pressure, effectively avoiding write resource contention."}),"\n",(0,a.jsx)(n.p,{children:"As shown below, the chosen refresh method is periodic refresh, refreshing every 2 hours. When orders and lineitem import data, it won't immediately trigger materialized view refresh."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW common_schedule_join_mv\nBUILD IMMEDIATE REFRESH AUTO ON SCHEDULE EVERY 2 HOUR\nDISTRIBUTED BY RANDOM BUCKETS 16\nAS\nSELECT\nl_linestatus,\nl_extendedprice * (1 - l_discount),\no_orderdate,\no_shippriority\nFROM\norders\nLEFT JOIN lineitem ON l_orderkey = o_orderkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Transparent rewriting can rewrite query SQL and achieve query acceleration, while also being able to rewrite import SQL to improve import efficiency. Starting from version 2.1.6, when materialized view and base table data are strongly consistent, DML operations like Insert Into or Insert Overwrite can be transparently rewritten, which significantly improves performance for data import scenarios."}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Create target table for Insert Into data"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE IF NOT EXISTS target_table  (\norderdate      DATE NOT NULL,\nshippriority   INTEGER NOT NULL,\nlinestatus     CHAR(1) NOT NULL,\nsale           DECIMALV3(15,2) NOT NULL\n)\nDUPLICATE KEY(orderdate, shippriority)\nDISTRIBUTED BY HASH(shippriority) BUCKETS 3;\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:"common_schedule_join_mv"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE MATERIALIZED VIEW common_schedule_join_mv\nBUILD IMMEDIATE REFRESH AUTO ON SCHEDULE EVERY 2 HOUR\nDISTRIBUTED BY RANDOM BUCKETS 16\nAS\nSELECT\nl_linestatus,\nl_extendedprice * (1 - l_discount),\no_orderdate,\no_shippriority\nFROM\norders\nLEFT JOIN lineitem ON l_orderkey = o_orderkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Import statement before rewriting:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"INSERT INTO target_table\nSELECT\no_orderdate,\no_shippriority,\nl_linestatus,\nl_extendedprice * (1 - l_discount)\nFROM\norders\nLEFT JOIN lineitem ON l_orderkey = o_orderkey;\n"})}),"\n",(0,a.jsx)(n.p,{children:"After transparent rewriting, the statement becomes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"INSERT INTO target_table\nSELECT *\nFROM common_schedule_join_mv;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Note that: If the DML operation involves external tables whose data changes cannot be detected, transparent rewriting may cause the latest base table data to not be imported into the target table in real-time. If users can accept data inconsistency or can ensure data consistency themselves, they can enable the following switch:"}),"\n",(0,a.jsx)(n.p,{children:"For DML, when the materialized view contains external tables whose data cannot be detected in real-time, whether to enable materialized view transparent rewriting based on structure information, default disabled"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"SET enable_dml_materialized_view_rewrite_when_base_table_unawareness = true;"})})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return o},a:function(){return s}});var t=i(667294);let a={},r=t.createContext(a);function s(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);