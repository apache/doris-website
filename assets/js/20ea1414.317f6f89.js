"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["291178"],{650734:function(e,t,n){n.r(t),n.d(t,{default:()=>h,frontMatter:()=>r,metadata:()=>i,assets:()=>l,toc:()=>c,contentTitle:()=>s});var i=JSON.parse('{"id":"table-design/data-partitioning/auto-partitioning","title":"Auto Partition","description":"The Auto Partition feature supports automatic detection of whether the corresponding partition exists during the data import process.","source":"@site/versioned_docs/version-4.x/table-design/data-partitioning/auto-partitioning.md","sourceDirName":"table-design/data-partitioning","slug":"/table-design/data-partitioning/auto-partitioning","permalink":"/docs/4.x/table-design/data-partitioning/auto-partitioning","draft":false,"unlisted":false,"tags":[],"version":"4.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Auto Partition","language":"en","description":"The Auto Partition feature supports automatic detection of whether the corresponding partition exists during the data import process."},"sidebar":"docs","previous":{"title":"Dynamic Partitioning(Outdated)","permalink":"/docs/4.x/table-design/data-partitioning/dynamic-partitioning"},"next":{"title":"Data Bucketing","permalink":"/docs/4.x/table-design/data-partitioning/data-bucketing"}}'),a=n("785893"),o=n("250065");let r={title:"Auto Partition",language:"en",description:"The Auto Partition feature supports automatic detection of whether the corresponding partition exists during the data import process."},s=void 0,l={},c=[{value:"Application scenario",id:"application-scenario",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Sample",id:"sample",level:3},{value:"Constraints",id:"constraints",level:3},{value:"NULL value partition",id:"null-value-partition",level:3},{value:"Example",id:"example",level:2},{value:"Conjunct with Dynamic Partition",id:"conjunct-with-dynamic-partition",level:2},{value:"Lifecycle Management",id:"lifecycle-management",level:2},{value:"Conjunct with Auto Bucket",id:"conjunct-with-auto-bucket",level:2},{value:"Partition Management",id:"partition-management",level:2},{value:"Key points",id:"key-points",level:2}];function d(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"application-scenario",children:"Application scenario"}),"\n",(0,a.jsx)(t.p,{children:"The Auto Partition feature supports automatic detection of whether the corresponding partition exists during the data import process. If it does not exist, the partition will be created automatically and imported normally."}),"\n",(0,a.jsx)(t.p,{children:"The auto partition function mainly solves the problem that the user expects to partition the table based on a certain column, but the data distribution of the column is scattered or unpredictable, so it is difficult to accurately create the required partitions when building or adjusting the structure of the table, or the number of partitions is so large that it is too cumbersome to create them manually."}),"\n",(0,a.jsx)(t.p,{children:"Take the time type partition column as an example, in dynamic partitioning, we support the automatic creation of new partitions to accommodate real-time data at specific time periods. For real-time user behavior logs and other scenarios, this feature basically meets the requirements. However, in more complex scenarios, such as dealing with non-real-time data, the partition column is independent of the current system time and contains a large number of discrete values. At this time, to improve efficiency we want to partition the data based on this column, but the data may actually involve the partition can not be grasped in advance, or the expected number of required partitions is too large. In this case, dynamic partitioning or manually created partitions cannot meet our needs, while Auto Partition covers such needs."}),"\n",(0,a.jsx)(t.p,{children:"Suppose the table DDL is as follows:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE `DAILY_TRADE_VALUE`\n(\n    `TRADE_DATE`              datev2 NOT NULL COMMENT 'TRADE_DATE',\n    `TRADE_ID`                varchar(40) NOT NULL COMMENT 'TRADE_ID',\n    ......\n)\nUNIQUE KEY(`TRADE_DATE`, `TRADE_ID`)\nPARTITION BY RANGE(`TRADE_DATE`)\n(\n    PARTITION p_2000 VALUES [('2000-01-01'), ('2001-01-01')),\n    PARTITION p_2001 VALUES [('2001-01-01'), ('2002-01-01')),\n    PARTITION p_2002 VALUES [('2002-01-01'), ('2003-01-01')),\n    PARTITION p_2003 VALUES [('2003-01-01'), ('2004-01-01')),\n    PARTITION p_2004 VALUES [('2004-01-01'), ('2005-01-01')),\n    PARTITION p_2005 VALUES [('2005-01-01'), ('2006-01-01')),\n    PARTITION p_2006 VALUES [('2006-01-01'), ('2007-01-01')),\n    PARTITION p_2007 VALUES [('2007-01-01'), ('2008-01-01')),\n    PARTITION p_2008 VALUES [('2008-01-01'), ('2009-01-01')),\n    PARTITION p_2009 VALUES [('2009-01-01'), ('2010-01-01')),\n    PARTITION p_2010 VALUES [('2010-01-01'), ('2011-01-01')),\n    PARTITION p_2011 VALUES [('2011-01-01'), ('2012-01-01')),\n    PARTITION p_2012 VALUES [('2012-01-01'), ('2013-01-01')),\n    PARTITION p_2013 VALUES [('2013-01-01'), ('2014-01-01')),\n    PARTITION p_2014 VALUES [('2014-01-01'), ('2015-01-01')),\n    PARTITION p_2015 VALUES [('2015-01-01'), ('2016-01-01')),\n    PARTITION p_2016 VALUES [('2016-01-01'), ('2017-01-01')),\n    PARTITION p_2017 VALUES [('2017-01-01'), ('2018-01-01')),\n    PARTITION p_2018 VALUES [('2018-01-01'), ('2019-01-01')),\n    PARTITION p_2019 VALUES [('2019-01-01'), ('2020-01-01')),\n    PARTITION p_2020 VALUES [('2020-01-01'), ('2021-01-01')),\n    PARTITION p_2021 VALUES [('2021-01-01'), ('2022-01-01'))\n)\nDISTRIBUTED BY HASH(`TRADE_DATE`) BUCKETS 10\nPROPERTIES (\n  \"replication_num\" = \"1\"\n);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The table stores a large amount of business history data, partitioned based on the date the transaction occurred. As you can see when building the table, we need to manually create the partitions in advance. If the data range of the partitioned columns changes, for example, 2022 is added to the above table, we need to create a partition by ",(0,a.jsx)(t.a,{href:"../../sql-manual/sql-statements/table-and-view/table/ALTER-TABLE-PARTITION",children:"ALTER-TABLE-PARTITION"})," to make changes to the table partition. If such partitions need to be changed, or subdivided at a finer level of granularity, it is very tedious to modify them. At this point we can rewrite the table DDL using Auto Partition."]}),"\n",(0,a.jsx)(t.h2,{id:"syntax",children:"Syntax"}),"\n",(0,a.jsxs)(t.p,{children:["When creating a table, use the following syntax to populate the ",(0,a.jsx)(t.code,{children:"partitions_definition"})," section in the ",(0,a.jsx)(t.a,{href:"../../sql-manual/sql-statements/table-and-view/table/CREATE-TABLE",children:"CREATE-TABLE"})," statement."]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"AUTO RANGE PARTITION:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"  [AUTO] PARTITION BY RANGE(<partition_expr>)\n  <origin_partitions_definition>\n"})}),"\n",(0,a.jsx)(t.p,{children:"where"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"  partition_expr ::= date_trunc ( <partition_column>, '<interval>' )\n"})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"AUTO LIST PARTITION:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"    AUTO PARTITION BY LIST(`partition_col1` [, `partition_col2`, ...])\n    <origin_partitions_definition>\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"sample",children:"Sample"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"AUTO RANGE PARTITION"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'  CREATE TABLE `date_table` (\n      `TIME_STAMP` datev2 NOT NULL\n  ) ENGINE=OLAP\n  DUPLICATE KEY(`TIME_STAMP`)\n  AUTO PARTITION BY RANGE (date_trunc(`TIME_STAMP`, \'month\'))\n  (\n  )\n  DISTRIBUTED BY HASH(`TIME_STAMP`) BUCKETS 10\n  PROPERTIES (\n  "replication_allocation" = "tag.location.default: 1"\n  );\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In AUTO RANGE PARTITION, the ",(0,a.jsx)(t.code,{children:"AUTO"})," keyword can be omitted, and it still conveys the meaning of automatic partitioning."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"AUTO LIST PARTITION"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'  CREATE TABLE `str_table` (\n      `str` varchar not null\n  ) ENGINE=OLAP\n  DUPLICATE KEY(`str`)\n  AUTO PARTITION BY LIST (`str`)\n  ()\n  DISTRIBUTED BY HASH(`str`) BUCKETS 10\n  PROPERTIES (\n  "replication_allocation" = "tag.location.default: 1"\n  );\n'})}),"\n",(0,a.jsxs)(t.p,{children:["List Auto Partition supports multiple partition columns, which are written in the same way as normal List Partition: ",(0,a.jsx)(t.code,{children:"AUTO PARTITION BY LIST (`col1`, `col2`, ...)"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"constraints",children:"Constraints"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["In auto List Partition, the partition name length ",(0,a.jsx)(t.strong,{children:"must not exceed 50 characters"}),". This length is derived from the concatenation and escape of contents of partition columns on corresponding data rows, so the actual allowed length may be shorter."]}),"\n",(0,a.jsxs)(t.li,{children:["In auto Range Partition, the partition function only supports ",(0,a.jsx)(t.code,{children:"date_trunc"}),", and the partition column supports only ",(0,a.jsx)(t.code,{children:"DATE"})," or ",(0,a.jsx)(t.code,{children:"DATETIME"})," types."]}),"\n",(0,a.jsxs)(t.li,{children:["In auto List Partition, function calls are not supported, and the partition column supports ",(0,a.jsx)(t.code,{children:"BOOLEAN"}),", ",(0,a.jsx)(t.code,{children:"TINYINT"}),", ",(0,a.jsx)(t.code,{children:"SMALLINT"}),", ",(0,a.jsx)(t.code,{children:"INT"}),", ",(0,a.jsx)(t.code,{children:"BIGINT"}),", ",(0,a.jsx)(t.code,{children:"LARGEINT"}),", ",(0,a.jsx)(t.code,{children:"DATE"}),", ",(0,a.jsx)(t.code,{children:"DATETIME"}),", ",(0,a.jsx)(t.code,{children:"CHAR"}),", ",(0,a.jsx)(t.code,{children:"VARCHAR"})," data types, with partition values being enumeration values."]}),"\n",(0,a.jsx)(t.li,{children:"In auto List Partition, for every existing value in the partition column that does not correspond to a partition, a new independent partition will be created."}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"null-value-partition",children:"NULL value partition"}),"\n",(0,a.jsxs)(t.p,{children:["When the session variable ",(0,a.jsx)(t.code,{children:"allow_partition_column_nullable"})," is enabled:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"For Auto List Partition, the corresponding NULL value partition will be created automatically:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'  create table auto_null_list(\n    k0 varchar null\n  )\n  auto partition by list (k0)\n  (\n  )\n  DISTRIBUTED BY HASH(`k0`) BUCKETS 1\n  properties("replication_num" = "1");\n\n  insert into auto_null_list values (null);\n\n  select * from auto_null_list;\n  +------+\n  | k0   |\n  +------+\n  | NULL |\n  +------+\n\n  select * from auto_null_list partition(pX);\n  +------+\n  | k0   |\n  +------+\n  | NULL |\n  +------+\n'})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["For Auto Range Partition, ",(0,a.jsx)(t.strong,{children:"null columns are not supported to be partition columns"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'  CREATE TABLE `range_table_nullable` (\n    `k1` INT,\n    `k2` DATETIMEV2(3),\n    `k3` DATETIMEV2(6)\n  ) ENGINE=OLAP\n  DUPLICATE KEY(`k1`)\n  AUTO PARTITION BY RANGE (date_trunc(`k2`, \'day\'))\n  ()\n  DISTRIBUTED BY HASH(`k1`) BUCKETS 16\n  PROPERTIES (\n  "replication_allocation" = "tag.location.default: 1"\n  );\n\nERROR 1105 (HY000): errCode = 2, detailMessage = AUTO RANGE PARTITION doesn\'t support NULL column\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,a.jsx)(t.p,{children:"When using Auto Partition, the example in the Application scenarios section can be rewritten as:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE `DAILY_TRADE_VALUE`\n(\n    `TRADE_DATE`              datev2 NOT NULL COMMENT '\u4EA4\u6613\u65E5\u671F',\n    `TRADE_ID`                varchar(40) NOT NULL COMMENT '\u4EA4\u6613\u7F16\u53F7',\n    ......\n)\nUNIQUE KEY(`TRADE_DATE`, `TRADE_ID`)\nAUTO PARTITION BY RANGE (date_trunc(`TRADE_DATE`, 'year'))\n(\n)\nDISTRIBUTED BY HASH(`TRADE_DATE`) BUCKETS 10\nPROPERTIES (\n  \"replication_num\" = \"1\"\n);\n"})}),"\n",(0,a.jsx)(t.p,{children:"Take the example of a table with only two columns, at which point the new table has no default partitions:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"show partitions from `DAILY_TRADE_VALUE`;\nEmpty set (0.12 sec)\n"})}),"\n",(0,a.jsx)(t.p,{children:"After inserting data and checking again, it is found that the table has created the corresponding partitions:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"insert into `DAILY_TRADE_VALUE` values ('2012-12-13', 1), ('2008-02-03', 2), ('2014-11-11', 3);\n\nshow partitions from `DAILY_TRADE_VALUE`;\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+----------+------------+-------------------------+-----------+\n| PartitionId | PartitionName   | VisibleVersion | VisibleVersionTime  | State  | PartitionKey | Range                                                                          | DistributionKey | Buckets | ReplicationNum | StorageMedium | CooldownTime        | RemoteStoragePolicy | LastConsistencyCheckTime | DataSize | IsInMemory | ReplicaAllocation       | IsMutable |\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+----------+------------+-------------------------+-----------+\n| 180060      | p20080101000000 | 2              | 2023-09-18 21:49:29 | NORMAL | TRADE_DATE   | [types: [DATEV2]; keys: [2008-01-01]; ..types: [DATEV2]; keys: [2009-01-01]; ) | TRADE_DATE      | 10      | 1              | HDD           | 9999-12-31 23:59:59 |                     | NULL                     | 0.000    | false      | tag.location.default: 1 | true      |\n| 180039      | p20120101000000 | 2              | 2023-09-18 21:49:29 | NORMAL | TRADE_DATE   | [types: [DATEV2]; keys: [2012-01-01]; ..types: [DATEV2]; keys: [2013-01-01]; ) | TRADE_DATE      | 10      | 1              | HDD           | 9999-12-31 23:59:59 |                     | NULL                     | 0.000    | false      | tag.location.default: 1 | true      |\n| 180018      | p20140101000000 | 2              | 2023-09-18 21:49:29 | NORMAL | TRADE_DATE   | [types: [DATEV2]; keys: [2014-01-01]; ..types: [DATEV2]; keys: [2015-01-01]; ) | TRADE_DATE      | 10      | 1              | HDD           | 9999-12-31 23:59:59 |                     | NULL                     | 0.000    | false      | tag.location.default: 1 | true      |\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+----------+------------+-------------------------+-----------+\n"})}),"\n",(0,a.jsx)(t.p,{children:"It can be concluded that the partitions created by Auto Partition share the same functionality as partitions created by manual partitioning."}),"\n",(0,a.jsx)(t.h2,{id:"conjunct-with-dynamic-partition",children:"Conjunct with Dynamic Partition"}),"\n",(0,a.jsx)(t.p,{children:"Doris supports both Auto and Dynamic Partition. In this case, both functions are in effect:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Auto Partition will automatically create partitions on demand during data import;"}),"\n",(0,a.jsx)(t.li,{children:"Dynamic Partition will automatically create, recycle and dump partitions."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"There is no conflict between the two syntaxes, just set the corresponding clauses/attributes at the same time. Please note that it is uncertain whether the partition in current period is created by Auto Partition or Dynamic Partition. Different creation methods will lead to different naming formats for the partitions."}),"\n",(0,a.jsx)(t.h2,{id:"lifecycle-management",children:"Lifecycle Management"}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsx)(t.p,{children:"Doris supports the simultaneous use of automatic partitioning and dynamic partitioning for lifecycle management, but it is now not recommended."})}),"\n",(0,a.jsxs)(t.p,{children:["In the AUTO RANGE PARTITION table, the property ",(0,a.jsx)(t.code,{children:"partition.retention_count"})," is supported, which accepts a positive integer value as a parameter (denoted as ",(0,a.jsx)(t.code,{children:"N"}),"), indicating that ",(0,a.jsxs)(t.strong,{children:["only the top ",(0,a.jsx)(t.code,{children:"N"})," historical partitions with the largest partition values"]})," are retained among all historical partitions. All current and future partitions are retained. Specifically:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Since RANGE partitions are always non-overlapping, ",(0,a.jsx)(t.code,{children:"partition A's value > partition B's value"})," is equivalent to ",(0,a.jsx)(t.code,{children:"partition A's lower bound value > partition B's upper bound value"})," which is equivalent to ",(0,a.jsx)(t.code,{children:"partition A's upper bound value > partition B's upper bound value"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["Historical partitions refer to ",(0,a.jsx)(t.strong,{children:"partitions whose upper bound is <= current time"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["Current and future partitions refer to ",(0,a.jsx)(t.strong,{children:"partitions whose lower bound is >= current time"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"For example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'create table auto_recycle(\n    k0 datetime(6) not null\n)\nAUTO PARTITION BY RANGE (date_trunc(k0, \'day\')) ()\nDISTRIBUTED BY HASH(`k0`) BUCKETS 1\nproperties(\n    "partition.retention_count" = "3"\n);\n'})}),"\n",(0,a.jsxs)(t.p,{children:["This represents keeping only the top 3 partitions with the largest date values in the history. Assuming the current date is ",(0,a.jsx)(t.code,{children:"2025-10-21"}),", and inserting data for each day from ",(0,a.jsx)(t.code,{children:"2025-10-16"})," to ",(0,a.jsx)(t.code,{children:"2025-10-23"}),", after one recycling, as shown in the figure, the remaining partitions are as follows:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Recycle",src:n(859455).Z+"",width:"736",height:"702"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"p20251018000000"}),"\n",(0,a.jsx)(t.li,{children:"p20251019000000"}),"\n",(0,a.jsx)(t.li,{children:"p20251020000000 (This partition and above: Only keep three historical partitions)"}),"\n",(0,a.jsx)(t.li,{children:"p20251021000000 (This partition and below: The current and future partitions are not affected)"}),"\n",(0,a.jsx)(t.li,{children:"p20251022000000"}),"\n",(0,a.jsx)(t.li,{children:"p20251023000000"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"conjunct-with-auto-bucket",children:"Conjunct with Auto Bucket"}),"\n",(0,a.jsxs)(t.p,{children:["Only AUTO RANGE PARTITION can be used together with the ",(0,a.jsx)(t.a,{href:"/docs/4.x/table-design/data-partitioning/data-bucketing#auto-setting-bucket-number",children:"Auto Bucket"})," feature. When using this feature, Doris assumes that the data import is incremental in time order, and each import only involves one partition. In other words, this usage is only recommended for tables that are incrementally imported batch by batch."]}),"\n",(0,a.jsx)(t.admonition,{title:"Note!",type:"warning",children:(0,a.jsx)(t.p,{children:"If the data import method does not conform to the above pattern, and both auto partitioning and auto bucketing are used at the same time, there is a possibility that the number of buckets in the new partition is extremely unreasonable, which may greatly affect query performance."})}),"\n",(0,a.jsx)(t.h2,{id:"partition-management",children:"Partition Management"}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["Since 2.1.6, Doris supports the ",(0,a.jsx)(t.code,{children:"partitions"})," table function and the ",(0,a.jsx)(t.code,{children:"auto_partition_name"})," function, which can be used to easily find and manage partitions for data."]})}),"\n",(0,a.jsxs)(t.p,{children:["When Auto Partition is enabled, partition names can be mapped to partitions using the ",(0,a.jsx)(t.code,{children:"auto_partition_name"})," function.The ",(0,a.jsx)(t.code,{children:"partitions"})," table function generates detailed partition information from partition names. Let's take the ",(0,a.jsx)(t.code,{children:"DAILY_TRADE_VALUE"})," table as an example to see its current partition after we insert data:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'select * from partitions("catalog"="internal","database"="optest","table"="DAILY_TRADE_VALUE") where PartitionName = auto_partition_name(\'range\', \'year\', \'2008-02-03\');\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+-----------+------------+-------------------------+-----------+--------------------+--------------+\n| PartitionId | PartitionName   | VisibleVersion | VisibleVersionTime  | State  | PartitionKey | Range                                                                          | DistributionKey | Buckets | ReplicationNum | StorageMedium | CooldownTime        | RemoteStoragePolicy | LastConsistencyCheckTime | DataSize  | IsInMemory | ReplicaAllocation       | IsMutable | SyncWithBaseTables | UnsyncTables |\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+-----------+------------+-------------------------+-----------+--------------------+--------------+\n|      127095 | p20080101000000 |              2 | 2024-11-14 17:29:02 | NORMAL | TRADE_DATE   | [types: [DATEV2]; keys: [2008-01-01]; ..types: [DATEV2]; keys: [2009-01-01]; ) | TRADE_DATE      |      10 |              1 | HDD           | 9999-12-31 23:59:59 |                     | \\N                       | 985.000 B |          0 | tag.location.default: 1 |         1 |                  1 | \\N           |\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+-----------+------------+-------------------------+-----------+--------------------+--------------+\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In this way the IDs and values of each partition can be precisely filtered for subsequent partition-specific operations (e.g. ",(0,a.jsx)(t.code,{children:"insert overwrite partition"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["For a detailed grammar description, see: ",(0,a.jsx)(t.a,{href:"../../sql-manual/sql-functions/scalar-functions/string-functions/auto-partition-name",children:"auto_partition_name"}),"\uFF0C",(0,a.jsx)(t.a,{href:"../../sql-manual/sql-functions/table-valued-functions/partitions",children:"partitions"}),"\u3002"]}),"\n",(0,a.jsx)(t.h2,{id:"key-points",children:"Key points"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Similar to regular partitioned tables, auto List Partition supports multi-column partitioning with no syntax differences."}),"\n",(0,a.jsx)(t.li,{children:"If partitions are created during data insertion or import processes, and the entire import process is not completed (fails or is canceled), the created partitions will not be automatically deleted."}),"\n",(0,a.jsx)(t.li,{children:"Tables using Auto Partition only differ in the method of partition creation, switching from manual to automatic. The original usage of the table and its created partitions remains the same as non-Auto Partition tables or partitions."}),"\n",(0,a.jsxs)(t.li,{children:["To prevent the accidental creation of too many partitions, Apache Doris controls the maximum number of partitions an Auto Partition table can accommodate through the ",(0,a.jsx)(t.code,{children:"max_auto_partition_num setting"})," in the FE configuration. This value can be adjusted if needed."]}),"\n",(0,a.jsxs)(t.li,{children:["When importing data into a table with Auto Partition enabled, the coordinator sends data with a polling interval different from regular tables. Refer to ",(0,a.jsx)(t.code,{children:"olap_table_sink_send_interval_auto_partition_factor"}),"  in ",(0,a.jsx)(t.a,{href:"../../admin-manual/config/be-config",children:"BE Configuration"})," for details. This setting does not have an impact after ",(0,a.jsx)(t.code,{children:"enable_memtable_on_sink_node"})," is enabled."]}),"\n",(0,a.jsxs)(t.li,{children:["When use ",(0,a.jsx)(t.a,{href:"../../sql-manual/sql-statements/data-modification/DML/INSERT-OVERWRITE",children:"insert-overwrite"})," to load data into Auto Partition table, the behaviour is detailed in the INSERT OVERWRITE documentation."]}),"\n",(0,a.jsx)(t.li,{children:"If metadata operations are involved when importing and creating partitions, the import process may fail."}),"\n"]})]})}function h(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},859455:function(e,t,n){n.d(t,{Z:function(){return i}});let i=n.p+"assets/images/auto-partition-lifetime1-e8e4a7dc3b134dce7a8a73ec042485be.png"},250065:function(e,t,n){n.d(t,{Z:function(){return s},a:function(){return r}});var i=n(667294);let a={},o=i.createContext(a);function r(e){let t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);