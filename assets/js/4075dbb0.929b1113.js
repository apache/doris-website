"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["84690"],{269805:function(e,n,r){r.r(n),r.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>t,assets:()=>c,toc:()=>l,contentTitle:()=>a});var t=JSON.parse('{"id":"compute-storage-decoupled/rw/file-cache-rw-compute-group-best-practice","title":"Best Practices for Cache Optimization in Read-Write Splitting Scenarios","description":"When using Apache Doris\'s storage-compute separation architecture,","source":"@site/docs/compute-storage-decoupled/rw/file-cache-rw-compute-group-best-practice.md","sourceDirName":"compute-storage-decoupled/rw","slug":"/compute-storage-decoupled/rw/file-cache-rw-compute-group-best-practice","permalink":"/docs/dev/compute-storage-decoupled/rw/file-cache-rw-compute-group-best-practice","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Best Practices for Cache Optimization in Read-Write Splitting Scenarios","language":"en","description":"When using Apache Doris\'s storage-compute separation architecture,"},"sidebar":"docs","previous":{"title":"Read Write Separation","permalink":"/docs/dev/compute-storage-decoupled/rw/read-write-separation"},"next":{"title":"Recycler","permalink":"/docs/dev/compute-storage-decoupled/recycler"}}'),s=r("785893"),i=r("250065");let o={title:"Best Practices for Cache Optimization in Read-Write Splitting Scenarios",language:"en",description:"When using Apache Doris's storage-compute separation architecture,"},a=void 0,c={},l=[{value:"Core Issue: Cache Invalidation Caused by New Data Versions (Rowsets)",id:"core-issue-cache-invalidation-caused-by-new-data-versions-rowsets",level:2},{value:"I. Overview of Cache Warm-up Mechanisms",id:"i-overview-of-cache-warm-up-mechanisms",level:2},{value:"1. Proactive Incremental Warm-up (Recommended)",id:"1-proactive-incremental-warm-up-recommended",level:3},{value:"2. Read-Only Compute Group Automatic Warm-up",id:"2-read-only-compute-group-automatic-warm-up",level:3},{value:"II. Optimizing the Impact of Compaction / Schema Change on Query Performance",id:"ii-optimizing-the-impact-of-compaction--schema-change-on-query-performance",level:2},{value:"Solution 1: Proactive Incremental Warm-up + Delayed Commit (Recommended)",id:"solution-1-proactive-incremental-warm-up--delayed-commit-recommended",level:3},{value:"Solution 2: Read-Only Compute Group Automatic Warm-up + Query Awareness",id:"solution-2-read-only-compute-group-automatic-warm-up--query-awareness",level:3},{value:"III. Optimizing the Impact of Data Ingestion on Query Performance",id:"iii-optimizing-the-impact-of-data-ingestion-on-query-performance",level:2},{value:"Summary and Recommendations",id:"summary-and-recommendations",level:2}];function d(e){let n={a:"a",blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"When using Apache Doris's storage-compute separation architecture, especially in scenarios where multiple Compute Groups are deployed to implement read-write splitting, query performance is highly dependent on the File Cache hit rate. When a read-only compute group experiences a cache miss, it needs to pull data from remote object storage, leading to a significant increase in query latency."}),"\n",(0,s.jsxs)(n.p,{children:["This document aims to detail how to effectively reduce cache miss issues caused by common scenarios such as ",(0,s.jsx)(n.strong,{children:"Compaction"}),", ",(0,s.jsx)(n.strong,{children:"Data Ingestion"}),", and ",(0,s.jsx)(n.strong,{children:"Schema Change"})," through cache warm-up and related configurations, thereby ensuring the query performance stability of the read-only cluster."]}),"\n",(0,s.jsx)(n.h2,{id:"core-issue-cache-invalidation-caused-by-new-data-versions-rowsets",children:"Core Issue: Cache Invalidation Caused by New Data Versions (Rowsets)"}),"\n",(0,s.jsx)(n.p,{children:"In Doris, both background processes like Compaction / Schema Change and foreground data ingestion will generate new sets of data files (Rowsets). On the nodes of the write-only compute group responsible for writes, this data is written to the local File Cache by default, so its query performance is not affected."}),"\n",(0,s.jsx)(n.p,{children:"However, for a read-only compute group, when it synchronizes metadata and becomes aware of these new Rowsets, its local cache does not contain this new data. If a query then needs to access these new Rowsets, it will trigger a cache miss, leading to a performance degradation."}),"\n",(0,s.jsxs)(n.p,{children:["To solve this problem, the core idea is: ",(0,s.jsx)(n.strong,{children:"to load data into the read-only compute group's cache in advance or intelligently before it is queried."})]}),"\n",(0,s.jsx)(n.h2,{id:"i-overview-of-cache-warm-up-mechanisms",children:"I. Overview of Cache Warm-up Mechanisms"}),"\n",(0,s.jsx)(n.p,{children:"Cache warm-up is the process of proactively loading data from remote storage into the File Cache of BE nodes. Doris provides the following three main warm-up methods:"}),"\n",(0,s.jsx)(n.h3,{id:"1-proactive-incremental-warm-up-recommended",children:"1. Proactive Incremental Warm-up (Recommended)"}),"\n",(0,s.jsx)(n.p,{children:"This is a more intelligent and automated mechanism. It establishes a warm-up relationship between the write compute group and the read-only compute group. When a write/Compaction event generates a new Rowset, it actively notifies and triggers the associated read-only compute group to perform an asynchronous cache warm-up."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Applicable Scenarios:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Most scenarios."}),"\n",(0,s.jsx)(n.li,{children:"Requires user permission to configure warm-up relationships."}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"[Documentation Link]"}),": For detailed information on how to configure and use proactive incremental warm-up, please refer to the official documentation ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/dev/compute-storage-decoupled/rw/read-write-separation",children:"FileCache Proactive Incremental Warm-up"})}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-read-only-compute-group-automatic-warm-up",children:"2. Read-Only Compute Group Automatic Warm-up"}),"\n",(0,s.jsxs)(n.p,{children:["This is a lightweight, automatic warm-up strategy. By enabling a configuration on the BE nodes of the ",(0,s.jsx)(n.strong,{children:"read-only compute group"}),", it automatically triggers an asynchronous warm-up task when it perceives a new Rowset."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Applicable Scenarios:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Most scenarios."}),"\n",(0,s.jsx)(n.li,{children:"Requires user permission to configure warm-up relationships."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Core Configuration:"})," In the ",(0,s.jsx)(n.code,{children:"be.conf"})," of the read-only compute group, set:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"enable_warmup_immediately_on_new_rowset = true\n"})}),"\n",(0,s.jsx)(n.h2,{id:"ii-optimizing-the-impact-of-compaction--schema-change-on-query-performance",children:"II. Optimizing the Impact of Compaction / Schema Change on Query Performance"}),"\n",(0,s.jsx)(n.p,{children:"Background Compaction merges old Rowsets and generates new ones. If the new Rowsets are not warmed up, the query performance of the read-only compute group will fluctuate due to cache misses. The following are two recommended solutions."}),"\n",(0,s.jsx)(n.h3,{id:"solution-1-proactive-incremental-warm-up--delayed-commit-recommended",children:"Solution 1: Proactive Incremental Warm-up + Delayed Commit (Recommended)"}),"\n",(0,s.jsxs)(n.p,{children:["This solution can ",(0,s.jsx)(n.strong,{children:"fundamentally prevent"})," the read-only compute group from querying new Rowsets generated by Compaction / Schema Change that have not yet been cached."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"How it Works:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["First, configure the ",(0,s.jsx)(n.strong,{children:"proactive incremental warm-up"})," relationship between the write compute group and the read-only compute group."]}),"\n",(0,s.jsxs)(n.li,{children:["On the BE nodes of the ",(0,s.jsx)(n.strong,{children:"write compute group"}),", enable the delayed commit feature for Compaction / Schema Change."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Core Configuration (Write Compute Group ",(0,s.jsx)(n.code,{children:"be.conf"}),"):"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"enable_compaction_delay_commit_for_warm_up = true\n"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Workflow:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"A Compaction / Schema Change task completes on the write compute group and generates a new Rowset."}),"\n",(0,s.jsxs)(n.li,{children:["At this point, the Rowset is ",(0,s.jsx)(n.strong,{children:"not immediately committed"})," (i.e., it is not visible to the read-only compute group)."]}),"\n",(0,s.jsx)(n.li,{children:"The system triggers the associated read-only compute group to warm up the cache for this new Rowset."}),"\n",(0,s.jsx)(n.li,{children:"Only after all associated read-only compute groups have completed the warm-up, the new Rowset is finally committed and becomes visible to all compute groups."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Seamless Switching"}),": For the read-only compute group, all visible data post-Compaction is already in the cache, so query performance does not fluctuate."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High Stability"}),": This is the most robust solution for ensuring query performance in read-write splitting scenarios."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"solution-2-read-only-compute-group-automatic-warm-up--query-awareness",children:"Solution 2: Read-Only Compute Group Automatic Warm-up + Query Awareness"}),"\n",(0,s.jsxs)(n.p,{children:["This solution uses intelligent selection at the query layer to ",(0,s.jsx)(n.strong,{children:"try to skip"})," new Rowsets that have not yet been warmed up (Note: For Unique Key MoW tables, Rowsets from compaction cannot be skipped to ensure correctness)."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"How it Works:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["On the BE nodes of the ",(0,s.jsx)(n.strong,{children:"read-only compute group"}),", enable automatic warm-up."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Core Configuration (Read-Only Compute Group ",(0,s.jsx)(n.code,{children:"be.conf"}),"):"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"enable_warmup_immediately_on_new_rowset = true\n"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'During a query, enable the "prefer cached" Rowset selection strategy via a session variable or user property.'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Set in the query session:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SET enable_prefer_cached_rowset = true;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Or set as a user property:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'SET property for "jack" enable_prefer_cached_rowset = true;\n'})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Workflow:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"When the read-only compute group perceives a new Rowset from Compaction, it asynchronously triggers a warm-up task."}),"\n",(0,s.jsxs)(n.li,{children:["With ",(0,s.jsx)(n.code,{children:"enable_prefer_cached_rowset"})," enabled, the query planner, when selecting Rowsets to read, will prioritize those that are ",(0,s.jsx)(n.strong,{children:"already warmed up"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"It will automatically ignore new Rowsets that are still being warmed up, provided that this does not affect data consistency (i.e., the old Rowsets before the merge are still accessible)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Relatively simple to configure, without needing to set up cross-compute-group warm-up relationships."}),"\n",(0,s.jsx)(n.li,{children:"Effectively reduces performance impact in most cases."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Note:"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'This solution is a "best-effort" strategy. If the old Rowsets corresponding to a new Rowset have already been cleaned up, or if the query must access the latest data version, the query will still have to wait for the warm-up to complete or access the cold data directly.'}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"iii-optimizing-the-impact-of-data-ingestion-on-query-performance",children:"III. Optimizing the Impact of Data Ingestion on Query Performance"}),"\n",(0,s.jsxs)(n.p,{children:["High-frequency data ingestion (like ",(0,s.jsx)(n.code,{children:"INSERT INTO"}),", ",(0,s.jsx)(n.code,{children:"Stream Load"}),') continuously produces new small files (Rowsets), which also causes cache miss problems for the read-only compute group. If your business can tolerate data latency of seconds or even sub-seconds, you can adopt the following combined strategy to trade a tiny amount of "freshness" for a huge performance gain.']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"How it Works:"})," This strategy combines ",(0,s.jsx)(n.strong,{children:"automatic warm-up"})," with a ",(0,s.jsx)(n.strong,{children:"query freshness tolerance"})," setting, allowing the query planner to intelligently skip the latest data that has not been warmed up within a specified time window."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Implementation Steps:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Enable a Warm-up Mechanism"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Enable either ",(0,s.jsx)(n.strong,{children:"Proactive Incremental Warm-up"})," or ",(0,s.jsx)(n.strong,{children:"Read-Only Compute Group Automatic Warm-up"}),"(",(0,s.jsx)(n.code,{children:"enable_warmup_immediately_on_new_rowset=true"}),") on the read-only compute group. This is the prerequisite for data to be loaded into the cache asynchronously."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Set Query Freshness Tolerance"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["In the query session of the read-only compute group, set the ",(0,s.jsx)(n.code,{children:"query_freshness_tolerance_ms"})," variable."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Set in the query session:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Set a tolerance for 1000 milliseconds (1 second) of data latency\nSET query_freshness_tolerance_ms = 1000;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Or set as a user property:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'SET property for "jack" query_freshness_tolerance_ms = 1000;\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Workflow:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When a query starts, it checks the Rowsets it needs to access."}),"\n",(0,s.jsxs)(n.li,{children:["If a Rowset was generated within the ",(0,s.jsx)(n.strong,{children:"last 1000ms"})," and is ",(0,s.jsx)(n.strong,{children:"not yet warmed up"}),", the query planner will automatically skip it and access older, but already cached, data instead."]}),"\n",(0,s.jsx)(n.li,{children:"This way, the vast majority of queries will hit the cache, avoiding the performance degradation caused by reading the latest, cold data from recent writes."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fallback Mechanism:"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["If the warm-up process for a Rowset is very slow and exceeds the time set by ",(0,s.jsx)(n.code,{children:"query_freshness_tolerance_ms"})," (e.g., still not finished after 1000ms), the query will no longer skip it to ensure eventual data visibility. It will fall back to the default behavior: read the cold data directly."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Significant Performance Improvement"}),": Effectively eliminates query performance spikes in high-throughput write scenarios."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High Flexibility"}),": Users can make a flexible trade-off between data freshness and query performance based on their business needs."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary-and-recommendations",children:"Summary and Recommendations"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Solution"}),(0,s.jsx)(n.th,{children:"Applicable Scenarios"}),(0,s.jsx)(n.th,{children:"Expected Effect (Impact of various write operations on cache hit rate)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Active incremental pre-warming + delayed commit + configurable data freshness tolerance (optional)"}),(0,s.jsx)(n.td,{children:"Suitable for scenarios with extremely high query latency requirements; requires users to have permission to configure pre-warming relationships"}),(0,s.jsxs)(n.td,{children:["Compaction: None ",(0,s.jsx)(n.br,{})," Heavyweight schema change: None ",(0,s.jsx)(n.br,{})," Newly written data: Depends on freshness tolerance"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Read-only compute group with automatic pre-warming + prefer cached data + configurable data freshness tolerance (optional)"}),(0,s.jsxs)(n.td,{children:["Users have no permission to configure pre-warming relationships ",(0,s.jsx)(n.br,{})," If freshness tolerance is not configured, ineffective for MOW primary key tables"]}),(0,s.jsxs)(n.td,{children:["Compaction: None ",(0,s.jsx)(n.br,{})," Heavyweight schema change: Cache miss ",(0,s.jsx)(n.br,{})," Newly written data: Depends on freshness tolerance"]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"By reasonably applying the above cache warm-up strategies and related configurations, you can effectively manage the cache behavior of Apache Doris in a read-write splitting architecture, minimize performance loss due to cache misses, and ensure the stability and efficiency of your read-only query services."})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},250065:function(e,n,r){r.d(n,{Z:function(){return a},a:function(){return o}});var t=r(667294);let s={},i=t.createContext(s);function o(e){let n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);