"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["19967"],{667900:function(e,n,i){i.r(n),i.d(n,{default:()=>h,frontMatter:()=>d,metadata:()=>r,assets:()=>l,toc:()=>o,contentTitle:()=>c});var r=JSON.parse('{"id":"sql-manual/basic-element/sql-data-types/conversion/timestamptz-conversion","title":"Cast to TIMESTAMPTZ Type","description":"The string 0000-01-01 00:00:00+08:00 is a valid DATETIME value, but after conversion to UTC time it exceeds the valid range, resulting in NULL.","source":"@site/docs/sql-manual/basic-element/sql-data-types/conversion/timestamptz-conversion.md","sourceDirName":"sql-manual/basic-element/sql-data-types/conversion","slug":"/sql-manual/basic-element/sql-data-types/conversion/timestamptz-conversion","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/conversion/timestamptz-conversion","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Cast to TIMESTAMPTZ Type","language":"en","description":"The string 0000-01-01 00:00:00+08:00 is a valid DATETIME value, but after conversion to UTC time it exceeds the valid range, resulting in NULL."},"sidebar":"docs","previous":{"title":"Cast to DATETIME Type","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/conversion/datetime-conversion"},"next":{"title":"Cast to DECIMAL Type","permalink":"/docs/dev/sql-manual/basic-element/sql-data-types/conversion/decimal-conversion"}}'),t=i("785893"),s=i("250065");let d={title:"Cast to TIMESTAMPTZ Type",language:"en",description:"The string 0000-01-01 00:00:00+08:00 is a valid DATETIME value, but after conversion to UTC time it exceeds the valid range, resulting in NULL."},c=void 0,l={},o=[{value:"From Datelike Types",id:"from-datelike-types",level:2},{value:"Timestamptz",id:"timestamptz",level:3},{value:"Strict Mode",id:"strict-mode",level:4},{value:"Rule Description",id:"rule-description",level:5},{value:"Error Handling",id:"error-handling",level:5},{value:"Examples",id:"examples",level:5},{value:"Non-strict Mode",id:"non-strict-mode",level:4},{value:"Rule Description",id:"rule-description-1",level:5},{value:"Error Handling",id:"error-handling-1",level:5},{value:"Examples",id:"examples-1",level:5},{value:"Datetime",id:"datetime",level:3},{value:"Strict Mode",id:"strict-mode-1",level:4},{value:"Rule Description",id:"rule-description-2",level:5},{value:"Error Handling",id:"error-handling-2",level:5},{value:"Examples",id:"examples-2",level:5},{value:"Non-strict Mode",id:"non-strict-mode-1",level:4},{value:"Rule Description",id:"rule-description-3",level:5},{value:"Error Handling",id:"error-handling-3",level:5},{value:"Examples",id:"examples-3",level:5}];function a(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The rules for converting string and numeric types to TIMESTAMPTZ type are almost exactly the same as converting to DATETIME type. The difference is that when converting to TIMESTAMPTZ, the converted DATETIME value is ultimately converted to UTC time, which may result in cases where the DATETIME value is valid but the value after conversion to UTC time is invalid. For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:'set time_zone="+08:00";\n\nselect cast("0000-01-01 00:00:00+08:00" as datetimev2);\n+-------------------------------------------------+\n| cast("0000-01-01 00:00:00+08:00" as datetimev2) |\n+-------------------------------------------------+\n| 0000-01-01 00:00:00                             |\n+-------------------------------------------------+\n1 row in set (0.00 sec)\n\nselect cast("0000-01-01 00:00:00+08:00" as timestamptz);\n+--------------------------------------------------+\n| cast("0000-01-01 00:00:00+08:00" as timestamptz) |\n+--------------------------------------------------+\n| NULL                                             |\n+--------------------------------------------------+\n1 row in set (0.04 sec)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The string ",(0,t.jsx)(n.code,{children:"0000-01-01 00:00:00+08:00"})," is a valid DATETIME value, but after conversion to UTC time it exceeds the valid range, resulting in ",(0,t.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For detailed conversion rules, refer to the ",(0,t.jsx)(n.a,{href:"/docs/dev/sql-manual/basic-element/sql-data-types/conversion/datetime-conversion",children:"Convert to DATETIME Type"})," documentation."]}),"\n",(0,t.jsx)(n.h2,{id:"from-datelike-types",children:"From Datelike Types"}),"\n",(0,t.jsx)(n.p,{children:"Supports conversion from Datetime type to Timestamptz type. During conversion, the DATETIME is converted to UTC time based on the current session's time zone. There may be cases where the DATETIME value is valid but the value after conversion to UTC time is invalid."}),"\n",(0,t.jsx)(n.p,{children:"Since Timestamptz has different precision values, there are also conversions between different precision Timestamptz types."}),"\n",(0,t.jsx)(n.h3,{id:"timestamptz",children:"Timestamptz"}),"\n",(0,t.jsx)(n.h4,{id:"strict-mode",children:"Strict Mode"}),"\n",(0,t.jsx)(n.h5,{id:"rule-description",children:"Rule Description"}),"\n",(0,t.jsx)(n.p,{children:"When converting from low precision to high precision, newly appeared decimal places are padded with 0, and this conversion is always valid."}),"\n",(0,t.jsx)(n.p,{children:"When converting from high precision to low precision, rounding will occur, and the carry can continue to propagate forward. If overflow occurs, the converted value is invalid."}),"\n",(0,t.jsx)(n.h5,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"If overflow occurs, an error is reported."}),"\n",(0,t.jsx)(n.h5,{id:"examples",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Input TIMESTAMPTZ"}),(0,t.jsx)(n.th,{children:"Source Type"}),(0,t.jsx)(n.th,{children:"Target Type"}),(0,t.jsx)(n.th,{children:"Result TIMESTAMPTZ"}),(0,t.jsx)(n.th,{children:"Comment"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123+08:00"})}),(0,t.jsx)(n.td,{children:"Timestamptz(3)"}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123000+08:00"})}),(0,t.jsx)(n.td,{children:"Expand precision"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123456+08:00"})}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(3)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123+08:00"})}),(0,t.jsx)(n.td,{children:"Reduce precision, no carry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.996666+08:00"})}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(2)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:01.00+08:00"})}),(0,t.jsx)(n.td,{children:"Reduce precision, carry to seconds"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"9999-12-31 23:59:59.999999+08:00"})}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(5)"}),(0,t.jsx)(n.td,{children:"Error"}),(0,t.jsx)(n.td,{children:"Carry overflow, produces invalid date of year 10000"})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"non-strict-mode",children:"Non-strict Mode"}),"\n",(0,t.jsx)(n.p,{children:"Except for error handling, the behavior of non-strict mode is exactly the same as strict mode."}),"\n",(0,t.jsx)(n.h5,{id:"rule-description-1",children:"Rule Description"}),"\n",(0,t.jsx)(n.p,{children:"When converting from low precision to high precision, newly appeared decimal places are padded with 0, and this conversion is always valid."}),"\n",(0,t.jsx)(n.p,{children:"When converting from high precision to low precision, rounding will occur, and the carry can continue to propagate forward. If overflow occurs, the converted value is invalid."}),"\n",(0,t.jsx)(n.h5,{id:"error-handling-1",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"If overflow occurs, the return value is NULL."}),"\n",(0,t.jsx)(n.h5,{id:"examples-1",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Input TIMESTAMPTZ"}),(0,t.jsx)(n.th,{children:"Source Type"}),(0,t.jsx)(n.th,{children:"Target Type"}),(0,t.jsx)(n.th,{children:"Result TIMESTAMPTZ"}),(0,t.jsx)(n.th,{children:"Comment"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123+08:00"})}),(0,t.jsx)(n.td,{children:"Timestamptz(3)"}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123000+08:00"})}),(0,t.jsx)(n.td,{children:"Expand precision"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123456+08:00"})}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(3)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123+08:00"})}),(0,t.jsx)(n.td,{children:"Reduce precision, no carry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.99666+08:00"})}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(2)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:01.00+08:00"})}),(0,t.jsx)(n.td,{children:"Reduce precision, carry to seconds"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"9999-12-31 23:59:59.999999+08:00"})}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(5)"}),(0,t.jsx)(n.td,{children:"NULL"}),(0,t.jsx)(n.td,{children:"Carry overflow, produces invalid date of year 10000"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"datetime",children:"Datetime"}),"\n",(0,t.jsx)(n.h4,{id:"strict-mode-1",children:"Strict Mode"}),"\n",(0,t.jsx)(n.h5,{id:"rule-description-2",children:"Rule Description"}),"\n",(0,t.jsx)(n.p,{children:"When converting from low precision to high precision, newly appeared decimal places are padded with 0, and this conversion is always valid."}),"\n",(0,t.jsx)(n.p,{children:"When converting from high precision to low precision, rounding will occur, and the carry can continue to propagate forward. If overflow occurs, the converted value is invalid."}),"\n",(0,t.jsx)(n.h5,{id:"error-handling-2",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"If overflow occurs, an error is reported."}),"\n",(0,t.jsx)(n.h5,{id:"examples-2",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Input DATETIME"}),(0,t.jsx)(n.th,{children:"Source Type"}),(0,t.jsx)(n.th,{children:"Target Type"}),(0,t.jsx)(n.th,{children:"Result TIMESTAMPTZ"}),(0,t.jsx)(n.th,{children:"Comment"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123"})}),(0,t.jsx)(n.td,{children:"Datetime(3)"}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123000+08:00"})}),(0,t.jsx)(n.td,{children:"Expand precision"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123456"})}),(0,t.jsx)(n.td,{children:"Datetime(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(3)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123+08:00"})}),(0,t.jsx)(n.td,{children:"Reduce precision, no carry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.99666"})}),(0,t.jsx)(n.td,{children:"Datetime(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(2)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:01.00+08:00"})}),(0,t.jsx)(n.td,{children:"Reduce precision, carry to seconds"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"9999-12-31 23:59:59.999999"})}),(0,t.jsx)(n.td,{children:"Datetime(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(5)"}),(0,t.jsx)(n.td,{children:"Error"}),(0,t.jsx)(n.td,{children:"Carry overflow, produces invalid date of year 10000"})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"non-strict-mode-1",children:"Non-strict Mode"}),"\n",(0,t.jsx)(n.p,{children:"Except for error handling, the behavior of non-strict mode is exactly the same as strict mode."}),"\n",(0,t.jsx)(n.h5,{id:"rule-description-3",children:"Rule Description"}),"\n",(0,t.jsx)(n.p,{children:"When converting from low precision to high precision, newly appeared decimal places are padded with 0, and this conversion is always valid."}),"\n",(0,t.jsx)(n.p,{children:"When converting from high precision to low precision, rounding will occur, and the carry can continue to propagate forward. If overflow occurs, the converted value is invalid."}),"\n",(0,t.jsx)(n.h5,{id:"error-handling-3",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"If overflow occurs, the return value is NULL."}),"\n",(0,t.jsx)(n.h5,{id:"examples-3",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Input DATETIME"}),(0,t.jsx)(n.th,{children:"Source Type"}),(0,t.jsx)(n.th,{children:"Target Type"}),(0,t.jsx)(n.th,{children:"Result TIMESTAMPTZ"}),(0,t.jsx)(n.th,{children:"Comment"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123"})}),(0,t.jsx)(n.td,{children:"Datetime(3)"}),(0,t.jsx)(n.td,{children:"Timestamptz(6)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123000+08:00"})}),(0,t.jsx)(n.td,{children:"Expand precision"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123456"})}),(0,t.jsx)(n.td,{children:"Datetime(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(3)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.123+08:00"})}),(0,t.jsx)(n.td,{children:"Reduce precision, no carry"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:00.99666"})}),(0,t.jsx)(n.td,{children:"Datetime(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(2)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"2020-12-12 00:00:01.00+08:00"})}),(0,t.jsx)(n.td,{children:"Reduce precision, carry to seconds"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"9999-12-31 23:59:59.999999"})}),(0,t.jsx)(n.td,{children:"Datetime(6)"}),(0,t.jsx)(n.td,{children:"Timestamptz(5)"}),(0,t.jsx)(n.td,{children:"NULL"}),(0,t.jsx)(n.td,{children:"Carry overflow, produces invalid date of year 10000"})]})]})]})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return c},a:function(){return d}});var r=i(667294);let t={},s=r.createContext(t);function d(e){let n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);