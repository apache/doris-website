"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["54793"],{678456:function(e,n,t){t.r(n),t.d(n,{default:()=>u,frontMatter:()=>o,metadata:()=>i,assets:()=>c,toc:()=>d,contentTitle:()=>r});var i=JSON.parse('{"id":"table-design/data-partitioning/data-bucketing","title":"Data Bucketing","description":"A partition can further be divided into different data buckets based on business logic. Each bucket will be stored as a physical data tablet. A reasonable bucket strategy can effectively reduce the amount of data scanned during queries, thereby improving query performance and increasing query concurrency.","source":"@site/docs/table-design/data-partitioning/data-bucketing.md","sourceDirName":"table-design/data-partitioning","slug":"/table-design/data-partitioning/data-bucketing","permalink":"/docs/dev/table-design/data-partitioning/data-bucketing","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Data Bucketing","language":"en"},"sidebar":"docs","previous":{"title":"Auto Partition","permalink":"/docs/dev/table-design/data-partitioning/auto-partitioning"},"next":{"title":"Common Issues","permalink":"/docs/dev/table-design/data-partitioning/common-issues"}}'),s=t("785893"),a=t("250065");let o={title:"Data Bucketing",language:"en"},r=void 0,c={},d=[{value:"Bucket Methods",id:"bucket-methods",level:2},{value:"Hash Bucketing",id:"hash-bucketing",level:3},{value:"Random Bucketing",id:"random-bucketing",level:3},{value:"Choosing Bucket Keys",id:"choosing-bucket-keys",level:2},{value:"Choosing the Number of Buckets",id:"choosing-the-number-of-buckets",level:2},{value:"Manually Setting the Number of Buckets",id:"manually-setting-the-number-of-buckets",level:3},{value:"Automatic Bucket Number Setting",id:"automatic-bucket-number-setting",level:3},{value:"Maintaining Data Buckets",id:"maintaining-data-buckets",level:2}];function l(e){let n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"A partition can further be divided into different data buckets based on business logic. Each bucket will be stored as a physical data tablet. A reasonable bucket strategy can effectively reduce the amount of data scanned during queries, thereby improving query performance and increasing query concurrency."}),"\n",(0,s.jsx)(n.h2,{id:"bucket-methods",children:"Bucket Methods"}),"\n",(0,s.jsx)(n.p,{children:"Doris supports two bucket methods: Hash Bucketing and Random Bucketing."}),"\n",(0,s.jsx)(n.h3,{id:"hash-bucketing",children:"Hash Bucketing"}),"\n",(0,s.jsx)(n.p,{children:"When creating a table or adding a partition, users need to select one or more columns as the bucket columns and specify the number of buckets. Within the same partition, the system performs a hash calculation based on the bucket key and the number of buckets. Data with the same hash value will be allocated to the same bucket. For example, in the figure below, partition p250102 is divided into three buckets based on the region column, and rows with the same hash value are placed into the same bucket."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"hash-bucket",src:t(641838).Z+"",width:"5788",height:"2740"})}),"\n",(0,s.jsx)(n.p,{children:"It is recommended to use Hash Bucketing in the following scenarios:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When the business needs to frequently filter based on a certain field, you can use this field as the bucket key for Hash Bucketing to improve query efficiency."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When the data distribution in the table is relatively uniform, Hash Bucketing is also a suitable choice."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The following example shows how to create a table with Hash Bucketing. For detailed syntax, please refer to the CREATE TABLE statement."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE demo.hash_bucket_tbl(\n    oid         BIGINT,\n    dt          DATE,\n    region      VARCHAR(10),\n    amount      INT\n)\nDUPLICATE KEY(oid)\nPARTITION BY RANGE(dt) (\n    PARTITION p250101 VALUES LESS THAN("2025-01-01"),\n    PARTITION p250102 VALUES LESS THAN("2025-01-02")\n)\nDISTRIBUTED BY HASH(region) BUCKETS 8;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the example, ",(0,s.jsx)(n.code,{children:"DISTRIBUTED BY HASH(region)"})," specifies the creation of Hash Bucketing and selects the ",(0,s.jsx)(n.code,{children:"region"})," column as the bucket key. Meanwhile, ",(0,s.jsx)(n.code,{children:"BUCKETS 8"})," specifies the creation of 8 buckets."]}),"\n",(0,s.jsx)(n.h3,{id:"random-bucketing",children:"Random Bucketing"}),"\n",(0,s.jsx)(n.p,{children:"In each partition, Random Bucketing randomly distributes data to various buckets without relying on the hash value of a certain field. Random Bucketing ensures uniform data distribution, thus avoiding data skew caused by improper bucket key selection."}),"\n",(0,s.jsxs)(n.p,{children:["During data import, each batch of a single import job will be randomly written to a tablet, ensuring uniform data distribution. For example, in one operation, eight batches of data are randomly allocated to three buckets under partition ",(0,s.jsx)(n.code,{children:"p250102"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"random-bucket",src:t(489307).Z+"",width:"5788",height:"2740"})}),"\n",(0,s.jsxs)(n.p,{children:["When using Random Bucketing, you can enable the single-tablet import mode (set ",(0,s.jsx)(n.code,{children:"load_to_single_tablet"})," to ",(0,s.jsx)(n.code,{children:"true"}),"). During large-scale data imports, one batch of data will only be written to one data tablet, helping to improve the concurrency and throughput of data imports, reducing write amplification caused by data imports and Compaction, thereby ensuring cluster stability."]}),"\n",(0,s.jsx)(n.p,{children:"It is recommended to use Random Bucketing in the following scenarios:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"In scenarios of arbitrary dimension analysis, where the business does not frequently filter or join queries based on a specific column, you can choose Random Bucketing."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When the data distribution of frequently queried columns or combinations of columns is extremely uneven, using Random Bucketing can avoid data skew."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Random Bucketing cannot be pruned based on bucket keys and will scan all data in the hit partition, so it is not recommended for point query scenarios."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Only DUPLICATE tables can use Random partitioning. UNIQUE and AGGREGATE tables cannot use Random Bucketing."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The following example shows how to create a table with Random Bucketing. For detailed syntax, please refer to the CREATE TABLE statement:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE demo.random_bucket_tbl(\n    oid         BIGINT,\n    dt          DATE,\n    region      VARCHAR(10),\n    amount      INT\n)\nDUPLICATE KEY(oid)\nPARTITION BY RANGE(dt) (\n    PARTITION p250101 VALUES LESS THAN("2025-01-01"),\n    PARTITION p250102 VALUES LESS THAN("2025-01-02")\n)\nDISTRIBUTED BY RANDOM BUCKETS 8;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the example, the statement ",(0,s.jsx)(n.code,{children:"DISTRIBUTED BY RANDOM"})," specifies the use of Random Bucketing. Creating Random Bucketing does not require selecting a bucket key, and the statement ",(0,s.jsx)(n.code,{children:"BUCKETS 8"})," specifies the creation of 8 buckets."]}),"\n",(0,s.jsx)(n.h2,{id:"choosing-bucket-keys",children:"Choosing Bucket Keys"}),"\n",(0,s.jsx)(n.admonition,{title:"Note",type:"tip",children:(0,s.jsx)(n.p,{children:"Only Hash Bucketing requires selecting bucket keys; Random Bucketing does not require selecting bucket keys."})}),"\n",(0,s.jsx)(n.p,{children:"Bucket keys can be one or more columns. If it is a DUPLICATE table, any Key column or Value column can be used as the bucket key. If it is an AGGREGATE or UNIQUE table, to ensure gradual aggregation, the bucket column must be a Key column."}),"\n",(0,s.jsx)(n.p,{children:"Generally, you can choose bucket keys based on the following rules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Using Query Filter Conditions:"})," Using query filter conditions for Hash Bucketing helps data pruning and reduces data scan volume;"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Using High Cardinality Columns:"})," Selecting high cardinality (many unique values) columns for Hash Bucketing helps to evenly distribute data across each bucket;"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"High-Concurrency Point Query Scenarios:"})," It is recommended to select a single column or fewer columns for bucketing. Point queries may only trigger a scan of one bucket, and the probability of different queries triggering scans of different buckets is high, thereby reducing the IO impact between queries."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"High-Throughput Query Scenarios:"})," It is recommended to select multiple columns for bucketing to make data more evenly distributed. If the query conditions cannot include the equality conditions of all bucket keys, it will increase query throughput and reduce the latency of single queries."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"choosing-the-number-of-buckets",children:"Choosing the Number of Buckets"}),"\n",(0,s.jsxs)(n.p,{children:["In Doris, a bucket is stored as a physical file (tablet). The number of tablets in a table equals ",(0,s.jsx)(n.code,{children:"partition_num"})," (number of partitions) multiplied by ",(0,s.jsx)(n.code,{children:"bucket_num"})," (number of buckets). Once the number of Partitions is specified, it cannot be changed."]}),"\n",(0,s.jsx)(n.p,{children:"When determining the number of buckets, you need to consider machine expansion in advance. Starting from version 2.0, Doris supports automatically setting the number of buckets in partitions based on machine resources and cluster information."}),"\n",(0,s.jsx)(n.h3,{id:"manually-setting-the-number-of-buckets",children:"Manually Setting the Number of Buckets"}),"\n",(0,s.jsxs)(n.p,{children:["You can specify the number of buckets using the ",(0,s.jsx)(n.code,{children:"DISTRIBUTED"})," statement:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Set hash bucket num to 8\nDISTRIBUTED BY HASH(region) BUCKETS 8\n\n-- Set random bucket num to 8\nDISTRIBUTED BY RANDOM BUCKETS 8\n"})}),"\n",(0,s.jsx)(n.p,{children:"When determining the number of buckets, two principles are usually followed: quantity and size. If there is a conflict between the two, the size principle is prioritized:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Size Principle:"})," It is recommended that the size of a tablet should be within the range of 1-10GB. Too small a tablet may result in poor aggregation effect and increase metadata management pressure; too large a tablet is not conducive to replica migration and supplementation and will increase the cost of retrying Schema Change operations."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Quantity Principle:"})," Without considering expansion, it is recommended that the number of tablets for a table be slightly more than the number of disks in the entire cluster."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For example, assuming there are 10 BE machines with one disk per BE, you can follow the recommendations below for data bucketing:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Table Size"}),(0,s.jsx)(n.th,{children:"Recommended Number of Buckets"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"500MB"}),(0,s.jsx)(n.td,{children:"4-8 buckets"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5GB"}),(0,s.jsx)(n.td,{children:"6-16 buckets"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"50GB"}),(0,s.jsx)(n.td,{children:"32 buckets"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"500GB"}),(0,s.jsx)(n.td,{children:"Partition recommended, 50GB per partition, 16-32 buckets per partition"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5TB"}),(0,s.jsx)(n.td,{children:"Partition recommended, 50GB per partition, 16-32 buckets per partition"})]})]})]}),"\n",(0,s.jsx)(n.admonition,{title:"Note",type:"tip",children:(0,s.jsxs)(n.p,{children:["The data volume of the table can be viewed using the ",(0,s.jsx)(n.code,{children:"SHOW DATA"})," command. The result needs to be divided by the number of replicas and the data volume of the table."]})}),"\n",(0,s.jsx)(n.h3,{id:"automatic-bucket-number-setting",children:"Automatic Bucket Number Setting"}),"\n",(0,s.jsx)(n.p,{children:"The automatic bucket number calculation function will automatically predict the future partition size based on the partition size over a period of time, and determine the number of buckets accordingly."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'-- Set hash bucket auto\nDISTRIBUTED BY HASH(region) BUCKETS AUTO\nproperties("estimate_partition_size" = "20G")\n\n-- Set random bucket auto\nDISTRIBUTED BY HASH(region) BUCKETS AUTO\nproperties("estimate_partition_size" = "20G")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When creating buckets, you can adjust the estimated partition size through the ",(0,s.jsx)(n.code,{children:"estimate_partition_size"})," attribute. This parameter is optional, and if not provided, Doris will default to 10GB. Please note that this parameter is not related to the future partition size calculated by the system based on historical partition data."]}),"\n",(0,s.jsx)(n.h2,{id:"maintaining-data-buckets",children:"Maintaining Data Buckets"}),"\n",(0,s.jsxs)(n.admonition,{title:"Note",type:"tip",children:[(0,s.jsx)(n.p,{children:"Currently, Doris only supports modifying the number of buckets in newly added partitions and does not support the following operations:"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Modifying the bucketing type"}),"\n",(0,s.jsx)(n.li,{children:"Modifying the bucket key"}),"\n",(0,s.jsx)(n.li,{children:"Modifying the number of buckets for existing buckets"}),"\n"]})]}),"\n",(0,s.jsxs)(n.p,{children:["When creating a table, the number of buckets for each partition is uniformly specified through the ",(0,s.jsx)(n.code,{children:"DISTRIBUTED"})," statement. To cope with data growth or reduction, you can specify the number of buckets for the new partition when dynamically adding partitions. The following example shows how to modify the number of buckets in newly added partitions using the ",(0,s.jsx)(n.code,{children:"ALTER TABLE"})," command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'-- Modify hash bucket table\nALTER TABLE demo.hash_bucket_tbl \nADD PARTITION p250103 VALUES LESS THAN("2025-01-03")\nDISTRIBUTED BY HASH(region) BUCKETS 16;\n\n-- Modify random bucket table\nALTER TABLE demo.random_bucket_tbl \nADD PARTITION p250103 VALUES LESS THAN("2025-01-03")\nDISTRIBUTED BY RANDOM BUCKETS 16;\n\n-- Modify dynamic partition table\nALTER TABLE demo.dynamic_partition_tbl\nSET ("dynamic_partition.buckets"="16");\n'})}),"\n",(0,s.jsx)(n.p,{children:"After modifying the number of buckets, you can use the SHOW PARTITION command to check the updated number of buckets."})]})}function u(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},641838:function(e,n,t){t.d(n,{Z:function(){return i}});let i=t.p+"assets/images/hash-bucket-bddcce3aa18c83ad8523cae53d8588e3.png"},489307:function(e,n,t){t.d(n,{Z:function(){return i}});let i=t.p+"assets/images/random-bucket-d8defe2db9959b5c291ab585a08aaf34.png"},250065:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return o}});var i=t(667294);let s={},a=i.createContext(s);function o(e){let n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);