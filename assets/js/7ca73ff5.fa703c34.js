"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["92500"],{565353:function(e,i,a){a.r(i),a.d(i,{default:()=>h,frontMatter:()=>c,metadata:()=>n,assets:()=>o,toc:()=>l,contentTitle:()=>r});var n=JSON.parse('{"id":"compute-storage-decoupled/file-cache/file-cache-internals","title":"File Cache Internals","description":"Fundamentals","source":"@site/docs/compute-storage-decoupled/file-cache/file-cache-internals.md","sourceDirName":"compute-storage-decoupled/file-cache","slug":"/compute-storage-decoupled/file-cache/file-cache-internals","permalink":"/docs/dev/compute-storage-decoupled/file-cache/file-cache-internals","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"File Cache Internals","language":"en"},"sidebar":"docs","previous":{"title":"File Cache","permalink":"/docs/dev/compute-storage-decoupled/file-cache/"},"next":{"title":"Read Write Separation","permalink":"/docs/dev/compute-storage-decoupled/rw/read-write-separation"}}'),t=a("785893"),s=a("250065");let c={title:"File Cache Internals",language:"en"},r=void 0,o={},l=[{value:"Fundamentals",id:"fundamentals",level:2},{value:"(1) Cache Slicing and Prefetch Mechanism",id:"1-cache-slicing-and-prefetch-mechanism",level:3},{value:"(2) Local File Directory Organization",id:"2-local-file-directory-organization",level:3},{value:"(3) Multi-Queue Mechanism",id:"3-multi-queue-mechanism",level:3},{value:"(4) Eviction Mechanism",id:"4-eviction-mechanism",level:3},{value:"(5) Warm-up Mechanism",id:"5-warm-up-mechanism",level:3},{value:"Scenario Analysis",id:"scenario-analysis",level:2},{value:"(1) File Cache in Query Processing",id:"1-file-cache-in-query-processing",level:3},{value:"(2) File Cache in Data Loading",id:"2-file-cache-in-data-loading",level:3},{value:"(3) File Cache in Compaction",id:"3-file-cache-in-compaction",level:3},{value:"(4) Cache Loading After Restart",id:"4-cache-loading-after-restart",level:3},{value:"(5) Cache Handling During Scaling",id:"5-cache-handling-during-scaling",level:3}];function d(e){let i={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h2,{id:"fundamentals",children:"Fundamentals"}),"\n",(0,t.jsx)(i.h3,{id:"1-cache-slicing-and-prefetch-mechanism",children:"(1) Cache Slicing and Prefetch Mechanism"}),"\n",(0,t.jsx)(i.p,{children:"Doris employs cache slicing and prefetch mechanisms to optimize data cache management and read efficiency. Specifically, target files are sliced with 1MB alignment, and each slice is stored as a separate Block file in the local filesystem after complete download. This slicing approach effectively reduces cache granularity, improving cache flexibility and space utilization. Doris can cache only required portions of data, avoiding the space waste of caching entire large files. Smaller cache blocks also facilitate management and eviction, enabling more precise hotspot data access."}),"\n",(0,t.jsx)(i.h3,{id:"2-local-file-directory-organization",children:"(2) Local File Directory Organization"}),"\n",(0,t.jsx)(i.p,{children:"To better manage cached data, Doris adopts a specific local file directory structure. Caches may be distributed across multiple directories on multiple disks. To achieve uniform distribution across directories, Doris calculates a hash value from the target file path and uses this hash as the last-level directory for Block file storage. Each Block file is named based on its offset position in the target file."}),"\n",(0,t.jsxs)(i.p,{children:["For example, if the target file path is ",(0,t.jsx)(i.code,{children:"/remote/data/datafile1"})," with a hash value of ",(0,t.jsx)(i.code,{children:"12345"}),", the cached Block file might be stored at ",(0,t.jsx)(i.code,{children:"/cache/123/12345/offset1"}),", where ",(0,t.jsx)(i.code,{children:"offset1"})," represents the block's offset position in the original file."]}),"\n",(0,t.jsx)(i.h3,{id:"3-multi-queue-mechanism",children:"(3) Multi-Queue Mechanism"}),"\n",(0,t.jsx)(i.p,{children:"Doris' file cache uses a multi-queue mechanism to separate different data types, preventing cache pollution and improving hit rates. Cache data is categorized into the following types, each stored in separate queues prioritized by importance:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"TTL Queue: Stores data with TTL (Time-To-Live) attributes. This data remains in cache for the specified TTL duration and has the highest priority during that period. When cache space is insufficient, the system preferentially evicts data from other queues to preserve TTL data. TTL is a table attribute - for example, setting it to 3600 means data imported into this table should remain in file cache for 1 hour after import. Use case: Suitable for small-scale tables that need local persistence, such as resident tables with long TTL values."}),"\n",(0,t.jsx)(i.li,{children:'Index Queue: Stores index data primarily used to accelerate query filtering operations, typically with high access frequency. Note: Inverted index files, despite being "indexes", are treated as normal cache data due to their typically large size.'}),"\n",(0,t.jsx)(i.li,{children:"Normal Queue: Stores regular data without TTL attributes. Most data falls into this category."}),"\n",(0,t.jsx)(i.li,{children:"Disposable Queue: Stores temporary data like compaction reads. This data is typically evicted after use and has the lowest priority."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"This multi-queue mechanism enables Doris to allocate cache space rationally based on different data characteristics and usage scenarios, maximizing cache resource utilization."}),"\n",(0,t.jsx)(i.h3,{id:"4-eviction-mechanism",children:"(4) Eviction Mechanism"}),"\n",(0,t.jsx)(i.p,{children:"The cache eviction mechanism is crucial for file cache management, determining how to select data for eviction when space is limited. Doris' eviction mechanism includes the following triggers and selection strategies:"}),"\n",(0,t.jsx)(i.p,{children:"Eviction Triggers:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Passive eviction due to space constraints:\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"When local disk space or inode count is insufficient, Doris triggers passive eviction to free space."}),"\n",(0,t.jsx)(i.li,{children:"When reaching cache capacity limits: Even if disk space remains, eviction starts when cache usage reaches predefined thresholds."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.li,{children:"Proactive early eviction: Unlike synchronous eviction where new data must wait for old data to be evicted (impacting query performance), Doris asynchronously cleans old caches when usage reaches high-water marks."}),"\n",(0,t.jsx)(i.li,{children:"Proactive garbage collection: While LRU can evict unused data, Doris actively cleans garbage data like compaction/Schema Change original data, failed import rollback data, and dropped table/partition data."}),"\n",(0,t.jsx)(i.li,{children:"TTL expiration: Unique to TTL data. When TTL expires, data is demoted to the normal cache and participates in regular eviction."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Eviction Target Selection:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Eviction ratio: Queues share disk space with individual ratio limits. When space is abundant (other queues haven't reached their ratios), a queue can use all remaining space. For example, the normal cache might be limited to 40% of total space but can use all available space if no other data exists. As other queue data enters, ratios gradually approach preset values."}),"\n",(0,t.jsx)(i.li,{children:"Eviction order: When write cache space is insufficient, Doris evicts data in this sequence: Disposable \u2192 Normal \u2192 Index \u2192 TTL. If evicting other queue data still doesn't free enough space, LRU eviction occurs within the same queue type."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Eviction Avoidance Recommendations:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Sufficient disk space: Ensure adequate space to accommodate cache data, avoiding frequent evictions due to space constraints. Since cache cleanup has latency, maintain some buffer. Experience shows file cache space should be about 1.5\xd7 query hot data size for optimal hit rates."}),"\n",(0,t.jsx)(i.li,{children:"Isolate large queries: Route large queries to separate clusters to prevent them from occupying cache space and affecting other queries' hit rates."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"5-warm-up-mechanism",children:"(5) Warm-up Mechanism"}),"\n",(0,t.jsx)(i.p,{children:"Cache warm-up preloads data into cache to accelerate subsequent queries. Doris provides multiple warm-up approaches:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Manual warm-up: Users can warm up current cluster caches for specific tables/partitions, or reference another cluster to warm up its cached tables/partitions. Warm-up always downloads from remote storage (not other clusters/BEs). After execution, targets (tables/partitions or reference clusters) are converted to tablet sets for BE download. BE download logic essentially performs sequential reads of all tablet data files to cache them locally. Since warm-up data volume can be large, Doris splits tasks into 20GB-max batches with checkpoints for recovery after interruptions. If BEs encounter severe issues (e.g., crashes) or users cancel warm-up, all BEs stop downloads. Users can check job status (",(0,t.jsx)(i.code,{children:"FINISHED"}),", ",(0,t.jsx)(i.code,{children:"CANCELLED"}),", ",(0,t.jsx)(i.code,{children:"RUNNING"}),") via ",(0,t.jsx)(i.code,{children:"SHOW WARM UP JOB"}),", including progress for running jobs. Repeated warm-ups for same tables/partitions won't redownload existing data, only performing incremental updates."]}),"\n",(0,t.jsx)(i.li,{children:"Load balancing-triggered warm-up: When tablet distribution becomes unbalanced (especially during node failures or scaling), tablets migrate to new BEs. Target BEs then download cache data using metadata from source BEs (if available), ensuring query cache hits on new nodes. Source BE cache data is actively evicted during cleanup. Note: There's a time window between migration and complete download where cache misses may occur."}),"\n",(0,t.jsxs)(i.li,{children:["Cross-cluster auto warm-up (v3.1+): In compute-storage separation scenarios, users may want automatic cache synchronization between compute clusters (e.g., when imports occur in Cluster A but queries in Cluster B). Doris offers two auto-sync methods:\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Periodic warm-up: For non-real-time requirements, add sync intervals in ",(0,t.jsx)(i.code,{children:"WARM UP"})," SQL. Instead of one-time execution, tasks periodically sync specified tables/partitions from one cluster to another incrementally."]}),"\n",(0,t.jsx)(i.li,{children:"Import/compaction-triggered warm-up: For real-time requirements, use import completion events to trigger warm-up. Since tablets may distribute differently across clusters, FE informs source clusters about target cluster tablet distribution. During source cluster import commit phase, it notifies target cluster BEs to download newly imported remote storage data. Compaction follows similar notification paths for warm-up."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"scenario-analysis",children:"Scenario Analysis"}),"\n",(0,t.jsx)(i.h3,{id:"1-file-cache-in-query-processing",children:"(1) File Cache in Query Processing"}),"\n",(0,t.jsx)(i.p,{children:"During queries, file cache reduces remote storage access and accelerates data retrieval:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Scanner reads data files: When queries arrive, Scanner attempts to read required data files."}),"\n",(0,t.jsx)(i.li,{children:"Local cache check: Before accessing remote storage, Scanner first checks local file cache."}),"\n",(0,t.jsx)(i.li,{children:"Cache hit: If cache metadata contains the requested file path and offset, it returns BlockFile handles for Scanner to read directly, avoiding remote downloads and reducing latency."}),"\n",(0,t.jsx)(i.li,{children:"Cache miss: For partially or completely uncached ranges, Scanner downloads missing data from remote storage. Downloaded data enters file cache for future queries while following eviction policies."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"2-file-cache-in-data-loading",children:"(2) File Cache in Data Loading"}),"\n",(0,t.jsx)(i.p,{children:"During imports, file cache prepares data for subsequent queries:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Data upload to remote storage: Imported data first goes to remote storage."}),"\n",(0,t.jsx)(i.li,{children:"Async local cache write: Doris asynchronously writes this data to local disk cache, enabling immediate cache hits for post-import queries."}),"\n",(0,t.jsx)(i.li,{children:"Cache type: Based on data type and attributes (e.g., TTL), imported data enters corresponding queues (TTL, Index, or Normal)."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"3-file-cache-in-compaction",children:"(3) File Cache in Compaction"}),"\n",(0,t.jsx)(i.p,{children:"Compaction optimizes storage and query performance by merging small files. Doris has two types:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Cumulative Compaction: Merges incremental data versions"}),"\n",(0,t.jsx)(i.li,{children:"Base Compaction: Merges baseline data (version 0) with incremental versions"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Cache handling during compaction:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Cumulative Compaction: Newly merged data enters file cache after remote storage upload, similar to imports, accelerating subsequent queries."}),"\n",(0,t.jsxs)(i.li,{children:["Base Compaction: Since Base Compaction typically involves large cold data, new data only enters cache when space permits. Users can force cache insertion via BE config ",(0,t.jsx)(i.code,{children:"enable_file_cache_keep_base_compaction_output = true"}),", but this may evict other hot data. Future versions plan adaptive strategies using historical query stats to determine cache insertion."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"4-cache-loading-after-restart",children:"(4) Cache Loading After Restart"}),"\n",(0,t.jsx)(i.p,{children:"Post-restart cache loading is critical for cache state recovery and quick query response. Pre-v3.1, unpreserved LRU information caused inconsistent queue ordering, affecting hit rates."}),"\n",(0,t.jsx)(i.p,{children:"v3.1 introduces LRU persistence:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Periodic dump: Doris periodically dumps LRU queue order info to disk."}),"\n",(0,t.jsx)(i.li,{children:"Post-restart load: Nodes reload dumped LRU info to restore queue states."}),"\n",(0,t.jsx)(i.li,{children:"Full-disk scan: To address potential metadata-file inconsistencies from periodic dumps, Doris performs a full-disk scan after LRU loading for completeness."}),"\n",(0,t.jsx)(i.li,{children:"Query-triggered async load: Since scanning takes time, BEs can serve queries during the process. If queries access unscanned data, early loading occurs to minimize latency."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"5-cache-handling-during-scaling",children:"(5) Cache Handling During Scaling"}),"\n",(0,t.jsx)(i.p,{children:"Scaling operations are common in cluster management. Doris handles file cache during scaling as follows:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Horizontal scale-out: During tablet migration to new BEs, target BEs download cache data using metadata from source BEs, ensuring cache hits on new nodes."}),"\n",(0,t.jsx)(i.li,{children:"Horizontal scale-in: Similar to scale-out, but when reduced cluster cache capacity falls below actual cache size, eviction occurs following standard mechanisms."}),"\n",(0,t.jsxs)(i.li,{children:["Vertical scale-out:\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Adding disks: Not recommended since Doris doesn't rehash or balance across disks. Cache directory changes may cause lookup failures. If necessary, clear cache and warm up as needed."}),"\n",(0,t.jsxs)(i.li,{children:["Increasing disk capacity: For same-disk-count capacity expansion, use ",(0,t.jsx)(i.code,{children:"curl http://BE_IP:WEB_PORT/api/file_cache?op=reset&capacity=123456"})," to notify BEs."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["Vertical scale-in:\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Reducing disk space: Also requires the ",(0,t.jsx)(i.code,{children:"reset"})," operation. When new capacity is below cache size, eviction occurs per standard mechanisms."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["Post-scaling warm-up notes: Since horizontal scaling involves tablet rebalancing, wait for stabilization before warm-up for effectiveness. Monitor ",(0,t.jsx)(i.code,{children:"doris_fe_tablet_num"})," metrics - when the curve stabilizes, warm-up completes."]}),"\n"]})]})}function h(e={}){let{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},250065:function(e,i,a){a.d(i,{Z:function(){return r},a:function(){return c}});var n=a(667294);let t={},s=n.createContext(t);function c(e){let i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);