"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["187015"],{869459:function(e,n,t){t.r(n),t.d(n,{default:()=>u,frontMatter:()=>r,metadata:()=>a,assets:()=>o,toc:()=>d,contentTitle:()=>s});var a=JSON.parse('{"id":"data-operate/update/partial-column-update","title":"Partial Column Update","description":"This document explains how to perform partial column updates in Doris for Unique Key Model and Aggregate Key Model tables.","source":"@site/versioned_docs/version-3.x/data-operate/update/partial-column-update.md","sourceDirName":"data-operate/update","slug":"/data-operate/update/partial-column-update","permalink":"/docs/3.x/data-operate/update/partial-column-update","draft":false,"unlisted":false,"tags":[],"version":"3.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Partial Column Update","language":"en","description":"This document explains how to perform partial column updates in Doris for Unique Key Model and Aggregate Key Model tables."},"sidebar":"docs","previous":{"title":"Updating Data on Aggregate Key Model","permalink":"/docs/3.x/data-operate/update/update-of-aggregate-model"},"next":{"title":"Concurrency Control for Updates in the Primary Key Model","permalink":"/docs/3.x/data-operate/update/unique-update-concurrent-control"}}'),i=t("785893"),l=t("250065");let r={title:"Partial Column Update",language:"en",description:"This document explains how to perform partial column updates in Doris for Unique Key Model and Aggregate Key Model tables."},s=void 0,o={},d=[{value:"Overview",id:"overview",level:2},{value:"Partial Column Update for Unique Key Model",id:"partial-column-update-for-unique-key-model",level:2},{value:"Usage Example",id:"usage-example",level:3},{value:"Partial Column Update Using Load Methods",id:"partial-column-update-using-load-methods",level:3},{value:"StreamLoad/BrokerLoad/RoutineLoad",id:"streamloadbrokerloadroutineload",level:4},{value:"INSERT INTO",id:"insert-into",level:4},{value:"Flink Connector",id:"flink-connector",level:4},{value:"Update Result",id:"update-result",level:3},{value:"Usage Notes",id:"usage-notes",level:3},{value:"Flexible Partial Column Updates",id:"flexible-partial-column-updates",level:3},{value:"Applicable Scenarios",id:"applicable-scenarios",level:4},{value:"Usage",id:"usage",level:4},{value:"Example",id:"example",level:4},{value:"Limitations and Considerations",id:"limitations-and-considerations",level:4},{value:"Handling New Rows in Partial Column Updates",id:"handling-new-rows-in-partial-column-updates",level:3},{value:"Partial Column Update for Aggregate Key Model",id:"partial-column-update-for-aggregate-key-model",level:2},{value:"Create Table",id:"create-table",level:3},{value:"Data Insertion",id:"data-insertion",level:3},{value:"Example",id:"example-1",level:3},{value:"Notes on Partial Column Updates",id:"notes-on-partial-column-updates",level:3}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Partial column update allows you to update specific fields in a table without modifying all fields. This document explains how to perform partial column updates for both Unique Key Model and Aggregate Key Model tables."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Partial column update is a feature that enables you to update only specific columns in a table row, rather than updating the entire row. This is particularly useful for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Real-time dynamic column updates, requiring frequent updates of specific fields in the table. For example, updating fields related to the latest user behavior in a user tag table for real-time analysis and decision-making in advertising/recommendation systems."}),"\n",(0,i.jsx)(n.li,{children:"Merging multiple source tables into one large wide table."}),"\n",(0,i.jsx)(n.li,{children:"Data correction."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"partial-column-update-for-unique-key-model",children:"Partial Column Update for Unique Key Model"}),"\n",(0,i.jsx)(n.p,{children:"Doris provides a feature to directly insert or update partial column data in the unique key model load update, bypassing the need to read the entire row first, thus significantly improving update efficiency."}),"\n",(0,i.jsx)(n.admonition,{title:"Note",type:"caution",children:(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Version 2.0 only supports partial column updates in the Merge-on-Write implementation of the Unique Key."}),"\n",(0,i.jsx)(n.li,{children:"Starting from version 2.0.2, partial column updates are supported using INSERT INTO."}),"\n",(0,i.jsx)(n.li,{children:"Partial column updates are not supported on tables with synchronized materialized views."}),"\n",(0,i.jsx)(n.li,{children:"Partial column updates are not allowed on tables doing schema change."}),"\n"]})}),"\n",(0,i.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,i.jsxs)(n.p,{children:["Assume there is an order table ",(0,i.jsx)(n.code,{children:"order_tbl"})," in Doris, where the order id is the Key column, and the order status and order amount are the Value columns. The data status is as follows:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Order id"}),(0,i.jsx)(n.th,{children:"Order Amount"}),(0,i.jsx)(n.th,{children:"Order Status"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"100"}),(0,i.jsx)(n.td,{children:"Pending Payment"})]})})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"+----------+--------------+--------------+\n| order_id | order_amount | order_status |\n+----------+--------------+--------------+\n| 1        |          100 | Pending Payment |\n+----------+--------------+--------------+\n1 row in set (0.01 sec)\n"})}),"\n",(0,i.jsx)(n.p,{children:"After the user clicks to pay, the Doris system needs to change the order status of the order with order id '1' to 'Pending Shipment'."}),"\n",(0,i.jsx)(n.h3,{id:"partial-column-update-using-load-methods",children:"Partial Column Update Using Load Methods"}),"\n",(0,i.jsx)(n.h4,{id:"streamloadbrokerloadroutineload",children:"StreamLoad/BrokerLoad/RoutineLoad"}),"\n",(0,i.jsx)(n.p,{children:"Prepare the following CSV file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"1,Pending Shipment\n"})}),"\n",(0,i.jsx)(n.p,{children:"Add the following header during load:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"partial_columns:true\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Specify the columns to be loaded in ",(0,i.jsx)(n.code,{children:"columns"})," (must include all key columns). Below is an example of Stream Load:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'curl --location-trusted -u root: -H "partial_columns:true" -H "column_separator:," -H "columns:order_id,order_status" -T /tmp/update.csv http://127.0.0.1:8030/api/db1/order_tbl/_stream_load\n'})}),"\n",(0,i.jsx)(n.h4,{id:"insert-into",children:"INSERT INTO"}),"\n",(0,i.jsxs)(n.p,{children:["In all data models, the default behavior of ",(0,i.jsx)(n.code,{children:"INSERT INTO"})," when given partial columns is to write the entire row. To prevent misuse, in the Merge-on-Write implementation, ",(0,i.jsx)(n.code,{children:"INSERT INTO"})," maintains the semantics of whole row UPSERT by default. To enable partial column updates, set the following session variable:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SET enable_unique_key_partial_update=true;\nINSERT INTO order_tbl (order_id, order_status) VALUES (1, 'Pending Shipment');\n"})}),"\n",(0,i.jsx)(n.admonition,{title:"Note:",type:"caution",children:(0,i.jsxs)(n.p,{children:["Note that the session variable ",(0,i.jsx)(n.code,{children:"enable_insert_strict"})," defaults to true, enabling strict mode by default. In version 3.0.x, partial column updates do not allow updating non-existent keys in strict mode. To insert non-existent keys using the insert statement for partial column updates, set ",(0,i.jsx)(n.code,{children:"enable_unique_key_partial_update"})," to true and ",(0,i.jsx)(n.code,{children:"enable_insert_strict"})," to false."]})}),"\n",(0,i.jsx)(n.h4,{id:"flink-connector",children:"Flink Connector"}),"\n",(0,i.jsx)(n.p,{children:"If using Flink Connector, add the following configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"'sink.properties.partial_columns' = 'true',\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Specify the columns to be loaded in ",(0,i.jsx)(n.code,{children:"sink.properties.column"})," (must include all key columns)."]}),"\n",(0,i.jsx)(n.h3,{id:"update-result",children:"Update Result"}),"\n",(0,i.jsx)(n.p,{children:"The result after the update is as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"+----------+--------------+--------------+\n| order_id | order_amount | order_status |\n+----------+--------------+--------------+\n| 1        |          100 | Pending Shipment |\n+----------+--------------+--------------+\n1 row in set (0.01 sec)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"usage-notes",children:"Usage Notes"}),"\n",(0,i.jsx)(n.p,{children:"Since the Merge-on-Write implementation needs to complete the entire row of data during writing to ensure optimal query performance, using it for partial column updates may decrease partial load performance."}),"\n",(0,i.jsx)(n.p,{children:"Performance optimization suggestions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use SSDs equipped with NVMe or high-speed SSD cloud disks, as completing data will read a large amount of historical data, generating high read IOPS and throughput."}),"\n",(0,i.jsx)(n.li,{children:"Enabling row storage can reduce the IOPS generated when completing data, significantly improving load performance. Enable row storage by setting the following property when creating a table:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Plain",children:'"store_row_column" = "true"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Currently, all rows in the same batch data writing task (whether a load task or ",(0,i.jsx)(n.code,{children:"INSERT INTO"}),") can only update the same columns. To update data with different columns, write in different batches."]}),"\n",(0,i.jsx)(n.h3,{id:"flexible-partial-column-updates",children:"Flexible Partial Column Updates"}),"\n",(0,i.jsx)(n.p,{children:"Previously, Doris's partial update feature required that every row in an import update the same columns. Now, Doris supports a more flexible partial update method that allows each row in a single import to update different columns (supported since 3.1.0)."}),"\n",(0,i.jsx)(n.admonition,{title:"Note:",type:"caution",children:(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Currently, only the Stream Load import method and tools using Stream Load (e.g. Doris-Flink-Connector) support this feature."}),"\n",(0,i.jsx)(n.li,{children:"The import file must be in JSON format when using flexible column updates."}),"\n"]})}),"\n",(0,i.jsx)(n.h4,{id:"applicable-scenarios",children:"Applicable Scenarios"}),"\n",(0,i.jsx)(n.p,{children:"When using CDC to synchronize data from a database system to Doris in real-time, the records output by the source system may not contain complete row data, but only the values of the primary keys and the updated columns. In such cases, the columns updated in a batch of data within a time window may differ. Flexible column updates can be used to import data into Doris."}),"\n",(0,i.jsx)(n.h4,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Enabling Flexible Column Updates for Existing Tables"})}),"\n",(0,i.jsxs)(n.p,{children:["For existing Merge-On-Write tables created in old versions of Doris, after upgrading, you can enable flexible partial updates using the command: ",(0,i.jsx)(n.code,{children:'ALTER TABLE db1.tbl1 ENABLE FEATURE "UPDATE_FLEXIBLE_COLUMNS";'}),". After executing this command, if the result of ",(0,i.jsx)(n.code,{children:"show create table db1.tbl1"})," includes ",(0,i.jsx)(n.code,{children:'"enable_unique_key_skip_bitmap_column" = "true"'}),", the feature has been successfully enabled. Ensure that the target table has the light-schema-change feature enabled beforehand."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Using Flexible Column Updates for New Tables"})}),"\n",(0,i.jsx)(n.p,{children:"For new tables, to use the flexible column update feature, specify the following table properties when creating the table to enable Merge-on-Write and include the required hidden bitmap column for flexible column updates:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Plain",children:'"enable_unique_key_merge_on_write" = "true"\n"enable_unique_key_skip_bitmap_column" = "true"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"StreamLoad"})}),"\n",(0,i.jsx)(n.p,{children:"When using Stream Load, add the following header:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Plain",children:"unique_key_update_mode:UPDATE_FLEXIBLE_COLUMNS\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Flink Doris Connector"})}),"\n",(0,i.jsx)(n.p,{children:"If using the Flink Doris Connector, add the following configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Plain",children:"'sink.properties.unique_key_update_mode' = 'UPDATE_FLEXIBLE_COLUMNS'\n"})}),"\n",(0,i.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.p,{children:"Assuming the following table:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE t1 (\n  `k` int(11) NULL, \n  `v1` BIGINT NULL,\n  `v2` BIGINT NULL DEFAULT "9876",\n  `v3` BIGINT NOT NULL,\n  `v4` BIGINT NOT NULL DEFAULT "1234",\n  `v5` BIGINT NULL\n) UNIQUE KEY(`k`) DISTRIBUTED BY HASH(`k`) BUCKETS 1\nPROPERTIES(\n"replication_num" = "3",\n"enable_unique_key_merge_on_write" = "true",\n"enable_unique_key_skip_bitmap_column" = "true");\n'})}),"\n",(0,i.jsx)(n.p,{children:"The original data in the table is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"MySQL root@127.1:d1> select * from t1;\n+---+----+----+----+----+----+\n| k | v1 | v2 | v3 | v4 | v5 |\n+---+----+----+----+----+----+\n| 0 | 0  | 0  | 0  | 0  | 0  |\n| 1 | 1  | 1  | 1  | 1  | 1  |\n| 2 | 2  | 2  | 2  | 2  | 2  |\n| 3 | 3  | 3  | 3  | 3  | 3  |\n| 4 | 4  | 4  | 4  | 4  | 4  |\n| 5 | 5  | 5  | 5  | 5  | 5  |\n+---+----+----+----+----+----+\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now, updating some fields using flexible column updates:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"$ cat test1.json\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{"k": 0, "__DORIS_DELETE_SIGN__": 1}\n{"k": 1, "v1": 10}\n{"k": 2, "v2": 20, "v5": 25}\n{"k": 3, "v3": 30}\n{"k": 4, "v4": 20, "v1": 43, "v3": 99}\n{"k": 5, "v5": null}\n{"k": 6, "v1": 999, "v3": 777}\n{"k": 2, "v4": 222}\n{"k": 1, "v2": 111, "v3": 111}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'curl --location-trusted -u root: \\\n-H "strict_mode:false" \\\n-H "format:json" \\\n-H "read_json_by_line:true" \\\n-H "unique_key_update_mode:UPDATE_FLEXIBLE_COLUMNS" \\\n-T test1.json \\\n-XPUT http://<host>:<http_port>/api/d1/t1/_stream_load\n'})}),"\n",(0,i.jsx)(n.p,{children:"After the update, the data in the table is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"MySQL root@127.1:d1> select * from t1;\n+---+-----+------+-----+------+--------+\n| k | v1  | v2   | v3  | v4   | v5     |\n+---+-----+------+-----+------+--------+\n| 1 | 10  | 111  | 111 | 1    | 1      |\n| 2 | 2   | 20   | 2   | 222  | 25     |\n| 3 | 3   | 3    | 30  | 3    | 3      |\n| 4 | 43  | 4    | 99  | 20   | 4      |\n| 5 | 5   | 5    | 5   | 5    | <null> |\n| 6 | 999 | 9876 | 777 | 1234 | <null> |\n+---+-----+------+-----+------+--------+\n"})}),"\n",(0,i.jsx)(n.h4,{id:"limitations-and-considerations",children:"Limitations and Considerations"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Similar to previous partial updates, flexible column updates require that each row of imported data include all key columns. Rows not meeting this requirement will be filtered out and counted in filter rows. If the number of filtered rows exceeds the ",(0,i.jsx)(n.code,{children:"max_filter_ratio"})," threshold for this import, the entire import will fail, and filtered data will generate an error log."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["In flexible partial update loads, key-value pairs in each JSON object are only valid if the key matches a column name in the target table. Key-value pairs that do not meet this requirement will be ignored. Pairs with keys ",(0,i.jsx)(n.code,{children:"__DORIS_VERSION_COL__"}),", ",(0,i.jsx)(n.code,{children:"__DORIS_ROW_STORE_COL__"}),", or ",(0,i.jsx)(n.code,{children:"__DORIS_SKIP_BITMAP_COL__"})," will also be ignored."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Flexible partial updates are not supported on tables with Variant columns."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Flexible partial updates are not supported on tables with synchronous materialized views."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"When using flexible partial updates, the following import parameters cannot be specified or enabled:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"merge_type"})," parameter cannot be specified."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"delete"})," parameter cannot be specified."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"fuzzy_parse"})," parameter cannot be enabled."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"columns"})," parameter cannot be specified."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"jsonpaths"})," parameter cannot be specified."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"hidden_columns"})," parameter cannot be specified."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"function_column.sequence_col"})," parameter cannot be specified."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"sql"})," parameter cannot be specified."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"memtable_on_sink_node"})," option cannot be enabled."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"group_commit"})," parameter cannot be specified."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"where"})," parameter cannot be specified."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"handling-new-rows-in-partial-column-updates",children:"Handling New Rows in Partial Column Updates"}),"\n",(0,i.jsxs)(n.p,{children:["In the 3.0.x series, whether strict mode is enabled during import controls the behavior of newly inserted rows in Partial Column Update. For details, see the documentation on ",(0,i.jsx)(n.a,{href:"/docs/3.x/data-operate/import/handling-messy-data#restricting-partial-column-updates-to-existing-columns-only",children:"Strict Mode"}),".\nStarting from version 3.1.0, the session variable or import property ",(0,i.jsx)(n.code,{children:"partial_update_new_key_behavior"})," controls the behavior when inserting new rows during partial column updates."]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"partial_update_new_key_behavior=ERROR"}),", each inserted row must have a key that already exists in the table. When ",(0,i.jsx)(n.code,{children:"partial_update_new_key_behavior=APPEND"}),", partial column updates can update existing rows with matching keys or insert new rows with keys that do not exist in the table."]}),"\n",(0,i.jsx)(n.p,{children:"For example, consider the following table structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE user_profile\n(\n  id               INT,\n  name             VARCHAR(10),\n  age              INT,\n  city             VARCHAR(10),\n  balance          DECIMAL(9, 0),\n  last_access_time DATETIME\n) ENGINE=OLAP\nUNIQUE KEY(id)\nDISTRIBUTED BY HASH(id) BUCKETS 1\nPROPERTIES (\n  "enable_unique_key_merge_on_write" = "true"\n);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Suppose the table contains the following data:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"mysql> select * from user_profile;\n+------+-------+------+----------+---------+---------------------+\n| id   | name  | age  | city     | balance | last_access_time    |\n+------+-------+------+----------+---------+---------------------+\n|    1 | kevin |   18 | shenzhen |     400 | 2023-07-01 12:00:00|\n+------+-------+------+----------+---------+---------------------+\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you use ",(0,i.jsx)(n.code,{children:"Insert Into"})," for partial column updates with ",(0,i.jsx)(n.code,{children:"partial_update_new_key_behavior=ERROR"}),", and try to insert the following data, the operation will fail because the keys ",(0,i.jsx)(n.code,{children:"(3)"})," and ",(0,i.jsx)(n.code,{children:"(18)"})," do not exist in the original table:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SET enable_unique_key_partial_update=true;\nSET partial_update_new_key_behavior=ERROR;\nINSERT INTO user_profile (id, balance, last_access_time) VALUES\n(1, 500, '2023-07-03 12:00:01'),\n(3, 23, '2023-07-03 12:00:02'),\n(18, 9999999, '2023-07-03 12:00:03');\n(1105, \"errCode = 2, detailMessage = (127.0.0.1)[INTERNAL_ERROR]tablet error: [E-7003]Can't append new rows in partial update when partial_update_new_key_behavior is ERROR. Row with key=[3] is not in table., host: 127.0.0.1\")\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you use ",(0,i.jsx)(n.code,{children:"partial_update_new_key_behavior=APPEND"})," and perform the same partial column update:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SET enable_unique_key_partial_update=true;\nSET partial_update_new_key_behavior=APPEND;\nINSERT INTO user_profile (id, balance, last_access_time) VALUES \n(1, 500, '2023-07-03 12:00:01'),\n(3, 23, '2023-07-03 12:00:02'),\n(18, 9999999, '2023-07-03 12:00:03');\n"})}),"\n",(0,i.jsx)(n.p,{children:"The existing row will be updated, and two new rows will be inserted. For columns not specified in the inserted data, if a default value is defined, the default will be used; if the column is nullable, NULL will be used; otherwise, the insert will fail."}),"\n",(0,i.jsx)(n.p,{children:"The query result will be:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"mysql> select * from user_profile;\n+------+-------+------+----------+---------+---------------------+\n| id   | name  | age  | city     | balance | last_access_time    |\n+------+-------+------+----------+---------+---------------------+\n|    1 | kevin |   18 | shenzhen |     500 | 2023-07-03 12:00:01 |\n|    3 | NULL  | NULL | NULL     |      23 | 2023-07-03 12:00:02 |\n|   18 | NULL  | NULL | NULL     | 9999999 | 2023-07-03 12:00:03 |\n+------+-------+------+----------+---------+---------------------+\n"})}),"\n",(0,i.jsx)(n.h2,{id:"partial-column-update-for-aggregate-key-model",children:"Partial Column Update for Aggregate Key Model"}),"\n",(0,i.jsx)(n.p,{children:"The Aggregate table is mainly used in pre-aggregation scenarios rather than data update scenarios, but partial column updates can be achieved by setting the aggregation function to REPLACE_IF_NOT_NULL."}),"\n",(0,i.jsx)(n.h3,{id:"create-table",children:"Create Table"}),"\n",(0,i.jsxs)(n.p,{children:["Set the aggregation function of the fields that need to be updated to ",(0,i.jsx)(n.code,{children:"REPLACE_IF_NOT_NULL"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE order_tbl (\n  order_id int(11) NULL,\n  order_amount int(11) REPLACE_IF_NOT_NULL NULL,\n  order_status varchar(100) REPLACE_IF_NOT_NULL NULL\n) ENGINE=OLAP\nAGGREGATE KEY(order_id)\nCOMMENT \'OLAP\'\nDISTRIBUTED BY HASH(order_id) BUCKETS 1\nPROPERTIES (\n"replication_allocation" = "tag.location.default: 1"\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"data-insertion",children:"Data Insertion"}),"\n",(0,i.jsxs)(n.p,{children:["Whether it is Stream Load, Broker Load, Routine Load, or ",(0,i.jsx)(n.code,{children:"INSERT INTO"}),", directly write the data of the fields to be updated."]}),"\n",(0,i.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,i.jsx)(n.p,{children:"Similar to the previous examples, the corresponding Stream Load command is (no additional header required):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'$ cat update.csv\n\n1,To be shipped\n\ncurl  --location-trusted -u root: -H "column_separator:," -H "columns:order_id,order_status" -T ./update.csv http://127.0.0.1:8030/api/db1/order_tbl/_stream_load\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The corresponding ",(0,i.jsx)(n.code,{children:"INSERT INTO"})," statement is (no additional session variable settings required):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"INSERT INTO order_tbl (order_id, order_status) values (1,'Shipped');\n"})}),"\n",(0,i.jsx)(n.h3,{id:"notes-on-partial-column-updates",children:"Notes on Partial Column Updates"}),"\n",(0,i.jsx)(n.p,{children:"The Aggregate Key model does not perform any additional processing during the write process, so the write performance is not affected and is the same as normal data load. However, the cost of aggregation during query is relatively high, and the typical aggregation query performance is 5-10 times lower than the Merge-on-Write implementation of the Unique Key model."}),"\n",(0,i.jsxs)(n.p,{children:["Since the ",(0,i.jsx)(n.code,{children:"REPLACE_IF_NOT_NULL"})," aggregation function only takes effect when the value is not NULL, users cannot change a field value to NULL."]})]})}function u(e={}){let{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return s},a:function(){return r}});var a=t(667294);let i={},l=a.createContext(i);function r(e){let n=a.useContext(l);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(l.Provider,{value:n},e.children)}}}]);