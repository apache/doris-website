"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["230067"],{464929:function(e,n,t){t.r(n),t.d(n,{default:()=>p,frontMatter:()=>o,metadata:()=>r,assets:()=>d,toc:()=>c,contentTitle:()=>s});var r=JSON.parse('{"id":"how-to-contribute/jdbc-catalog-developer-guide","title":"JDBC Catalog Developer Guide","description":"\x3c!--","source":"@site/community/how-to-contribute/jdbc-catalog-developer-guide.md","sourceDirName":"how-to-contribute","slug":"/how-to-contribute/jdbc-catalog-developer-guide","permalink":"/community/how-to-contribute/jdbc-catalog-developer-guide","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"JDBC Catalog Developer Guide","language":"en"},"sidebar":"community","previous":{"title":"Trino Connector Developer Guide","permalink":"/community/how-to-contribute/trino-connector-developer-guide"},"next":{"title":"Doris Versioning","permalink":"/community/release-versioning"}}'),a=t("785893"),i=t("250065");let o={title:"JDBC Catalog Developer Guide",language:"en"},s=void 0,d={},c=[{value:"1. Overview",id:"1-overview",level:2},{value:"2. Architecture Overview",id:"2-architecture-overview",level:2},{value:"2.1 Overall Architecture",id:"21-overall-architecture",level:3},{value:"2.2 Core Components",id:"22-core-components",level:3},{value:"Frontend Core Components",id:"frontend-core-components",level:4},{value:"Backend Core Components",id:"backend-core-components",level:4},{value:"3. Development Steps for Adding New Data Source",id:"3-development-steps-for-adding-new-data-source",level:2},{value:"Step 1: Update Thrift Definition",id:"step-1-update-thrift-definition",level:3},{value:"Step 2: Define Core Metadata in Frontend",id:"step-2-define-core-metadata-in-frontend",level:3},{value:"Step 3: Implement Frontend Metadata Client (JdbcClient)",id:"step-3-implement-frontend-metadata-client-jdbcclient",level:3},{value:"Core Logic for Metadata Interaction",id:"core-logic-for-metadata-interaction",level:4},{value:"Register <code>JdbcNewDBClient</code> in Factory Class",id:"register-jdbcnewdbclient-in-factory-class",level:4},{value:"Step 4: Adapt Frontend Query Planning (JdbcScanNode)",id:"step-4-adapt-frontend-query-planning-jdbcscannode",level:3},{value:"Step 5: Implement Backend Data Executor (JdbcExecutor)",id:"step-5-implement-backend-data-executor-jdbcexecutor",level:3},{value:"Core Logic for Data Reading",id:"core-logic-for-data-reading",level:4},{value:"Register <code>NewDBJdbcExecutor</code> in Factory Class",id:"register-newdbjdbcexecutor-in-factory-class",level:4},{value:"Step 6: Add Regression Tests",id:"step-6-add-regression-tests",level:3},{value:"4. Development Considerations",id:"4-development-considerations",level:2},{value:"4.1 Data Type Mapping",id:"41-data-type-mapping",level:3},{value:"4.2 Data Source Specific Data Reading",id:"42-data-source-specific-data-reading",level:3},{value:"4.3 Error Handling",id:"43-error-handling",level:3},{value:"4.4 Predicate and Function Pushdown (Optional Optimization)",id:"44-predicate-and-function-pushdown-optional-optimization",level:3},{value:"5. Deployment Configuration",id:"5-deployment-configuration",level:2},{value:"5.1 Driver Deployment",id:"51-driver-deployment",level:3},{value:"5.2 Create Catalog",id:"52-create-catalog",level:3}];function l(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"1-overview",children:"1. Overview"}),"\n",(0,a.jsx)(n.p,{children:"Apache Doris's JdbcCatalog provides access to external databases through the JDBC protocol."}),"\n",(0,a.jsxs)(n.p,{children:["This document provides detailed instructions on how to add support for a new data source type to JdbcCatalog, using the addition of ",(0,a.jsx)(n.strong,{children:"NewDB"})," data source as an example."]}),"\n",(0,a.jsx)(n.p,{children:"This document is for version 3.0+."}),"\n",(0,a.jsx)(n.h2,{id:"2-architecture-overview",children:"2. Architecture Overview"}),"\n",(0,a.jsx)(n.h3,{id:"21-overall-architecture",children:"2.1 Overall Architecture"}),"\n",(0,a.jsx)(n.p,{children:"JdbcCatalog adopts a Frontend (FE) and Backend (BE) separated architecture:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Frontend (FE): Responsible for metadata management, SQL parsing, query planning and optimization."}),"\n",(0,a.jsx)(n.li,{children:"Backend (BE): Responsible for data scanning, type conversion and execution."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"22-core-components",children:"2.2 Core Components"}),"\n",(0,a.jsx)(n.h4,{id:"frontend-core-components",children:"Frontend Core Components"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"JdbcResource"}),": Defines JDBC connection resources and parameters."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"JdbcExternalCatalog"}),": Manages the entire Catalog, creates and manages JdbcClient."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"JdbcExternalDatabase"}),": Manages database-level metadata."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"JdbcExternalTable"}),": Manages table-level metadata and Schema."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"JdbcClient"}),": Abstract base class that handles metadata operations (getting database list, table list, column information, etc.)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"JdbcScanNode"}),": Scan node in query plan, responsible for generating query SQL."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"JdbcTableSink"}),": Sink node in write plan."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"backend-core-components",children:"Backend Core Components"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"vjdbc_connector.cpp"}),": C++ connector that calls Java executor through JNI. ",(0,a.jsx)(n.strong,{children:"(Developers do not need to modify this file)"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"BaseJdbcExecutor"}),": Java executor abstract base class that handles data read/write operations."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"JdbcExecutorFactory"}),": Factory class that creates corresponding executors based on data source type."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"3-development-steps-for-adding-new-data-source",children:"3. Development Steps for Adding New Data Source"}),"\n",(0,a.jsx)(n.h3,{id:"step-1-update-thrift-definition",children:"Step 1: Update Thrift Definition"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Modify Thrift file"}),"\n",(0,a.jsxs)(n.p,{children:["In the ",(0,a.jsx)(n.code,{children:"gensrc/thrift//Types.thrift"})," file, add new type to the ",(0,a.jsx)(n.code,{children:"TOdbcTableType"})," enum:"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Generate code"}),"\n",(0,a.jsx)(n.p,{children:"Execute the script in the Doris root directory to make the new enum values effective in Java and C++ code:"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"step-2-define-core-metadata-in-frontend",children:"Step 2: Define Core Metadata in Frontend"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Modify ",(0,a.jsx)(n.code,{children:"JdbcResource.java"})]}),"\n",(0,a.jsxs)(n.p,{children:["Add constants for NewDB's URL prefix and type name, and add recognition logic in the ",(0,a.jsx)(n.code,{children:"parseDbType"})," method."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Modify ",(0,a.jsx)(n.code,{children:"JdbcTable.java"})]}),"\n",(0,a.jsx)(n.p,{children:"Map NewDB type string to Thrift enum and define its SQL identifier reference style."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"step-3-implement-frontend-metadata-client-jdbcclient",children:"Step 3: Implement Frontend Metadata Client (JdbcClient)"}),"\n",(0,a.jsx)(n.h4,{id:"core-logic-for-metadata-interaction",children:"Core Logic for Metadata Interaction"}),"\n",(0,a.jsxs)(n.p,{children:["This step is the core of metadata interaction with external data sources. You need to create a ",(0,a.jsx)(n.code,{children:"JdbcNewDBClient.java"})," file in the ",(0,a.jsx)(n.code,{children:"doris/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/"})," directory and override the following key methods:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// doris/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcNewDBClient.java\n\npublic class JdbcNewDBClient extends JdbcClient {\n\n    public JdbcNewDBClient(JdbcClientConfig jdbcClientConfig) {\n        super(jdbcClientConfig);\n    }\n\n    /**\n     * [Must Override] Get database (or Schema) list.\n     * \n     * @return List of database names.\n     * @purpose This is the underlying implementation of the `SHOW DATABASES` command.\n     * @implementation\n     * 1. Get a JDBC Connection from the connection pool.\n     * 2. Use `connection.getMetaData().getCatalogs()` or `getSchemas()` to get the list.\n     * 3. Iterate through ResultSet and add database names to List<String>.\n     * 4. Call `filterDatabaseNames()` to filter out system databases and non-compliant databases.\n     */\n    @Override\n    public List<String> getDatabaseNameList() {\n        // Implement logic to get all NewDB database names\n    }\n\n    /**\n     * This is the underlying implementation of the `SHOW TABLES` command.\n     * \n     * @param remoteDbName Database name.\n     * @return List of table names.\n     */\n    @Override\n    public List<String> getTablesNameList(String remoteDbName) {\n        // Usually no need to override this method directly, but override processTable() that it calls internally\n        return super.getTablesNameList(remoteDbName);\n    }\n\n    /**\n     * [Must Override] Get table metadata.\n     * \n     * @purpose Called by getTablesNameList() and isTableExist() methods,\n     *          performs metadata lookup through `DatabaseMetaData.getTables()`.\n     * @implementation\n     * 1. Get JDBC Connection and DatabaseMetaData.\n     * 2. Call `databaseMetaData.getTables(catalog, schemaPattern, tableNamePattern, types)`.\n     * 3. The key is to pass correct values for `catalog` and `schemaPattern` parameters, which depends on NewDB\'s JDBC driver implementation.\n     *    - If NewDB uses Catalog, pass `remoteDbName` for catalog and `null` for schemaPattern.\n     *    - If NewDB uses Schema, pass `null` for catalog and `remoteDbName` for schemaPattern.\n     */\n    @Override\n    protected void processTable(String remoteDbName, String remoteTableName, String[] tableTypes,\n            Consumer<ResultSet> resultSetConsumer) {\n        // Implement logic to call DatabaseMetaData.getTables()\n    }\n\n    /**\n     * [Must Override] **Core Method** - Define mapping from NewDB types to Doris types.\n     * \n     * @param fieldSchema Contains column information obtained from JDBC Driver, such as type name (getDataTypeName),\n     *                    precision (getColumnSize), scale (getDecimalDigits), etc.\n     * @return Corresponding Doris `Type`.\n     */\n    @Override\n    public Type jdbcTypeToDoris(JdbcFieldSchema fieldSchema) {\n        // Return Doris Type based on information in fieldSchema\n        // For example:\n        // String newdbType = fieldSchema.getDataTypeName().toUpperCase();\n        // switch (newdbType) {\n        //     case "VARCHAR": return ScalarType.createStringType();\n        //     case "INTEGER": return Type.INT;\n        //     case "DECIMAL":\n        //         return ScalarType.createDecimalV3Type(fieldSchema.getColumnSize(), fieldSchema.getDecimalDigits());\n        //     // ... other type mappings\n        //     default: return Type.UNSUPPORTED;\n        // }\n    }\n    \n    /**\n     * [Recommended Override] Define system databases to filter out from `getDatabaseNameList` results.\n     */\n    @Override\n    protected Set<String> getFilterInternalDatabases() {\n        // return ImmutableSet.of("information_schema", "sys", "performance_schema", "newdb_system_db");\n    }\n\n    /**\n     * [Recommended Override] Define the query statement used for connection testing.\n     * Default is "SELECT 1", but some databases (like Oracle) need "SELECT 1 FROM DUAL".\n     */\n    @Override\n    public String getTestQuery() {\n        // return "SELECT 1"; // or simple query supported by NewDB\n    }\n\n    /**\n     * [Optional Override] Define what value the catalog parameter should be when calling `DatabaseMetaData` related methods.\n     * Default returns `connection.getCatalog()`. Should return `null` if NewDB doesn\'t support Catalog.\n     */\n    @Override\n    protected String getCatalogName(Connection conn) throws SQLException {\n        // return conn.getCatalog(); // or return null;\n    }\n\n    /**\n     * [Optional Override] Get column definitions.\n     * Default implementation is usually sufficient, but for some databases (like MySQL), you might need to execute a SHOW or SELECT query\n     * to get more precise type information (e.g., distinguish between `TINYINT(1)` and `TINYINT`).\n     */\n    @Override\n    public List<JdbcFieldSchema> getJdbcColumnsInfo(String remoteDbName, String remoteTableName) {\n        return super.getJdbcColumnsInfo(remoteDbName, remoteTableName);\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"register-jdbcnewdbclient-in-factory-class",children:["Register ",(0,a.jsx)(n.code,{children:"JdbcNewDBClient"})," in Factory Class"]}),"\n",(0,a.jsxs)(n.p,{children:["Modify ",(0,a.jsx)(n.code,{children:"doris/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/client/JdbcClient.java"}),":"]}),"\n",(0,a.jsx)(n.h3,{id:"step-4-adapt-frontend-query-planning-jdbcscannode",children:"Step 4: Adapt Frontend Query Planning (JdbcScanNode)"}),"\n",(0,a.jsxs)(n.p,{children:["In the ",(0,a.jsx)(n.code,{children:"getJdbcQueryStr()"})," method, add specific ",(0,a.jsx)(n.code,{children:"LIMIT"})," clause generation logic for NewDB."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// doris/fe/fe-core/src/main/java/org/apache/doris/datasource/jdbc/source/JdbcScanNode.java\n\nprivate String getJdbcQueryStr() {\n    // ...\n    // MSSQL use select top to do top n\n    if (shouldPushDownLimit() && jdbcType == TOdbcTableType.SQLSERVER) {\n        sql.append("TOP " + limit + " ");\n    }\n    // ...\n    sql.append(Joiner.on(", ").join(columns));\n    sql.append(" FROM ").append(tableName);\n    // ...\n    // Other DataBase use limit do top n\n    if (shouldPushDownLimit()\n            && (jdbcType == TOdbcTableType.MYSQL\n            || jdbcType == TOdbcTableType.POSTGRESQL\n            /* Other databases using standard LIMIT */\n            // Add here if NewDB also uses standard LIMIT\n            )) {\n        sql.append(" LIMIT ").append(limit);\n    }\n    if (shouldPushDownLimit() && jdbcType == TOdbcTableType.NEWDB) {\n        // Example: If NewDB has special LIMIT syntax, e.g., \'FETCH FIRST n ROWS ONLY\'\n        // Handle independently here\n        sql.append(" FETCH FIRST ").append(limit).append(" ROWS ONLY");\n    }\n    return sql.toString();\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"step-5-implement-backend-data-executor-jdbcexecutor",children:"Step 5: Implement Backend Data Executor (JdbcExecutor)"}),"\n",(0,a.jsx)(n.h4,{id:"core-logic-for-data-reading",children:"Core Logic for Data Reading"}),"\n",(0,a.jsxs)(n.p,{children:["This step is the core of actually executing JDBC data read/write through JNI on the BE side. You need to create a ",(0,a.jsx)(n.code,{children:"NewDBJdbcExecutor.java"})," file in the ",(0,a.jsx)(n.code,{children:"doris/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/"})," directory and override the following key methods:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// doris/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/NewDBJdbcExecutor.java\n\npublic class NewDBJdbcExecutor extends BaseJdbcExecutor {\n\n    public NewDBJdbcExecutor(byte[] thriftParams) throws Exception {\n        super(thriftParams);\n    }\n\n    /**\n     * [Override as needed] Initialize Java-side cache for storing a batch of data.\n     *\n     * @purpose This is a key performance optimization. It pre-allocates memory for the entire batch of data before starting to iterate through the ResultSet.\n     *          This avoids repeated object creation in loops, significantly improving data reading performance.\n     * @implementation\n     * 1. Iterate through each column.\n     * 2. For most standard types, best practice is to call `outputTable.getColumn(i).newObjectContainerArray(batchSizeNum)`.\n     *    This creates a type-safe array container based on Doris target type (like Integer[], BigDecimal[], Long[], etc.).\n     * 3. For types needing special handling (e.g., a binary object returned by JDBC Driver but we only want to treat as String),\n     *    allocate a more generic container like `Object[]`.\n     */\n    @Override\n    protected void initializeBlock(int columnCount, String[] replaceStringList, int batchSizeNum,\n            VectorTable outputTable) {\n        for (int i = 0; i < columnCount; ++i) {\n            if (outputTable.getColumnType(i).getType() == Type.STRING) {\n                block.add(new Object[batchSizeNum]);\n            } else {\n                block.add(outputTable.getColumn(i).newObjectContainerArray(batchSizeNum));\n            }\n        }\n    }\n\n    /**\n     * [Must Override] **Core Method** - Get single column data from JDBC ResultSet.\n     * \n     * @param columnIndex Column index (starting from 0).\n     * @param type Expected column type on Doris side.\n     * @return Java object retrieved and converted from ResultSet.\n     * @implementation\n     * 1. Use `resultSet.getObject(columnIndex + 1, TargetClass.class)` to get value, this is the safest way.\n     * 2. `TargetClass.class` should match Doris `type`, e.g., `Type.INT` corresponds to `Integer.class`.\n     * 3. Must handle `NULL` values correctly through `resultSet.wasNull()`.\n     */\n    @Override\n    protected Object getColumnValue(int columnIndex, ColumnType type, String[] replaceStringList) throws SQLException {\n        switch (type.getType()) {\n            case INT:\n                return resultSet.getObject(columnIndex + 1, Integer.class);\n            case DATETIME:\n                return resultSet.getObject(columnIndex + 1, LocalDateTime.class);\n            // ... other types\n            default:\n                 return resultSet.getObject(columnIndex + 1);\n        }\n    }\n    \n    /**\n     * [Must Override] Provide output converter for specific types.\n     * \n     * @purpose Perform final processing on values obtained by `getColumnValue` before passing to C++ layer.\n     *          Commonly used for scenarios requiring specific formatting.\n     * @implementation\n     *   A common example is `java.sql.Time` type. To preserve its microsecond precision, `getColumnValue` \n     *   gets the `Time` object, while the converter formats it to the `HH:mm:ss.SSSSSS` string required by Doris.\n     *   Another example is converting `byte[]` type to hexadecimal display string.\n     */\n    @Override\n    protected ColumnValueConverter getOutputConverter(ColumnType columnType, String replaceString) {\n        if (columnType.getType() == ColumnType.Type.STRING) {\n            // Example: Time type handling in MySQL Executor\n            return createConverter(input -> {\n                if (input instanceof java.sql.Time) {\n                    return timeToString((java.sql.Time) input); // timeToString is a method in BaseJdbcExecutor\n                }\n                return input.toString();\n            }, String.class);\n        }\n        return null; // Other types usually don\'t need conversion\n    }\n\n    /**\n     * [Optional Override] Initialize PreparedStatement.\n     * \n     * @purpose If optimization of certain write/read sizes and methods is needed\n     * @implementation\n     * 1. Must handle read operations (READ) and write operations (WRITE) separately.\n     * 2. For read operations, control how many rows the JDBC Driver fetches from database at once through `stmt.setFetchSize()`.\n     *    This can avoid OOM. Different Drivers behave differently with this parameter (e.g., MySQL setting to `Integer.MIN_VALUE` enables streaming read).\n     */\n    @Override\n    protected void initializeStatement(Connection conn, JdbcDataSourceConfig config, String sql) throws SQLException {\n        // if (config.getOp() == TJdbcOperation.READ) {\n        //     stmt = conn.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n        //     stmt.setFetchSize(1024); // Set appropriate fetch size for NewDB\n        // } else {\n        //     preparedStatement = conn.prepareStatement(sql);\n        // }\n    }\n    \n    /**\n     * [Optional Override] Interrupt JDBC connection when query is cancelled.\n     * \n     * @purpose If certain data source Driver has special interruption method, need to override here\n     * @implementation Call `connection.abort()` or other interruption methods provided by Driver.\n     */\n    @Override\n    protected void abortReadConnection(Connection connection, ResultSet resultSet) throws SQLException {\n        // connection.abort(MoreExecutors.directExecutor());\n    }\n\n    /**\n     * [Override as needed] Set validation query for Hikari connection pool, default is SELECT 1, override if data source has special syntax\n     * \n     * @purpose Ensure connections obtained from pool are valid.\n     */\n    @Override\n    protected void setValidationQuery(HikariDataSource ds) {\n        // ds.setConnectionTestQuery("SELECT 1"); // NewDB validation query\n    }\n\n    /**\n     * [Optional Override] Set JDBC Driver specific system properties.\n     * \n     * @purpose Some Drivers need to enable or disable certain features through `System.setProperty()`.\n     */\n    @Override\n    protected void setJdbcDriverSystemProperties() {\n        // System.setProperty("newdb.driver.property", "true");\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"register-newdbjdbcexecutor-in-factory-class",children:["Register ",(0,a.jsx)(n.code,{children:"NewDBJdbcExecutor"})," in Factory Class"]}),"\n",(0,a.jsxs)(n.p,{children:["Modify ",(0,a.jsx)(n.code,{children:"doris/fe/be-java-extensions/jdbc-scanner/src/main/java/org/apache/doris/jdbc/JdbcExecutorFactory.java"}),":"]}),"\n",(0,a.jsx)(n.h3,{id:"step-6-add-regression-tests",children:"Step 6: Add Regression Tests"}),"\n",(0,a.jsxs)(n.p,{children:["Refer to ",(0,a.jsx)(n.code,{children:"doris/regression-test/suites/external_table_p0/jdbc/type_test/select/test_mysql_all_types_select.groovy"})," to create a simple test case."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Create ",(0,a.jsx)(n.code,{children:"test_newdb_select.groovy"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-groovy",children:'suite("test_newdb_select", "p0,external,newdb") {\n    String enabled = context.config.otherConfigs.get("enableJdbcTest")\n    if (enabled != null && enabled.equalsIgnoreCase("true")) {\n        // 1. Define NewDB connection information\n        def newdb_port = context.config.otherConfigs.get("newdb_port")\n        def driver_url = "http://your_repo/newdb-driver.jar"\n\n        // 2. Create Catalog\n        sql """create catalog newdb_catalog properties(\n            "type"="jdbc",\n            "user"="root",\n            "password"="123456",\n            "jdbc_url" = "jdbc:newdb://\\${context.config.otherConfigs.get("externalEnvIp")}:\\${newdb_port}/your_db",\n            "driver_url" = "\\${driver_url}",\n            "driver_class" = "com.newdb.jdbc.Driver"\n        );"""\n\n        // 3. Execute tests\n        sql """use newdb_catalog.your_db"""\n        qt_select """select * from your_table order by 1 limit 10;"""\n\n        // 4. Clean up environment\n        sql """drop catalog newdb_catalog"""\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"4-development-considerations",children:"4. Development Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"41-data-type-mapping",children:"4.1 Data Type Mapping"}),"\n",(0,a.jsxs)(n.p,{children:["In the ",(0,a.jsx)(n.code,{children:"jdbcTypeToDoris"})," method, careful handling is needed for:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Precision mapping: ",(0,a.jsx)(n.code,{children:"DECIMAL"})," types need correct precision and scale mapping."]}),"\n",(0,a.jsx)(n.li,{children:"Time types: Pay attention to timezone and precision handling."}),"\n",(0,a.jsx)(n.li,{children:"Special types: Such as some binary special types"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"42-data-source-specific-data-reading",children:"4.2 Data Source Specific Data Reading"}),"\n",(0,a.jsxs)(n.p,{children:["In subclasses of ",(0,a.jsx)(n.code,{children:"BaseJdbcExecutor"}),", focus on:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getColumnValue"}),": How to get data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getOutputConverter"}),": Data conversion function"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"43-error-handling",children:"4.3 Error Handling"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["SQL exception conversion: Convert data source specific exceptions to ",(0,a.jsx)(n.code,{children:"JdbcClientException"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Driver compatibility: Handle compatibility issues with different driver versions."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"44-predicate-and-function-pushdown-optional-optimization",children:"4.4 Predicate and Function Pushdown (Optional Optimization)"}),"\n",(0,a.jsxs)(n.p,{children:["To improve query performance, Doris will push down ",(0,a.jsx)(n.code,{children:"WHERE"})," conditions and some functions to external data sources for execution whenever possible."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Predicate pushdown: In most scenarios, Doris handles this automatically. But for special syntax (like special date functions), adaptation might be needed in the ",(0,a.jsx)(n.code,{children:"conjunctExprToString()"})," method of ",(0,a.jsx)(n.code,{children:"JdbcScanNode.java"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Function pushdown: You can define the list of functions that NewDB supports for pushdown and function name replacement rules in ",(0,a.jsx)(n.code,{children:"JdbcFunctionPushDownRule.java"})," for better performance."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"5-deployment-configuration",children:"5. Deployment Configuration"}),"\n",(0,a.jsx)(n.h3,{id:"51-driver-deployment",children:"5.1 Driver Deployment"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Put NewDB JDBC driver in the specified directory\ncp newdb-jdbc-driver.jar $DORIS_HOME/plugins/jdbc_drivers/\n"})}),"\n",(0,a.jsx)(n.h3,{id:"52-create-catalog",children:"5.2 Create Catalog"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'CREATE CATALOG newdb_catalog PROPERTIES (\n    "type" = "jdbc",\n    "user" = "newdb_user",\n    "password" = "newdb_password",\n    "jdbc_url" = "jdbc:newdb://host:port/database",\n    "driver_url" = "newdb-jdbc-driver.jar",\n    "driver_class" = "com.newdb.jdbc.Driver"\n);\n\n-- Use Catalog\nUSE newdb_catalog.database_name;\nSELECT * FROM table_name LIMIT 10;\n'})})]})}function p(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return s},a:function(){return o}});var r=t(667294);let a={},i=r.createContext(a);function o(e){let n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);