"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["310955"],{448327:function(e,o,r){r.r(o),r.d(o,{default:()=>m,frontMatter:()=>s,metadata:()=>n,assets:()=>l,toc:()=>c,contentTitle:()=>i});var n=JSON.parse('{"id":"admin-manual/trouble-shooting/memory-management/memory-analysis/heap-profile-memory-analysis","title":"Heap Profile Memory Analysis","description":"Heap Profile supports real-time viewing of process memory usage and call stacks, so this usually requires some understanding of the code. It should be noted that Heap Profile records virtual memory. You need to modify the configuration and restart the Doris BE process, and the phenomenon can be reproduced.","source":"@site/docs/admin-manual/trouble-shooting/memory-management/memory-analysis/heap-profile-memory-analysis.md","sourceDirName":"admin-manual/trouble-shooting/memory-management/memory-analysis","slug":"/admin-manual/trouble-shooting/memory-management/memory-analysis/heap-profile-memory-analysis","permalink":"/docs/dev/admin-manual/trouble-shooting/memory-management/memory-analysis/heap-profile-memory-analysis","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Heap Profile Memory Analysis","language":"en"},"sidebar":"docs","previous":{"title":"Memory Log Analysis","permalink":"/docs/dev/admin-manual/trouble-shooting/memory-management/memory-analysis/memory-log-analysis"},"next":{"title":"Memory Tracker","permalink":"/docs/dev/admin-manual/trouble-shooting/memory-management/memory-feature/memory-tracker"}}'),t=r("785893"),a=r("250065");let s={title:"Heap Profile Memory Analysis",language:"en"},i=void 0,l={},c=[];function d(e){let o={a:"a",code:"code",li:"li",ol:"ol",p:"p",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.p,{children:"Heap Profile supports real-time viewing of process memory usage and call stacks, so this usually requires some understanding of the code. It should be noted that Heap Profile records virtual memory. You need to modify the configuration and restart the Doris BE process, and the phenomenon can be reproduced."}),"\n",(0,t.jsx)(o.p,{children:"Doris uses Jemalloc as the default Allocator. Refer to the following method to use Heap Profile."}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsxs)(o.li,{children:["\n",(0,t.jsxs)(o.p,{children:["Change ",(0,t.jsx)(o.code,{children:"prof_active:false"})," of ",(0,t.jsx)(o.code,{children:"JEMALLOC_CONF"})," in ",(0,t.jsx)(o.code,{children:"be.conf"})," to ",(0,t.jsx)(o.code,{children:"prof_active:true"})," and restart Doris BE."]}),"\n"]}),"\n",(0,t.jsxs)(o.li,{children:["\n",(0,t.jsxs)(o.p,{children:["After executing ",(0,t.jsx)(o.code,{children:"curl http://be_host:8040/jeheap/dump"}),", you will see the generated ",(0,t.jsx)(o.code,{children:"profile"})," file in the ",(0,t.jsx)(o.code,{children:"${DORIS_HOME}/log"})," directory."]}),"\n"]}),"\n",(0,t.jsxs)(o.li,{children:["\n",(0,t.jsxs)(o.p,{children:["After executing ",(0,t.jsx)(o.code,{children:"jeprof --dot ${DORIS_HOME}/lib/doris_be ${DORIS_HOME}/log/profile_file"}),", paste the text output by the terminal to the ",(0,t.jsx)(o.a,{href:"http://www.webgraphviz.com/",children:"online dot drawing website"})," to generate a memory allocation graph."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:["The above process is based on Doris 2.1.8 and 3.0.4 and later versions, which are used for real-time memory analysis. If you need to observe memory for a long time or observe the cumulative value of memory application, please refer to ",(0,t.jsx)(o.a,{href:"https://doris.apache.org/community/developer-guide/debug-tool/?_highlight=debug#jemalloc-1",children:"Jemalloc Heap Profile"})," for more information about the use of Jemalloc Heap Profile."]}),"\n",(0,t.jsxs)(o.p,{children:["If you see the ",(0,t.jsx)(o.code,{children:"Segment"}),", ",(0,t.jsx)(o.code,{children:"TabletSchema"}),", and ",(0,t.jsx)(o.code,{children:"ColumnReader"})," fields in the call stack with a large memory share of Heap Profile, it means that the metadata occupies a large amount of memory."]}),"\n",(0,t.jsxs)(o.p,{children:["If the BE memory does not decrease when the cluster is idle after running for a period of time, then you can see fields such as ",(0,t.jsx)(o.code,{children:"Agg"}),", ",(0,t.jsx)(o.code,{children:"Join"}),", ",(0,t.jsx)(o.code,{children:"Filter"}),", ",(0,t.jsx)(o.code,{children:"Sort"}),", and ",(0,t.jsx)(o.code,{children:"Scan"})," in the call stack with a large memory share in the Heap Profile. If the BE process memory monitoring in the corresponding time period shows a continuous upward trend, then there is reason to suspect that there is a memory leak. Continue to analyze the code based on the call stack."]}),"\n",(0,t.jsxs)(o.p,{children:["If you see fields such as ",(0,t.jsx)(o.code,{children:"Agg"}),", ",(0,t.jsx)(o.code,{children:"Join"}),", ",(0,t.jsx)(o.code,{children:"Filter"}),", ",(0,t.jsx)(o.code,{children:"Sort"}),", and ",(0,t.jsx)(o.code,{children:"Scan"})," in the call stack with a large memory share in the Heap Profile during task execution on the cluster, and the memory is released normally after the task is completed, it means that most of the memory is used by the running tasks and there is no leak. If the value of ",(0,t.jsx)(o.code,{children:"Label=query, Type=overview"})," Memory Tracker accounts for a smaller proportion of the total memory than the memory call stack containing the above fields in the Heap Profile, it means that the statistics of ",(0,t.jsx)(o.code,{children:"Label=query, Type=overview"})," Memory Tracker are inaccurate, and you can provide timely feedback in the community."]})]})}function m(e={}){let{wrapper:o}={...(0,a.a)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},250065:function(e,o,r){r.d(o,{Z:function(){return i},a:function(){return s}});var n=r(667294);let t={},a=n.createContext(t);function s(e){let o=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function i(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),n.createElement(a.Provider,{value:o},e.children)}}}]);