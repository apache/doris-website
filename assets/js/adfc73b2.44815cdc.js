"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["383309"],{833329:function(e,n,l){l.r(n),l.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>i,assets:()=>d,toc:()=>c,contentTitle:()=>t});var i=JSON.parse('{"id":"table-design/schema-change","title":"Schema Change","description":"Users can modify the schema of an existing table through the Schema Change operation. The  schema of a table mainly includes the modification of columns and the modification of indexes. Here we mainly introduce the column-related  Scheme  changes. For index-related changes, you can check the data table design/table index to see the change method of each index.","source":"@site/versioned_docs/version-2.0/table-design/schema-change.md","sourceDirName":"table-design","slug":"/table-design/schema-change","permalink":"/docs/2.0/table-design/schema-change","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Schema Change","language":"en"},"sidebar":"docs","previous":{"title":"Common Issues","permalink":"/docs/2.0/table-design/data-partitioning/common-issues"},"next":{"title":"Tiered Storage","permalink":"/docs/2.0/table-design/cold-hot-separation"}}'),a=l("785893"),s=l("250065");let o={title:"Schema Change",language:"en"},t=void 0,d={},c=[{value:"Glossary",id:"glossary",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Adding a column at a specified position to a specified index",id:"adding-a-column-at-a-specified-position-to-a-specified-index",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Examples",id:"examples",level:3},{value:"non-aggregate model",id:"non-aggregate-model",level:4},{value:"aggregate model",id:"aggregate-model",level:4},{value:"Adding multiple columns to a specified index",id:"adding-multiple-columns-to-a-specified-index",level:2},{value:"Syntax",id:"syntax-1",level:3},{value:"Example",id:"example",level:3},{value:"Removing a column from a specified index",id:"removing-a-column-from-a-specified-index",level:2},{value:"Syntax",id:"syntax-2",level:3},{value:"Example",id:"example-1",level:3},{value:"Modifying the column type and position of a specified index",id:"modifying-the-column-type-and-position-of-a-specified-index",level:2},{value:"Syntax",id:"syntax-3",level:3},{value:"Examples",id:"examples-1",level:3},{value:"Reorder columns for a specified index",id:"reorder-columns-for-a-specified-index",level:2},{value:"Syntax",id:"syntax-4",level:3},{value:"Example",id:"example-2",level:3},{value:"Perform multiple changes in one submission",id:"perform-multiple-changes-in-one-submission",level:2},{value:"Example 1",id:"example-1-1",level:3},{value:"Example 2",id:"example-2-1",level:3},{value:"Rename Column",id:"rename-column",level:2},{value:"Check Job Status",id:"check-job-status",level:2},{value:"Cancel Job",id:"cancel-job",level:2},{value:"Notes",id:"notes",level:2},{value:"FAQs",id:"faqs",level:2},{value:"Configurations",id:"configurations",level:2},{value:"FE Configuration",id:"fe-configuration",level:3},{value:"BE Configuration",id:"be-configuration",level:3},{value:"More Details",id:"more-details",level:2}];function r(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Users can modify the schema of an existing table through the Schema Change operation. The  schema of a table mainly includes the modification of columns and the modification of indexes. Here we mainly introduce the column-related  Scheme  changes. For index-related changes, you can check the data table design/table index to see the change method of each index."}),"\n",(0,a.jsx)(n.h2,{id:"glossary",children:"Glossary"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Base Table: When each table is created, it corresponds to a base table."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Rollup: A roll-up table created based on a base table or other rollup."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Index: materialized index. Rollup or base table are both called materialized indexes."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Transaction: Each import task is a transaction, and each transaction has a unique increasing transaction ID."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Light Schema Change"})}),"\n",(0,a.jsx)(n.p,{children:"Before introduction, it is necessary to know the three Schema Change implementations before the Apache Doris 1.2.0 version, all of which are asynchronous:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Hard linked schema change  mainly acts on addition and subtraction of value columns and does not require modification of the data file."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Direct schema change  is mainly used to change the type of value  column, which needs to rewrite the data, but does not involve the key  column, and does not need to be reordered."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Sort schema change  is mainly used for the key column  schema change, because the key  column addition/subtraction/modification type and other operations will affect the sorting of existing data, so the data needs to be read out again, modified, and then sort."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Since Apache Doris 1.2.0 , for the first type, the new feature of light schema change has been introduced. The new light schema change allows the addition and subtraction of the value column to be completed in milliseconds. Starting from Apache Doris 2.0.0, all newly created tables have enabled light schema change by default."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"In addition to adding and deleting the value column, the main principles of other types of schema changes are as follows"})}),"\n",(0,a.jsx)(n.p,{children:"The basic process of executing schema change is to generate a new schema table from the data  /Index  in the original table  /Index data. There are mainly two parts of data conversion, one is the conversion of existing historical data, and the other is the conversion of newly arrived imported data during the execution of schema change."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-Plain",children:"+----------+\n| Load Job |\n+----+-----+\n     |\n     | Load job generates both origin and new Index data\n     |\n     |      +------------------+ +---------------+\n     |      | Origin Index     | | Origin Index  |\n     +------\x3e New Incoming Data| | History Data  |\n     |      +------------------+ +------+--------+\n     |                                  |\n     |                                  | Convert history data\n     |                                  |\n     |      +------------------+ +------v--------+\n     |      | New Index        | | New Index     |\n     +------\x3e New Incoming Data| | History Data  |\n            +------------------+ +---------------+\n"})}),"\n",(0,a.jsx)(n.p,{children:"Before starting to convert historical data, Doris will obtain a latest transaction ID and wait for all import transactions before this transaction ID to complete. This transaction ID becomes a watershed. This means that Doris ensures that all import tasks after the watershed will generate data for the original table  /Index  and the new table  /Index  at the same time. This way, when the historical data conversion is completed, the data in the new table can be guaranteed to be complete."}),"\n",(0,a.jsxs)(n.p,{children:["The specific syntax for creating schema changes can be found in the schema change section of the help ",(0,a.jsx)(n.a,{href:"../sql-manual/sql-statements/table-and-view/table/ALTER-TABLE-COLUMN",children:"ALTER TABLE COLUMN"})]}),"\n",(0,a.jsx)(n.h2,{id:"adding-a-column-at-a-specified-position-to-a-specified-index",children:"Adding a column at a specified position to a specified index"}),"\n",(0,a.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE table_name ADD COLUMN column_name column_type [KEY | agg_type] [DEFAULT "default_value"]\n[AFTER column_name|FIRST]\n[TO rollup_index_name]\n[PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["For aggregate models, if adding a value column, specify ",(0,a.jsx)(n.code,{children:"agg_type"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["For non-aggregate models (e.g., DUPLICATE KEY), if adding a key column, specify the ",(0,a.jsx)(n.code,{children:"KEY"})," keyword."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"You cannot add a column to a rollup index that already exists in the base index (if needed, you can create a new rollup index)."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.h4,{id:"non-aggregate-model",children:"non-aggregate model"}),"\n",(0,a.jsx)(n.p,{children:"table's DDL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_db.my_table(\n    col1 int,\n    col2 int,\n    col3 int,\n    col4 int,\n    col5 int\n) DUPLICATE KEY(col1, col2, col3)\nDISTRIBUTED BY RANDOM BUCKETS 1\nROLLUP (\n   example_rollup_index (col1, col3, col4, col5)\n)\nPROPERTIES (\n   "replication_num" = "1"\n)\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["1. Adding a key column ",(0,a.jsx)(n.code,{children:"new_col"})," after col1 to ",(0,a.jsx)(n.code,{children:"example_rollup_index"})]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD COLUMN new_col INT KEY DEFAULT "0" AFTER col1\nTO example_rollup_index;\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["2. Adding a value column ",(0,a.jsx)(n.code,{children:"new_col"})," with a default value of 0 after col1 to ",(0,a.jsx)(n.code,{children:"example_rollup_index"})]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table   \nADD COLUMN new_col INT DEFAULT "0" AFTER col1    \nTO example_rollup_index;\n'})}),"\n",(0,a.jsx)(n.h4,{id:"aggregate-model",children:"aggregate model"}),"\n",(0,a.jsx)(n.p,{children:"table's DDL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_db.my_table(\n    col1 int,\n    col2 int,\n    col3 int,\n    col4 int SUM,\n    col5 varchar(32) REPLACE DEFAULT "abc"\n) AGGREGATE KEY(col1, col2, col3)\nDISTRIBUTED BY HASH(col1) BUCKETS 1\nROLLUP (\n    example_rollup_index (col1, col3, col4, col5)\n)\nPROPERTIES (\n    "replication_num" = "1"\n)\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["3. Adding a Key column ",(0,a.jsx)(n.code,{children:"new_col"})," after col1 to ",(0,a.jsx)(n.code,{children:"example_rollup_index"})]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table   \nADD COLUMN new_col INT DEFAULT "0" AFTER col1    \nTO example_rollup_index;\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["4. Adding a value column ",(0,a.jsx)(n.code,{children:"new_col"})," with SUM aggregation type after col1 to ",(0,a.jsx)(n.code,{children:"example_rollup_index"})]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table   \nADD COLUMN new_col INT SUM DEFAULT "0" AFTER col1    \nTO example_rollup_index;\n'})}),"\n",(0,a.jsx)(n.h2,{id:"adding-multiple-columns-to-a-specified-index",children:"Adding multiple columns to a specified index"}),"\n",(0,a.jsx)(n.h3,{id:"syntax-1",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE table_name ADD COLUMN (column_name1 column_type [KEY | agg_type] DEFAULT "default_value", ...)\n[TO rollup_index_name]\n[PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["For aggregate models, if adding a value column, specify ",(0,a.jsx)(n.code,{children:"agg_type"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"For aggregate models, if adding a key column, specify the KEY keyword."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"You cannot add a column to a rollup index that already exists in the base index (if needed, you can create a new rollup index)."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(n.p,{children:["Adding multiple columns (aggregate model) to ",(0,a.jsx)(n.code,{children:"example_rollup_index"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD COLUMN (c1 INT DEFAULT "1", c2 FLOAT SUM DEFAULT "0")\nTO example_rollup_index;\n'})}),"\n",(0,a.jsx)(n.h2,{id:"removing-a-column-from-a-specified-index",children:"Removing a column from a specified index"}),"\n",(0,a.jsx)(n.h3,{id:"syntax-2",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE table_name DROP COLUMN column_name\n[FROM rollup_index_name]\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"You cannot delete a partition column."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"If you delete a column from the base index, it will also be removed from the rollup index if it contains the column."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,a.jsxs)(n.p,{children:["Removing column col2 from ",(0,a.jsx)(n.code,{children:"example_rollup_index"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_db.my_table\nDROP COLUMN col3\nFROM example_rollup_index;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"modifying-the-column-type-and-position-of-a-specified-index",children:"Modifying the column type and position of a specified index"}),"\n",(0,a.jsx)(n.h3,{id:"syntax-3",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE table_name MODIFY COLUMN column_name column_type [KEY | agg_type] [NULL | NOT NULL] [DEFAULT "default_value"]\n[AFTER column_name|FIRST]\n[FROM rollup_index_name]\n[PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["For aggregate models, if modifying a value column, specify ",(0,a.jsx)(n.code,{children:"agg_type"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["For non-aggregate models, if modifying a key column, specify the ",(0,a.jsx)(n.strong,{children:"KEY"})," keyword."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Only the column type can be modified, other column properties remain the same (i.e., other properties need to be explicitly written in the statement, see Example 8)."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Partition and bucket columns cannot be modified."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Currently, the following type conversions are supported (users need to ensure precision loss):"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Conversion from TINYINT/SMALLINT/INT/BIGINT/LARGEINT/FLOAT/DOUBLE to a larger numeric type."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Conversion from TINYINT/SMALLINT/INT/BIGINT/LARGEINT/FLOAT/DOUBLE/DECIMAL to VARCHAR."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Modification of maximum length for VARCHAR."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Conversion from VARCHAR/CHAR to TINYINT/SMALLINT/INT/BIGINT/LARGEINT/FLOAT/DOUBLE."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:'Conversion from VARCHAR/CHAR to DATE (supports six formatting formats: "%Y-%m-%d", "%y-%m-%d", "%Y%m%d", "%y%m%d", "%Y/%m/%d", "%y/%m/%d").'}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Conversion from DATETIME to DATE (only retains year-month-day information, e.g., ",(0,a.jsx)(n.code,{children:"2019-12-09 21:47:05"})," <--\x3e ",(0,a.jsx)(n.code,{children:"2019-12-09"}),")."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Conversion from DATE to DATETIME (automatically adds zeros for hours, minutes, and seconds, e.g., ",(0,a.jsx)(n.code,{children:"2019-12-09"})," <--\x3e ",(0,a.jsx)(n.code,{children:"2019-12-09 00:00:00"}),")."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Conversion from FLOAT to DOUBLE."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Conversion from INT to DATE (if the INT type data is invalid, the conversion fails, and the original data remains unchanged)."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"All types except DATE and DATETIME can be converted to STRING, but STRING cannot be converted to any other type."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"examples-1",children:"Examples"}),"\n",(0,a.jsx)(n.p,{children:"table's DDL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_db.my_table(\n    col0 int,\n    col1 int DEFAULT "1",\n    col2 int,\n    col3 varchar(32),\n    col4 int SUM,\n    col5 varchar(32) REPLACE DEFAULT "abc"\n) AGGREGATE KEY(col0, col1, col2, col3)\nDISTRIBUTED BY HASH(col0) BUCKETS 1\nPROPERTIES (\n    "replication_num" = "1"\n)\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"1. Modifying the column type of Key column col1 to BIGINT in the base index and moving it after column col2"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table \nMODIFY COLUMN col1 BIGINT KEY DEFAULT "1" AFTER col2;\n'})}),"\n",(0,a.jsx)(n.p,{children:"Note: whether modifying a key column or a value column, the complete column information needs to be declared."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:'2. Modifying the maximum length of column val1 in the Base Index. The original val1 is (val1 VARCHAR(32) REPLACE DEFAULT "abc")'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nMODIFY COLUMN col5 VARCHAR(64) REPLACE DEFAULT "abc";\n'})}),"\n",(0,a.jsx)(n.p,{children:"Note: only the column type can be modified while keeping the other properties of the column unchanged."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"3. Modifying the length of a field in the key column of a duplicate key table"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_db.my_table\nMODIFY COLUMN col3 varchar(50) KEY NULL comment 'to 50'\n"})}),"\n",(0,a.jsx)(n.h2,{id:"reorder-columns-for-a-specified-index",children:"Reorder columns for a specified index"}),"\n",(0,a.jsx)(n.h3,{id:"syntax-4",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE table_name ORDER BY (column_name1, column_name2, ...)\n[FROM rollup_index_name]\n[PROPERTIES ("key"="value", ...)]\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"All columns in the index should be listed."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Value columns come after key columns."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_db.my_table(\n    k1 int DEFAULT "1",\n    k2 int,\n    k3 varchar(32),\n    k4 date,\n    v1 int SUM,\n    v2 int MAX,\n) AGGREGATE KEY(k1, k2, k3, k4)\nDISTRIBUTED BY HASH(k1) BUCKETS 1\nROLLUP (\n   example_rollup_index(k1, k2, k3, v1, v2)\n)\nPROPERTIES (\n    "replication_num" = "1"\n)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Reorder columns in the index ",(0,a.jsx)(n.code,{children:"example_rollup_index"})," (assuming the original column order is: k1, k2, k3, v1, v2)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE example_db.my_table\nORDER BY (k3,k1,k2,v2,v1)\nFROM example_rollup_index;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"perform-multiple-changes-in-one-submission",children:"Perform multiple changes in one submission"}),"\n",(0,a.jsx)(n.p,{children:"Schema change can modify multiple indexes in a single job."}),"\n",(0,a.jsx)(n.h3,{id:"example-1-1",children:"Example 1"}),"\n",(0,a.jsx)(n.p,{children:"Source Schema:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_db.tbl1(\n    k1 int,\n    k2 int,\n    k3 int\n) AGGREGATE KEY(k1, k2, k3)\nDISTRIBUTED BY HASH(k1) BUCKETS 1\nROLLUP (\n   rollup1 (k1, k2),\n   rollup2 (k2)\n)\nPROPERTIES (\n    "replication_num" = "1"\n)\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can use the following command to add a column k4 to rollup1 and rollup2, and add an additional column k5 to rollup2:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE tbl1\nADD COLUMN k4 INT default "1" to rollup1,\nADD COLUMN k4 INT default "1" to rollup2,\nADD COLUMN k5 INT default "1" to rollup2;\n'})}),"\n",(0,a.jsx)(n.p,{children:"After completion, the schema becomes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-Plain",children:"+-----------+-------+------+------+------+---------+-------+\n| IndexName | Field | Type | Null | Key  | Default | Extra |\n+-----------+-------+------+------+------+---------+-------+\n| tbl1      | k1    | INT  | No   | true | N/A     |       |\n|           | k2    | INT  | No   | true | N/A     |       |\n|           | k3    | INT  | No   | true | N/A     |       |\n|           | k4    | INT  | No   | true | 1       |       |\n|           | k5    | INT  | No   | true | 1       |       |\n|           |       |      |      |      |         |       |\n| rollup2   | k2    | INT  | No   | true | N/A     |       |\n|           | k4    | INT  | No   | true | 1       |       |\n|           | k5    | INT  | No   | true | 1       |       |\n|           |       |      |      |      |         |       |\n| rollup1   | k1    | INT  | No   | true | N/A     |       |\n|           | k2    | INT  | No   | true | N/A     |       |\n|           | k4    | INT  | No   | true | 1       |       |\n+-----------+-------+------+------+------+---------+-------+\n"})}),"\n",(0,a.jsx)(n.p,{children:"As seen, the base table tbl1 automatically includes the columns k4 and k5. Any columns added to a rollup will automatically be added to the base table."}),"\n",(0,a.jsx)(n.p,{children:"Additionally, it is not allowed to add columns to a rollup that already exist in the base table. If a user needs to do so, they can create a new rollup with the additional columns and then delete the original rollup."}),"\n",(0,a.jsx)(n.h3,{id:"example-2-1",children:"Example 2"}),"\n",(0,a.jsx)(n.p,{children:"table's DDL"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_db.my_table(\n    k1 int DEFAULT "1",\n    k2 int,\n    k3 varchar(32),\n    k4 date,\n    v1 int SUM,\n) AGGREGATE KEY(k1, k2, k3, k4)\nDISTRIBUTED BY HASH(k1) BUCKETS 1\nROLLUP (\n   example_rollup_index(k1, k3, k2, v1)\n)\nPROPERTIES (\n   "replication_num" = "1"\n)\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ALTER TABLE example_db.my_table\nADD COLUMN v2 INT MAX DEFAULT "0" TO example_rollup_index,\nORDER BY (k3,k1,k2,v2,v1) FROM example_rollup_index;\n'})}),"\n",(0,a.jsx)(n.h2,{id:"rename-column",children:"Rename Column"}),"\n",(0,a.jsx)(n.p,{children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ALTER TABLE RENAME COLUMN old_column_name new_column_name;    \n"})}),"\n",(0,a.jsx)(n.h2,{id:"check-job-status",children:"Check Job Status"}),"\n",(0,a.jsxs)(n.p,{children:["The creation of a schema change is an asynchronous process. After a job is successfully submitted, users need to use the ",(0,a.jsx)(n.code,{children:"SHOW ALTER TABLE COLUMN"})," command to check the progress of the job."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"SHOW ALTER TABLE COLUMN "})," allows you to view the currently executing or completed schema Change jobs. When a schema change job involves multiple indexes, the command will display multiple rows, with each row corresponding to an index. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"mysql > SHOW ALTER TABLE COLUMN\\G;\n*************************** 1. row ***************************\n        JobId: 20021\n    TableName: tbl1\n   CreateTime: 2019-08-05 23:03:13\n   FinishTime: 2019-08-05 23:03:42\n    IndexName: tbl1\n      IndexId: 20022\nOriginIndexId: 20017\nSchemaVersion: 2:792557838\nTransactionId: 10023\n        State: FINISHED\n          Msg: \n     Progress: NULL\n      Timeout: 86400\n1 row in set (0.00 sec)\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"JobId: unique ID for each schema change job."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"TableName: name of the base table associated with schema change."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"CreateTime: time when the job was created."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:'FinishTime: time when the job is finished. If not finished, it displays "N/A".'}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"IndexName: name of one of the indexes involved in the modification."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"IndexId: unique ID of the new index."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"OriginIndexId: unique ID of the old index."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"SchemaVersion: displayed in the format M:N, where M represents the version of the schema change modification, and N represents the corresponding hash value. The version increments with each schema change."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"TransactionId: transaction ID that serves as the boundary for transforming historical data."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"State: current state of the job."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"PENDING: the job is waiting in the queue to be scheduled."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"WAITING_TXN: waiting for import tasks before the boundary transaction ID to complete."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"RUNNING: historical data transformation is in progress."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"FINISHED: the job completed successfully."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"CANCELLED: the job was cancelled."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Msg: if the job fails, this field displays the failure message."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Progress: job progress. It is only displayed when the state is RUNNING. Progress is shown in the format M/N, where N is the total number of replicas involved in the schema change, and M is the number of replicas that have completed historical data transformation."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Timeout: job timeout in seconds."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"cancel-job",children:"Cancel Job"}),"\n",(0,a.jsx)(n.p,{children:"In cases where the job state is not FINISHED or CANCELLED, you can cancel the schema change job using the following command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CANCEL ALTER TABLE COLUMN FROM tbl_name;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Only one schema change job can run on a table at a time."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Schema change operations do not block import and query operations."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Partition and bucket columns cannot be modified."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"If the schema includes value columns aggregated using the REPLACE method, it is not allowed to delete key columns."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"If a key column is deleted, Doris cannot determine the values for the REPLACE columns."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"All non-key columns in a unique data model table are aggregated using the REPLACE method."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"When adding a value column with an aggregation type of SUM or REPLACE, the default value for that column has no meaning for historical data."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Since the historical data has lost detailed information, the default value does not reflect the actual aggregated value."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"When modifying the column type, all fields except Type need to be completed based on the information from the original column."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["For example, to modify the column ",(0,a.jsx)(n.code,{children:'k1 from INT SUM NULL DEFAULT "1"'})," to BIGINT, the command would be: ",(0,a.jsx)(n.code,{children:'ALTER TABLE tbl1 MODIFY COLUMN k1 BIGINT SUM NULL DEFAULT "1"'}),";"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Note that apart from the new column type, other attributes such as the aggregation method, nullable property, and default value should be completed based on the original information."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"It is not supported to modify column names, aggregation types, nullable properties, default values, or column comments."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"faqs",children:"FAQs"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Schema change execution speed"})}),"\n",(0,a.jsx)(n.p,{children:"For a Light Schema Change, such as adding or deleting Value columns, the execution speed can be in the millisecond range. For other types of Schema Change, the execution speed is estimated to be around 10MB/s in the worst-case scenario. As a conservative measure, users can set the job timeout based on this speed."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Error:"})," ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:'"Table xxx is not stable"'})})," ",(0,a.jsx)(n.strong,{children:"when submitting a job"})]}),"\n",(0,a.jsx)(n.p,{children:"Schema Change can only be initiated when the table data is complete and in a balanced state. If some data shard replicas of the table are incomplete or if some replicas are undergoing balancing operations, the submission will be rejected. You can check if the data shard replicas are complete using the following command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'SHOW REPLICA STATUS FROM tbl WHERE STATUS != "OK";\n'})}),"\n",(0,a.jsx)(n.p,{children:"If there are any results returned, it indicates that there are issues with the replicas. Typically, the system will automatically repair these issues, but users can prioritize the repair for a specific table using the following command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"ADMIN REPAIR TABLE tbl1;\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can check if there are any running balancing tasks using the following command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'SHOW PROC "/cluster_balance/pending_tablets";\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can wait for the balancing tasks to complete or temporarily disable balancing operations using the following command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:'ADMIN SET FRONTEND CONFIG ("disable_balance" = "true");\n'})}),"\n",(0,a.jsx)(n.h2,{id:"configurations",children:"Configurations"}),"\n",(0,a.jsx)(n.h3,{id:"fe-configuration",children:"FE Configuration"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"alter_table_timeout_second"}),": Default timeout for jobs, set to 86400 seconds."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"be-configuration",children:"BE Configuration"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"alter_tablet_worker_count"}),": Number of threads used on the BE side for executing historical data transformation. The default is 3. If you want to speed up Schema Change jobs, you can increase this parameter and restart the BE. However, having too many transformation threads may increase IO pressure and affect other operations. This thread is shared with Rollup jobs."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"alter_index_worker_count"}),": Number of threads used on the BE side for building indexes on historical data (currently only supports inverted indexes). The default is 3. If you want to speed up Index Change jobs, you can increase this parameter and restart the BE. However, having too many threads may increase IO pressure and affect other operations."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"more-details",children:"More Details"}),"\n",(0,a.jsxs)(n.p,{children:["For more detailed syntax and best practices regarding Schema Change, please refer to the ",(0,a.jsx)(n.a,{href:"../sql-manual/sql-reference/Data-Definition-Statements/Alter/ALTER-TABLE-COLUMN",children:"ALTER TABLE COLUMN"})," command manual. You can also enter ",(0,a.jsx)(n.code,{children:"HELP ALTER TABLE COLUMN "}),"in the MySQL client command line for more help information."]})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(r,{...e})}):r(e)}},250065:function(e,n,l){l.d(n,{Z:function(){return t},a:function(){return o}});var i=l(667294);let a={},s=i.createContext(a);function o(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);