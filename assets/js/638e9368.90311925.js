"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["378766"],{837853:function(e,n,r){r.r(n),r.d(n,{default:()=>h,frontMatter:()=>c,metadata:()=>i,assets:()=>l,toc:()=>a,contentTitle:()=>d});var i=JSON.parse('{"id":"compute-storage-decoupled/rw/read-write-separation","title":"Read Write Separation","description":"Background","source":"@site/docs/compute-storage-decoupled/rw/read-write-separation.md","sourceDirName":"compute-storage-decoupled/rw","slug":"/compute-storage-decoupled/rw/read-write-separation","permalink":"/docs/dev/compute-storage-decoupled/rw/read-write-separation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Read Write Separation","language":"en"},"sidebar":"docs","previous":{"title":"File Cache Internals","permalink":"/docs/dev/compute-storage-decoupled/file-cache/file-cache-internals"},"next":{"title":"Best Practices for Cache Optimization in Read-Write Splitting Scenarios","permalink":"/docs/dev/compute-storage-decoupled/rw/file-cache-rw-compute-group-best-practice"}}'),s=r("785893"),t=r("250065");let c={title:"Read Write Separation",language:"en"},d="File Cache Active Incremental Warm-Up",l={},a=[{value:"Background",id:"background",level:2},{value:"Feature Overview",id:"feature-overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Synchronization Modes",id:"synchronization-modes",level:3},{value:"WARM UP Syntax Extensions",id:"warm-up-syntax-extensions",level:3},{value:"Warm-Up Job Management",id:"warm-up-job-management",level:2},{value:"Viewing Jobs",id:"viewing-jobs",level:3},{value:"Cancelling Jobs",id:"cancelling-jobs",level:3},{value:"Working Principle",id:"working-principle",level:2},{value:"Periodic Synchronization Process",id:"periodic-synchronization-process",level:3},{value:"Event-Triggered Synchronization Process",id:"event-triggered-synchronization-process",level:3},{value:"Storage and Scheduling Mechanism",id:"storage-and-scheduling-mechanism",level:2},{value:"Internal API Design",id:"internal-api-design",level:2},{value:"Metrics Monitoring",id:"metrics-monitoring",level:2},{value:"Periodic Jobs - FE Side",id:"periodic-jobs---fe-side",level:3},{value:"Periodic Jobs - BE Side",id:"periodic-jobs---be-side",level:3},{value:"Event-Triggered Jobs - Source BE",id:"event-triggered-jobs---source-be",level:3},{value:"Event-Triggered Jobs - Target BE",id:"event-triggered-jobs---target-be",level:3},{value:"FAQ",id:"faq",level:2},{value:"Version Information",id:"version-information",level:2}];function o(e){let n={blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"file-cache-active-incremental-warm-up",children:"File Cache Active Incremental Warm-Up"})}),"\n",(0,s.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(n.p,{children:["To support cross-availability zone (AZ) high-availability cluster architectures and read-write separation architectures, Doris introduces the ",(0,s.jsx)(n.strong,{children:"File Cache Active Incremental Warm-Up Mechanism"}),". This mechanism ensures that the target cluster's cached data remains highly consistent with the source cluster, thereby improving query performance, reducing jitter, and speeding up response time during failover."]}),"\n",(0,s.jsx)(n.p,{children:"Application scenarios include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primary-Standby Cluster Architecture"}),": Ensures that the standby cluster can quickly take over the load when the primary cluster fails."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Read-Write Separation Architecture"}),": Ensures that newly written data is promptly cached in the read cluster."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"feature-overview",children:"Feature Overview"}),"\n",(0,s.jsx)(n.p,{children:"File Cache active warm-up mainly supports synchronization of the following two types of caches:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Import Data Cache Synchronization"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Covers data generated after write operations such as Load, Compaction, and Schema Change."}),"\n",(0,s.jsxs)(n.li,{children:["Supports ",(0,s.jsx)(n.strong,{children:"event-triggered synchronization"})," to reduce query jitter."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Query Data Cache Synchronization"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Supports ",(0,s.jsx)(n.strong,{children:"periodic synchronization"})," to keep hot query data in a ready state in the target cluster."]}),"\n",(0,s.jsx)(n.li,{children:"Ensures standby cluster performance remains stable during primary-standby switchovers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsx)(n.h3,{id:"synchronization-modes",children:"Synchronization Modes"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Mode"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["One-Time Sync (",(0,s.jsx)(n.code,{children:"ONCE"}),")"]}),(0,s.jsx)(n.td,{children:"Suitable for manual triggers, e.g., preheating a newly launched cluster"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Periodic Sync (",(0,s.jsx)(n.code,{children:"PERIODIC"}),")"]}),(0,s.jsx)(n.td,{children:"Suitable for regular synchronization of query data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Event-Driven Sync (",(0,s.jsx)(n.code,{children:"EVENT_DRIVEN"}),")"]}),(0,s.jsx)(n.td,{children:"Suitable for automatic triggering after Load, Compaction, or Schema Change operations"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"warm-up-syntax-extensions",children:"WARM UP Syntax Extensions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'-- One-time synchronization\nWARM UP COMPUTE GROUP <target_cluster> WITH COMPUTE GROUP <source_cluster>;\n\n-- Periodic synchronization\nWARM UP COMPUTE GROUP <target_cluster> WITH COMPUTE GROUP <source_cluster>\nPROPERTIES (\n    "sync_mode" = "periodic",\n    "sync_interval_sec" = "600"\n);\n\n-- Event-triggered synchronization\nWARM UP COMPUTE GROUP <target_cluster> WITH COMPUTE GROUP <source_cluster>\nPROPERTIES (\n    "sync_mode" = "event_driven",\n    "sync_event" = "load"\n);\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"warm-up-job-management",children:"Warm-Up Job Management"}),"\n",(0,s.jsx)(n.h3,{id:"viewing-jobs",children:"Viewing Jobs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SHOW WARM UP JOB;\nSHOW WARM UP JOB WHERE ID = 12345;\n"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Column Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JobId"}),(0,s.jsx)(n.td,{children:"Unique job ID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ComputeGroup"}),(0,s.jsx)(n.td,{children:"Target Compute Group"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SrcComputeGroup"}),(0,s.jsx)(n.td,{children:"Source Compute Group"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Type"}),(0,s.jsx)(n.td,{children:"Type: CLUSTER / TABLE"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SyncMode"}),(0,s.jsx)(n.td,{children:"ONCE / PERIODIC(x) / EVENT_DRIVEN(x)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Status"}),(0,s.jsx)(n.td,{children:"PENDING / RUNNING / FINISHED / CANCELLED / DELETED"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CreateTime"}),(0,s.jsx)(n.td,{children:"Creation time"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"StartTime"}),(0,s.jsx)(n.td,{children:"Last start time"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"FinishTime"}),(0,s.jsx)(n.td,{children:"Last finish time"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"FinishBatch"}),(0,s.jsx)(n.td,{children:"Number of completed batches"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"AllBatch"}),(0,s.jsx)(n.td,{children:"Total batches to sync"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ErrMsg"}),(0,s.jsx)(n.td,{children:"Error message (if any)"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"cancelling-jobs",children:"Cancelling Jobs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CANCEL WARM UP JOB WHERE id = 12345;\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," The current version does not support ALTER. To modify configuration, cancel the job and recreate it."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"working-principle",children:"Working Principle"}),"\n",(0,s.jsx)(n.h3,{id:"periodic-synchronization-process",children:"Periodic Synchronization Process"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["FE registers the job and sets ",(0,s.jsx)(n.code,{children:"sync_interval"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"FE periodically checks if the trigger time has been reached (based on the last start time)."}),"\n",(0,s.jsx)(n.li,{children:"Starts the synchronization job (avoiding overlapping executions)."}),"\n",(0,s.jsx)(n.li,{children:"Records status after completion and waits for the next cycle."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"event-triggered-synchronization-process",children:"Event-Triggered Synchronization Process"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The user creates an event-triggered job, FE registers the job and sends it to the source cluster BE."}),"\n",(0,s.jsx)(n.li,{children:"Source BE automatically triggers warm-up after Load, Compaction, or similar events."}),"\n",(0,s.jsx)(n.li,{children:"Sends synchronization requests to the target BE (at Rowset granularity)."}),"\n",(0,s.jsx)(n.li,{children:"After completion, BE reports status back to FE."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"storage-and-scheduling-mechanism",children:"Storage and Scheduling Mechanism"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Synchronization relationships are stored by FE as ",(0,s.jsx)(n.code,{children:"CloudWarmUpJob"}),", supporting multi-job management."]}),"\n",(0,s.jsxs)(n.li,{children:["Multiple ",(0,s.jsx)(n.strong,{children:"Pending Jobs"})," are allowed for the same target cluster, but only one ",(0,s.jsx)(n.strong,{children:"Running Job"})," is allowed at a time; others will queue."]}),"\n",(0,s.jsx)(n.li,{children:"Supports managing synchronization relationships using CLUSTER NAME, including cluster renaming/migration."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"internal-api-design",children:"Internal API Design"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"CacheHotspotManager {\n    long createJob(WarmUpClusterStmt stmt);\n    void cancel(long jobId);\n}\n\nWarmUpClusterStmt(String dstClusterName, String srcClusterName, boolean isForce,\n                  Map<String, String> properties);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"metrics-monitoring",children:"Metrics Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"periodic-jobs---fe-side",children:"Periodic Jobs - FE Side"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Metric Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_warm_up_job_exec_count"}),(0,s.jsx)(n.td,{children:"Number of scheduling executions"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_warm_up_job_requested_tablets"}),(0,s.jsx)(n.td,{children:"Number of tablets submitted"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_warm_up_job_finished_tablets"}),(0,s.jsx)(n.td,{children:"Number of tablets completed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_warm_up_job_latest_start_time"}),(0,s.jsx)(n.td,{children:"Most recent start time"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_warm_up_job_last_finish_time"}),(0,s.jsx)(n.td,{children:"Most recent finish time"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"periodic-jobs---be-side",children:"Periodic Jobs - BE Side"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Metric Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_once_or_periodic_warm_up_submitted_segment_size"}),(0,s.jsx)(n.td,{children:"Size of segments submitted"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_once_or_periodic_warm_up_finished_segment_size"}),(0,s.jsx)(n.td,{children:"Size of segments completed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_once_or_periodic_warm_up_submitted_index_num"}),(0,s.jsx)(n.td,{children:"Number of indexes submitted"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_once_or_periodic_warm_up_finished_index_num"}),(0,s.jsx)(n.td,{children:"Number of indexes completed"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"event-triggered-jobs---source-be",children:"Event-Triggered Jobs - Source BE"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Metric Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_event_driven_warm_up_requested_segment_size"}),(0,s.jsx)(n.td,{children:"Size of segments requested"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_event_driven_warm_up_requested_index_num"}),(0,s.jsx)(n.td,{children:"Number of indexes requested"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_warm_up_rowset_last_call_unix_ts"}),(0,s.jsx)(n.td,{children:"Last request timestamp"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"event-triggered-jobs---target-be",children:"Event-Triggered Jobs - Target BE"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Metric Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_event_driven_warm_up_submitted_segment_num"}),(0,s.jsx)(n.td,{children:"Number of segments received"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_event_driven_warm_up_finished_segment_num"}),(0,s.jsx)(n.td,{children:"Number of segments completed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"file_cache_warm_up_rowset_last_handle_unix_ts"}),(0,s.jsx)(n.td,{children:"Last processing timestamp"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Will a job be canceled entirely if it fails?"}),(0,s.jsx)(n.br,{}),"\nNo, it will only skip the current sync, and the next cycle will continue."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Do periodic jobs support timeout cancellation?"}),(0,s.jsx)(n.br,{}),"\nYes, after timeout, the current round will be skipped but the job itself remains."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Can multiple clusters sync to the same cluster?"}),(0,s.jsx)(n.br,{}),"\nYes, e.g., A -> B and C -> B can exist simultaneously."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"version-information",children:"Version Information"}),"\n",(0,s.jsx)(n.p,{children:"This feature is introduced in Apache Doris version 3.1.0."})]})}function h(e={}){let{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},250065:function(e,n,r){r.d(n,{Z:function(){return d},a:function(){return c}});var i=r(667294);let s={},t=i.createContext(s);function c(e){let n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);