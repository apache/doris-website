"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["842481"],{580300:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>a,metadata:()=>i,assets:()=>l,toc:()=>d,contentTitle:()=>o});var i=JSON.parse('{"id":"table-design/data-model/overview","title":"Table Type Overview","description":"When creating a table in Doris, it is necessary to specify the Table Type to define how data is stored and managed. Doris provides three Table Types: the Duplicate Key Table, Unique Key Table and Aggregate Key Table, which cater to different application scenarios. Each type has corresponding mechanisms for data deduplication, aggregation, and updates. Choosing the appropriate Table Type helps achieve business objectives while ensuring flexibility and efficiency in data processing.","source":"@site/versioned_docs/version-3.x/table-design/data-model/overview.md","sourceDirName":"table-design/data-model","slug":"/table-design/data-model/overview","permalink":"/docs/3.x/table-design/data-model/overview","draft":false,"unlisted":false,"tags":[],"version":"3.x","frontMatter":{"title":"Table Type Overview","language":"en"},"sidebar":"docs","previous":{"title":"Overview","permalink":"/docs/3.x/table-design/overview"},"next":{"title":"Duplicate Key Table","permalink":"/docs/3.x/table-design/data-model/duplicate"}}'),r=t("785893"),s=t("250065");let a={title:"Table Type Overview",language:"en"},o=void 0,l={},d=[{value:"Table Type Classification",id:"table-type-classification",level:2},{value:"Sort Key",id:"sort-key",level:2},{value:"Table Type Comparison",id:"table-type-comparison",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["When creating a table in Doris, it is necessary to specify the Table Type to define how data is stored and managed. Doris provides three Table Types: the ",(0,r.jsx)(n.strong,{children:"Duplicate Key Table"}),", ",(0,r.jsx)(n.strong,{children:"Unique Key Table"})," and ",(0,r.jsx)(n.strong,{children:"Aggregate Key Table"}),", which cater to different application scenarios. Each type has corresponding mechanisms for data deduplication, aggregation, and updates. Choosing the appropriate Table Type helps achieve business objectives while ensuring flexibility and efficiency in data processing."]}),"\n",(0,r.jsx)(n.h2,{id:"table-type-classification",children:"Table Type Classification"}),"\n",(0,r.jsx)(n.p,{children:"Doris supports three types of Table Types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"./duplicate",children:"Duplicate Key Table"}),": Allows the specified Key columns to be duplicated, and Doris's storage layer retains all written data. This type is suitable for situations where all original data records must be preserved."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"./unique",children:"Unique Key Table"}),": Ensures that each row has a unique Key value, and guarantees that there are no duplicate rows for a given Key column. The Doris storage layer retains only the latest written data for each key, making this type suitable for scenarios that involve data updates."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"./aggregate",children:"Aggregate Key Table"}),": Allows data to be aggregated based on the Key columns. The Doris storage layer retains aggregated data, reducing storage space and improving query performance. This type is typically used in situations where summary or aggregated information (such as totals or averages) is required."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"After creating the table, the properties of the Table Type are confirmed and cannot be modified. Choosing the right type for the business is crucial:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Duplicate Key Table"})," is suitable for ad-hoc queries with any dimensions. Although it cannot leverage the benefits of pre-aggregation, it is not constrained by aggregation tables and can take advantage of the columnar storage (only reading relevant columns without needing to read all key columns)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Unique Key Table"})," is designed for scenarios where a unique key constraint is needed, ensuring the uniqueness of the key. However, it cannot utilize the query benefits brought by pre-aggregations such as ROLLUP."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Aggregate Key Table"})," can greatly reduce the data and computation required for aggregation queries through pre-aggregation, making it ideal for fixed-schema reporting queries. However, this type is not friendly to ",(0,r.jsx)(n.code,{children:"count(*)"})," queries. Also, because the aggregation method for the Value columns is fixed, when performing other types of aggregation queries, semantic correctness must be considered."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Update partial columns"}),", please refer to the documentation for ",(0,r.jsx)(n.a,{href:"../../data-operate/update/update-of-aggregate-model",children:"Partial Column Updates in Unique Key Table"})," and ",(0,r.jsx)(n.a,{href:"../../data-operate/update/update-of-aggregate-model",children:"Partial Column Updates in Aggregate Key Table"})," for relevant usage advice."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"sort-key",children:"Sort Key"}),"\n",(0,r.jsx)(n.p,{children:"In Doris, data is stored in a columnar format, and a table can be divided into Key columns and Value columns. The Key columns are used for grouping and sorting, while the Value columns are used for aggregation. Key columns can consist of one or more fields, and when creating a table, data is sorted and stored according to the columns of Aggregate Key, Unique Key, and Duplicate Key Tables."}),"\n",(0,r.jsx)(n.p,{children:"Different Table Types require the specification of Key columns during table creation, each with a different significance: for the Duplicate Key Table, the Key columns represent sorting, without any uniqueness constraints. In the Aggregate Key and Unique Key Tables, aggregation is performed based on the Key columns, which not only have sorting capabilities but also enforce uniqueness constraints."}),"\n",(0,r.jsx)(n.p,{children:"Proper use of the Sort Key can provide the following benefits:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Accelerated Query Performance"}),": Sort keys help reduce the amount of data that needs to be scanned. For range queries or filtering queries, the sort key can directly locate the data. For queries that require sorting, the sort key can also accelerate the sorting process."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Data Compression Optimization"}),": Storing data in an ordered fashion based on the sort key improves compression efficiency, as similar data will be grouped together, significantly increasing the compression ratio and reducing storage space."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reduced Deduplication Costs"}),": When using the Unique Key Table, the sort key allows Doris to perform deduplication more efficiently, ensuring data uniqueness."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When selecting a sort key, the following recommendations can be followed:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The Key columns must come before all Value columns."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Preferably choose integer types. This is because integer types are much more efficient in computation and lookup than strings."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"For selecting different lengths of integer types, follow the principle of choosing what is sufficient."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["For the length of ",(0,r.jsx)(n.code,{children:"VARCHAR"})," and ",(0,r.jsx)(n.code,{children:"STRING"})," types, follow the principle of choosing enough..."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"table-type-comparison",children:"Table Type Comparison"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{}),(0,r.jsx)(n.th,{children:"Duplicate Key Table"}),(0,r.jsx)(n.th,{children:"Unique Key Table"}),(0,r.jsx)(n.th,{children:"Aggregate Key Table"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Key Column Uniqueness"}),(0,r.jsx)(n.td,{children:"Not Supported, Key columns can be duplicated"}),(0,r.jsx)(n.td,{children:"Supported"}),(0,r.jsx)(n.td,{children:"Supported"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Synchronous Materialized View"}),(0,r.jsx)(n.td,{children:"Supported"}),(0,r.jsx)(n.td,{children:"Supported"}),(0,r.jsx)(n.td,{children:"Supported"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Asynchronous Materialized View"}),(0,r.jsx)(n.td,{children:"Supported"}),(0,r.jsx)(n.td,{children:"Supported"}),(0,r.jsx)(n.td,{children:"Supported"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"UPDATE Statement"}),(0,r.jsx)(n.td,{children:"Not Supported"}),(0,r.jsx)(n.td,{children:"Supported"}),(0,r.jsx)(n.td,{children:"Not Supported"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DELETE Statement"}),(0,r.jsx)(n.td,{children:"Partially Supported"}),(0,r.jsx)(n.td,{children:"Supported"}),(0,r.jsx)(n.td,{children:"Not Supported"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Full Row Update on Import"}),(0,r.jsx)(n.td,{children:"Not Supported"}),(0,r.jsx)(n.td,{children:"Supported"}),(0,r.jsx)(n.td,{children:"Not Supported"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Partial Column Update on Import"}),(0,r.jsx)(n.td,{children:"Not Supported"}),(0,r.jsx)(n.td,{children:"Supported"}),(0,r.jsx)(n.td,{children:"Partially Supported"})]})]})]})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return a}});var i=t(667294);let r={},s=i.createContext(r);function a(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);