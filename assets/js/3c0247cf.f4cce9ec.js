"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["206751"],{793348:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>l,metadata:()=>s,assets:()=>a,toc:()=>c,contentTitle:()=>d});var s=JSON.parse('{"id":"sql-manual/basic-element/sql-data-types/conversion/struct-conversion","title":"Cast to STRUCT Types","description":"STRUCT type is used to store and process structured data, which can contain fields of different types, each with a name and corresponding value.","source":"@site/versioned_docs/version-4.x/sql-manual/basic-element/sql-data-types/conversion/struct-conversion.md","sourceDirName":"sql-manual/basic-element/sql-data-types/conversion","slug":"/sql-manual/basic-element/sql-data-types/conversion/struct-conversion","permalink":"/docs/4.x/sql-manual/basic-element/sql-data-types/conversion/struct-conversion","draft":false,"unlisted":false,"tags":[],"version":"4.x","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Cast to STRUCT Types","language":"en","description":"STRUCT type is used to store and process structured data, which can contain fields of different types, each with a name and corresponding value."},"sidebar":"docs","previous":{"title":"Cast to MAP Types","permalink":"/docs/4.x/sql-manual/basic-element/sql-data-types/conversion/map-conversion"},"next":{"title":"Cast to TIME Type","permalink":"/docs/4.x/sql-manual/basic-element/sql-data-types/conversion/time-conversion"}}'),i=t("785893"),r=t("250065");let l={title:"Cast to STRUCT Types",language:"en",description:"STRUCT type is used to store and process structured data, which can contain fields of different types, each with a name and corresponding value."},d=void 0,a={},c=[{value:"Cast to STRUCT",id:"cast-to-struct",level:2},{value:"FROM String",id:"from-string",level:3},{value:"Strict Mode",id:"strict-mode",level:4},{value:"BNF Definition",id:"bnf-definition",level:5},{value:"Rule Description",id:"rule-description",level:5},{value:"Examples",id:"examples",level:5},{value:"Non-Strict Mode",id:"non-strict-mode",level:4},{value:"BNF Definition",id:"bnf-definition-1",level:5},{value:"Rule Description",id:"rule-description-1",level:5},{value:"Examples",id:"examples-1",level:5},{value:"FROM STRUCT&lt;Other Type&gt;",id:"from-structother-type",level:3},{value:"Strict Mode",id:"strict-mode-1",level:4},{value:"Rule Description",id:"rule-description-2",level:5},{value:"Examples",id:"examples-2",level:5},{value:"Non-Strict Mode",id:"non-strict-mode-1",level:4},{value:"Rule Description",id:"rule-description-3",level:5},{value:"Examples",id:"examples-3",level:5}];function o(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"STRUCT type is used to store and process structured data, which can contain fields of different types, each with a name and corresponding value. STRUCT can nest other complex types such as ARRAY, MAP, or other STRUCTs."}),"\n",(0,i.jsx)(n.h2,{id:"cast-to-struct",children:"Cast to STRUCT"}),"\n",(0,i.jsx)(n.h3,{id:"from-string",children:"FROM String"}),"\n",(0,i.jsx)(n.h4,{id:"strict-mode",children:"Strict Mode"}),"\n",(0,i.jsx)(n.h5,{id:"bnf-definition",children:"BNF Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<struct>          ::= "{" <struct-content>? "}" | <empty-struct> \n\n<empty-struct> ::= "{}"\n\n<struct-content>  ::=  <struct-field-value-content> | <struct-only-value-content>\n\n<struct-field-value-content> ::=  <field-token> <map_key_delimiter> <value-token>\n                     (<collection-delim> <field-token> <map_key_delimiter> <value-token>)*\n                         \n<struct-only-value-content> ::=  <value-token>(<collection-delim> <value-token>)*\n\n<value-token>    ::= <whitespace>* "\\"" <inner-sequence> "\\"" <whitespace>*\n                   | <whitespace>* "\'" <inner-sequence> "\'" <whitespace>*\n                   | <whitespace>* <inner-sequence> <whitespace>*\n\n<inner-sequence>    ::= .*\n<collection-delim>  ::= "," \n<map_key_delimiter> ::= ":"\n'})}),"\n",(0,i.jsx)(n.h5,{id:"rule-description",children:"Rule Description"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The textual representation of a STRUCT must begin with a left brace ",(0,i.jsx)(n.code,{children:"{"})," and end with a right brace ",(0,i.jsx)(n.code,{children:"}"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Empty STRUCTs are directly represented as ",(0,i.jsx)(n.code,{children:"{}"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Field-value pairs within the STRUCT are separated by commas ",(0,i.jsx)(n.code,{children:","}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Each field-value pair consists of an optional field name, a colon ",(0,i.jsx)(n.code,{children:":"}),', and a value, in the order "fieldname:value" or simply "value".']}),"\n",(0,i.jsx)(n.li,{children:'Field-value pairs must either all use the "fieldname:value" format or all use the "value" format.'}),"\n",(0,i.jsxs)(n.li,{children:["Field names and values can optionally be enclosed in matching single quotes (",(0,i.jsx)(n.code,{children:"'"}),") or double quotes (",(0,i.jsx)(n.code,{children:'"'}),"). The content inside the quotes is treated as a single entity."]}),"\n",(0,i.jsx)(n.li,{children:"Whitespace is allowed before and after elements within the STRUCT."}),"\n",(0,i.jsxs)(n.li,{children:["During parsing, parts that match ",(0,i.jsx)(n.code,{children:"<value-token>"})," continue to apply the parsing rules of the value type. If there are ",(0,i.jsx)(n.code,{children:"<field-token>"})," parts, they must match the number and order of names defined in the STRUCT."]}),"\n",(0,i.jsx)(n.li,{children:'Elements can use "null" to represent a null value.'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the STRUCT format does not meet the requirements, an error is reported, for example:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The number of field-value pairs does not match the number defined in the STRUCT."}),"\n",(0,i.jsx)(n.li,{children:"The order of field-values does not match the order defined in the STRUCT."}),"\n",(0,i.jsx)(n.li,{children:"Some field-value pairs have field names while others do not (they must either all have field names or none have field names)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If a value in the STRUCT does not meet the requirements of the corresponding type, an error is reported."}),"\n",(0,i.jsx)(n.h5,{id:"examples",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Input String"}),(0,i.jsx)(n.th,{children:"Conversion Result"}),(0,i.jsx)(n.th,{children:"Comment"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'"{}"'}),(0,i.jsx)(n.td,{children:"{}"}),(0,i.jsx)(n.td,{children:"Valid empty STRUCT"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'"  {}"'}),(0,i.jsx)(n.td,{children:"Error"}),(0,i.jsx)(n.td,{children:"Does not start with a brace, parsing fails"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'\'{"a":1,"b":1}\''}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<a:int, b:int>: {"a":1, "b":1}'}),(0,i.jsx)(n.td,{children:"Valid STRUCT with field names"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{a:1,\"b\":3.14}'"}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<a:int, b:double>: {"a":1, "b":3.14}'}),(0,i.jsx)(n.td,{children:"Field names can be quoted or unquoted"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{1,3.14}'"}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<a:int, b:double>: {"a":1, "b":3.14}'}),(0,i.jsx)(n.td,{children:"No field names provided, parsing succeeds"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{a:1,3.1,c:100}'"}),(0,i.jsx)(n.td,{children:"Error"}),(0,i.jsx)(n.td,{children:"Mixed format with some having field names and others not"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{a:1}'"}),(0,i.jsx)(n.td,{children:"Cast to STRUCT<a:int, b:double>: Error"}),(0,i.jsx)(n.td,{children:"Number of field-value pairs does not match defined count"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{b:1,a:1}'"}),(0,i.jsx)(n.td,{children:"Cast to STRUCT<a:int, b:double>: Error"}),(0,i.jsx)(n.td,{children:"Incorrect order of fields"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'\'{"a":"abc","b":1}\''}),(0,i.jsx)(n.td,{children:"Cast to STRUCT<a:int, b:int>: Error"}),(0,i.jsx)(n.td,{children:'"abc" cannot be converted to int type'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{null,1}'"}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<a:int, b:int>: {"a":null, "b":1}'}),(0,i.jsx)(n.td,{children:"Valid STRUCT with null value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'\'{"name":"John","age":25}\''}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<name:string, age:int>: {"name":"John", "age":25}'}),(0,i.jsx)(n.td,{children:"STRUCT with string values"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'\'{{"x":1,"y":2},3}\''}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<point:struct<x:int,y:int>, z:int>: {"point":{"x":1,"y":2}, "z":3}'}),(0,i.jsx)(n.td,{children:"Nested STRUCT structure"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"non-strict-mode",children:"Non-Strict Mode"}),"\n",(0,i.jsx)(n.h5,{id:"bnf-definition-1",children:"BNF Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<struct>          ::= "{" <struct-content>? "}" | <empty-struct> \n\n<empty-struct> ::= "{}"\n\n<struct-content>  ::=  <struct-field-value-content> | <struct-only-value-content>\n\n<struct-field-value-content> ::=  <field-token> <map_key_delimiter> <value-token>\n                     (<collection-delim> <field-token> <map_key_delimiter> <value-token>)*\n                         \n<struct-only-value-content> ::=  <value-token>(<collection-delim> <value-token>)*\n\n<value-token>    ::= <whitespace>* "\\"" <inner-sequence> "\\"" <whitespace>*\n                   | <whitespace>* "\'" <inner-sequence> "\'" <whitespace>*\n                   | <whitespace>* <inner-sequence> <whitespace>*\n\n<inner-sequence>    ::= .*\n<collection-delim>  ::= "," \n<map_key_delimiter> ::= ":"\n'})}),"\n",(0,i.jsx)(n.h5,{id:"rule-description-1",children:"Rule Description"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The textual representation of a STRUCT must begin with a left brace ",(0,i.jsx)(n.code,{children:"{"})," and end with a right brace ",(0,i.jsx)(n.code,{children:"}"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Empty STRUCTs are directly represented as ",(0,i.jsx)(n.code,{children:"{}"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Field-value pairs within the STRUCT are separated by commas ",(0,i.jsx)(n.code,{children:","}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Each field-value pair consists of an optional field name, a colon ",(0,i.jsx)(n.code,{children:":"}),', and a value, in the order "fieldname:value" or simply "value".']}),"\n",(0,i.jsx)(n.li,{children:'Field-value pairs must either all use the "fieldname:value" format or all use the "value" format.'}),"\n",(0,i.jsxs)(n.li,{children:["Field names and values can optionally be enclosed in matching single quotes (",(0,i.jsx)(n.code,{children:"'"}),") or double quotes (",(0,i.jsx)(n.code,{children:'"'}),"). The content inside the quotes is treated as a single entity."]}),"\n",(0,i.jsx)(n.li,{children:"Whitespace is allowed before and after elements within the STRUCT."}),"\n",(0,i.jsxs)(n.li,{children:["During parsing, parts that match ",(0,i.jsx)(n.code,{children:"<value-token>"})," continue to apply the parsing rules of the value type. If there are ",(0,i.jsx)(n.code,{children:"<field-token>"})," parts, they must match the number and order of names defined in the STRUCT."]}),"\n",(0,i.jsx)(n.li,{children:'Elements can use "null" to represent a null value.'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the STRUCT format does not meet the requirements, NULL is returned, for example:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The number of field-value pairs does not match the number defined in the STRUCT."}),"\n",(0,i.jsx)(n.li,{children:"The order of field-values does not match the order defined in the STRUCT."}),"\n",(0,i.jsx)(n.li,{children:"Some field-value pairs have field names while others do not (they must either all have field names or none have field names)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If a value in the STRUCT does not meet the requirements of the corresponding type, the corresponding position is set to null."}),"\n",(0,i.jsx)(n.h5,{id:"examples-1",children:"Examples"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Input String"}),(0,i.jsx)(n.th,{children:"Conversion Result"}),(0,i.jsx)(n.th,{children:"Comment"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'"{}"'}),(0,i.jsx)(n.td,{children:"{}"}),(0,i.jsx)(n.td,{children:"Valid empty STRUCT"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'"  {}"'}),(0,i.jsx)(n.td,{children:"NULL"}),(0,i.jsx)(n.td,{children:"Does not start with a brace, parsing fails"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'\'{"a":1,"b":1}\''}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<a:int, b:int>: {"a":1, "b":1}'}),(0,i.jsx)(n.td,{children:"Valid STRUCT with field names"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{a:1,\"b\":3.14}'"}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<a:int, b:double>: {"a":1, "b":3.14}'}),(0,i.jsx)(n.td,{children:"Field names can be quoted or unquoted"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{1,3.14}'"}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<a:int, b:double>: {"a":1, "b":3.14}'}),(0,i.jsx)(n.td,{children:"No field names provided, parsing succeeds"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{a:1,3.1,c:100}'"}),(0,i.jsx)(n.td,{children:"NULL"}),(0,i.jsx)(n.td,{children:"Mixed format with some having field names and others not"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{a:1}'"}),(0,i.jsx)(n.td,{children:"Cast to STRUCT<a:int, b:double>: NULL"}),(0,i.jsx)(n.td,{children:"Number of field-value pairs does not match defined count"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{b:1,a:1}'"}),(0,i.jsx)(n.td,{children:"Cast to STRUCT<a:int, b:double>: NULL"}),(0,i.jsx)(n.td,{children:"Incorrect order of fields"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'\'{"a":"abc","b":1}\''}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<a:int, b:int>: {"a":null, "b":1}'}),(0,i.jsx)(n.td,{children:'"abc" cannot be converted to int type, position set to null'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"'{null,1}'"}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<a:int, b:int>: {"a":null, "b":1}'}),(0,i.jsx)(n.td,{children:"Valid STRUCT with null value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'\'{"name":"John","age":"twenty-five"}\''}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<name:string, age:int>: {"name":"John", "age":null}'}),(0,i.jsx)(n.td,{children:'"twenty-five" cannot be converted to int type, position set to null'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'\'{{"x":"one","y":2},3}\''}),(0,i.jsx)(n.td,{children:'Cast to STRUCT<point:struct<x:int,y:int>, z:int>: {"point":{"x":null,"y":2}, "z":3}'}),(0,i.jsx)(n.td,{children:"In nested STRUCT, failed conversion results in null"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"from-structother-type",children:"FROM STRUCT<Other Type>"}),"\n",(0,i.jsx)(n.p,{children:"When the source data is of STRUCT type and the target is also of STRUCT type, the following conditions must be met:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The source STRUCT and target STRUCT must have the same number of elements (fields)"}),"\n",(0,i.jsx)(n.li,{children:"Each element in the source STRUCT will be converted to the corresponding element type in the target STRUCT in sequence"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the above conditions are not met, such as when the number of elements doesn't match, the conversion will not be possible."}),"\n",(0,i.jsx)(n.h4,{id:"strict-mode-1",children:"Strict Mode"}),"\n",(0,i.jsx)(n.h5,{id:"rule-description-2",children:"Rule Description"}),"\n",(0,i.jsx)(n.p,{children:"For each element in the STRUCT, a Cast from Other Type To Type is performed. The Cast is also in strict mode."}),"\n",(0,i.jsx)(n.h5,{id:"examples-2",children:"Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Create a simple STRUCT type variable\nmysql> SELECT named_struct('a', 123, 'b', 'abc') AS original_struct;\n+----------------------+\n| original_struct      |\n+----------------------+\n| {\"a\":123, \"b\":\"abc\"} |\n+----------------------+\n-- Result: {\"a\":123,\"b\":\"abc\"} Type: struct<a:tinyint,b:varchar(3)>\n\n-- Normal CAST\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<c:bigint, d:string>) AS renamed_struct;\n+----------------------+\n| renamed_struct       |\n+----------------------+\n| {\"c\":123, \"d\":\"abc\"} |\n+----------------------+\n\n-- Fields count doesn't match\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<c:bigint, d:string,e:char>) AS renamed_struct;\nERROR 1105 (HY000): errCode = 2, detailMessage = can not cast from ...\n\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<c:bigint>) AS renamed_struct;\nERROR 1105 (HY000): errCode = 2, detailMessage = can not cast from ...\n\n-- Element in STRUCT doesn't have a corresponding CAST\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<b:Array<int>, a:int>) AS renamed_struct;\nERROR 1105 (HY000): errCode = 2, detailMessage = can not cast from ...\n\n-- CAST is based on the defined order, not field names\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<b:string, a:int>) AS renamed_struct;\n+------------------------+\n| renamed_struct         |\n+------------------------+\n| {\"b\":\"123\", \"a\":\"abc\"} |\n+------------------------+\n\n-- Element CAST fails, the whole CAST reports an error\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<b:string, a:int>) AS renamed_struct;\nERROR 1105 (HY000): errCode = 2, detailMessage = (127.0.0.1)[INVALID_ARGUMENT]parse number fail, string: 'abc'\n"})}),"\n",(0,i.jsx)(n.h4,{id:"non-strict-mode-1",children:"Non-Strict Mode"}),"\n",(0,i.jsx)(n.h5,{id:"rule-description-3",children:"Rule Description"}),"\n",(0,i.jsx)(n.p,{children:"For each element in the STRUCT, a Cast from Other Type To Type is performed. The Cast is also in non-strict mode."}),"\n",(0,i.jsx)(n.h5,{id:"examples-3",children:"Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Create a simple STRUCT type variable\nmysql> SELECT named_struct('a', 123, 'b', 'abc') AS original_struct;\n+----------------------+\n| original_struct      |\n+----------------------+\n| {\"a\":123, \"b\":\"abc\"} |\n+----------------------+\n-- Result: {\"a\":123,\"b\":\"abc\"} Type: struct<a:tinyint,b:varchar(3)>\n\n-- Normal CAST\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<c:bigint, d:string>) AS renamed_struct;\n+----------------------+\n| renamed_struct       |\n+----------------------+\n| {\"c\":123, \"d\":\"abc\"} |\n+----------------------+\n\n-- Fields count doesn't match\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<c:bigint, d:string,e:char>) AS renamed_struct;\nERROR 1105 (HY000): errCode = 2, detailMessage = can not cast from ...\n\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<c:bigint>) AS renamed_struct;\nERROR 1105 (HY000): errCode = 2, detailMessage = can not cast from ...\n\n-- Element in STRUCT doesn't have a corresponding CAST\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<b:Array<int>, a:int>) AS renamed_struct;\nERROR 1105 (HY000): errCode = 2, detailMessage = can not cast from ...\n\n-- CAST is based on the defined order, not field names\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<b:string, a:int>) AS renamed_struct;\n+------------------------+\n| renamed_struct         |\n+------------------------+\n| {\"b\":\"123\", \"a\":\"abc\"} |\n+------------------------+\n\n-- Element CAST fails, the corresponding element is set to null\nmysql> SELECT CAST(named_struct('a', 123, 'b', 'abc') AS STRUCT<b:string, a:int>) AS renamed_struct;\n+-----------------------+\n| renamed_struct        |\n+-----------------------+\n| {\"b\":\"123\", \"a\":null} |\n+-----------------------+\n"})})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return d},a:function(){return l}});var s=t(667294);let i={},r=s.createContext(i);function l(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);