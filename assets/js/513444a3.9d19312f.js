"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["867325"],{534213:function(e,t,n){n.r(t),n.d(t,{default:()=>c,frontMatter:()=>o,metadata:()=>r,assets:()=>p,toc:()=>l,contentTitle:()=>s});var r=JSON.parse('{"id":"data-operate/delete/table-temp-partition","title":"Temporary Partition","description":"Doris supports adding temporary partitions to partitioned tables.","source":"@site/versioned_docs/version-2.1/data-operate/delete/table-temp-partition.md","sourceDirName":"data-operate/delete","slug":"/data-operate/delete/table-temp-partition","permalink":"/docs/2.1/data-operate/delete/table-temp-partition","draft":false,"unlisted":false,"tags":[],"version":"2.1","lastUpdatedAt":1770477659000,"frontMatter":{"title":"Temporary Partition","language":"en","description":"Doris supports adding temporary partitions to partitioned tables."},"sidebar":"docs","previous":{"title":"Replacing Atomic Table","permalink":"/docs/2.1/data-operate/delete/atomicity-replace"},"next":{"title":"Transaction","permalink":"/docs/2.1/data-operate/transaction"}}'),a=n("785893"),i=n("250065");let o={title:"Temporary Partition",language:"en",description:"Doris supports adding temporary partitions to partitioned tables."},s=void 0,p={},l=[{value:"Add Temporary Partition",id:"add-temporary-partition",level:2},{value:"Drop Temporary Partition",id:"drop-temporary-partition",level:2},{value:"Replace Regular Partition",id:"replace-regular-partition",level:2},{value:"Import Temporary Partition",id:"import-temporary-partition",level:2},{value:"Query Temporary Partition",id:"query-temporary-partition",level:2},{value:"Relationship with Other Operations",id:"relationship-with-other-operations",level:2}];function d(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Doris supports adding temporary partitions to partitioned tables. Temporary partitions differ from regular partitions in that they are not retrieved by regular queries and can only be queried through special query statements."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"The partition columns of temporary partitions are the same as those of regular partitions and cannot be modified."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"The partition ranges of all temporary partitions cannot overlap, but the ranges of temporary partitions and regular partitions can overlap."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"The names of temporary partitions cannot duplicate those of regular partitions or other temporary partitions."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Main application scenarios for temporary partitions:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Atomic overwrite operation"}),": Users can rewrite the data of a partition without data loss between deleting old data and importing new data. In this case, a temporary partition can be created, new data can be imported into the temporary partition, and then the original partition can be atomically replaced through a replace operation. For atomic overwrite operations on non-partitioned tables, refer to the ",(0,a.jsx)(t.a,{href:"../../data-operate/delete/atomicity-replace",children:"replace table documentation"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Modify the number of buckets"}),": If an inappropriate number of buckets was used when creating a partition, a new temporary partition can be created with the specified new number of buckets. Then, the data of the regular partition can be imported into the temporary partition using the ",(0,a.jsx)(t.code,{children:"INSERT INTO"})," command, and the original partition can be atomically replaced through a replace operation."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Merge or split partitions"}),": Users can modify the partition range, such as merging two partitions or splitting a large partition into multiple smaller partitions. A new temporary partition can be created, the data of the regular partition can be imported into the temporary partition using the ",(0,a.jsx)(t.code,{children:"INSERT INTO"})," command, and the original partition can be atomically replaced through a replace operation."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"add-temporary-partition",children:"Add Temporary Partition"}),"\n",(0,a.jsxs)(t.p,{children:["Use the ",(0,a.jsx)(t.code,{children:"ALTER TABLE ADD TEMPORARY PARTITION"})," statement to add a temporary partition:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'ALTER TABLE tbl1 ADD TEMPORARY PARTITION tp1 VALUES LESS THAN("2020-02-01");\n\nALTER TABLE tbl2 ADD TEMPORARY PARTITION tp1 VALUES [("2020-01-01"), ("2020-02-01"));\n\nALTER TABLE tbl1 ADD TEMPORARY PARTITION tp1 VALUES LESS THAN("2020-02-01")\n("replication_num" = "1")\nDISTRIBUTED BY HASH(k1) BUCKETS 5;\n\nALTER TABLE tbl3 ADD TEMPORARY PARTITION tp1 VALUES IN ("Beijing", "Shanghai");\n\nALTER TABLE tbl4 ADD TEMPORARY PARTITION tp1 VALUES IN ((1, "Beijing"), (1, "Shanghai"));\n\nALTER TABLE tbl3 ADD TEMPORARY PARTITION tp1 VALUES IN ("Beijing", "Shanghai")\n("replication_num" = "1")\nDISTRIBUTED BY HASH(k1) BUCKETS 5;\n'})}),"\n",(0,a.jsx)(t.h2,{id:"drop-temporary-partition",children:"Drop Temporary Partition"}),"\n",(0,a.jsxs)(t.p,{children:["Use the ",(0,a.jsx)(t.code,{children:"ALTER TABLE DROP TEMPORARY PARTITION"})," statement to drop a temporary partition:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"ALTER TABLE tbl1 DROP TEMPORARY PARTITION tp1;\n"})}),"\n",(0,a.jsx)(t.h2,{id:"replace-regular-partition",children:"Replace Regular Partition"}),"\n",(0,a.jsxs)(t.p,{children:["Use the ",(0,a.jsx)(t.code,{children:"ALTER TABLE REPLACE PARTITION"})," statement to replace a regular partition with a temporary partition:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'ALTER TABLE tbl1 REPLACE PARTITION (p1) WITH TEMPORARY PARTITION (tp1);\n\nALTER TABLE tbl1 REPLACE PARTITION (p1, p2) WITH TEMPORARY PARTITION (tp1, tp2, tp3);\n\nALTER TABLE tbl1 REPLACE PARTITION (p1, p2) WITH TEMPORARY PARTITION (tp1, tp2)\nPROPERTIES (\n  "strict_range" = "false",\n  "use_temp_partition_name" = "true"\n);\n'})}),"\n",(0,a.jsx)(t.p,{children:"There are two special optional parameters for the replace operation:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["1. ",(0,a.jsx)(t.code,{children:"strict_range"})]})}),"\n",(0,a.jsx)(t.p,{children:"Default is true."}),"\n",(0,a.jsx)(t.p,{children:"For Range partitions, when this parameter is true, the union of the ranges of all replaced regular partitions must be exactly the same as the union of the ranges of the replacing temporary partitions. When set to false, it only needs to ensure that the ranges of the new regular partitions do not overlap after replacement."}),"\n",(0,a.jsx)(t.p,{children:"For List partitions, this parameter is always true. The enumeration values of all replaced regular partitions must be exactly the same as the enumeration values of the replacing temporary partitions."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Example 1"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"-- The range of partitions p1, p2, p3 to be replaced (=> union):\n[10, 20), [20, 30), [40, 50) => [10, 30), [40, 50)\n\n-- The range of replacing partitions tp1, tp2 (=> union):\n[10, 30), [40, 45), [45, 50) => [10, 30), [40, 50)\n\n-- The union of ranges is the same, so tp1 and tp2 can replace p1, p2, p3.\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Example 2"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"-- The range of partition p1 to be replaced (=> union):\n[10, 50) => [10, 50)\n\n-- The range of replacing partitions tp1, tp2 (=> union):\n[10, 30), [40, 50) => [10, 30), [40, 50)\n\n-- The union of ranges is not the same. If strict_range is true, tp1 and tp2 cannot replace p1. If it is false, and the ranges of the two partitions after replacement [10, 30), [40, 50) do not overlap with other regular partitions, they can replace p1.\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Example 3"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"-- The enumeration values of partitions p1, p2 to be replaced (=> union):\n(1, 2, 3), (4, 5, 6) => (1, 2, 3, 4, 5, 6)\n\n-- The enumeration values of replacing partitions tp1, tp2, tp3 (=> union):\n(1, 2, 3), (4), (5, 6) => (1, 2, 3, 4, 5, 6)\n\n-- The union of enumeration values is the same, so tp1, tp2, tp3 can replace p1, p2.\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Example 4"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'-- The enumeration values of partitions p1, p2, p3 to be replaced (=> union):\n(("1","beijing"), ("1", "shanghai")), (("2","beijing"), ("2", "shanghai")), (("3","beijing"), ("3", "shanghai")) => (("1","beijing"), ("1", "shanghai"), ("2","beijing"), ("2", "shanghai"), ("3","beijing"), ("3", "shanghai"))\n\n-- The enumeration values of replacing partitions tp1, tp2 (=> union):\n(("1","beijing"), ("1", "shanghai")), (("2","beijing"), ("2", "shanghai"), ("3","beijing"), ("3", "shanghai")) => (("1","beijing"), ("1", "shanghai"), ("2","beijing"), ("2", "shanghai"), ("3","beijing"), ("3", "shanghai"))\n\n-- The union of enumeration values is the same, so tp1, tp2 can replace p1, p2, p3.\n'})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["2. ",(0,a.jsx)(t.code,{children:"use_temp_partition_name"})]})}),"\n",(0,a.jsx)(t.p,{children:"Default is false."}),"\n",(0,a.jsx)(t.p,{children:"When this parameter is false, and the number of partitions to be replaced is the same as the number of replacing partitions, the names of the partitions remain unchanged after replacement."}),"\n",(0,a.jsx)(t.p,{children:"If it is true, the names of the partitions after replacement will be the names of the replacing partitions. Examples are as follows:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Example 1"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"ALTER TABLE tbl1 REPLACE PARTITION (p1) WITH TEMPORARY PARTITION (tp1);\n"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"use_temp_partition_name"})," defaults to false, so after replacement, the partition name remains p1, but the data and properties are replaced with those of tp1."]}),"\n",(0,a.jsxs)(t.li,{children:["If ",(0,a.jsx)(t.code,{children:"use_temp_partition_name"})," is true, after replacement, the partition name is tp1, and p1 no longer exists."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Example 2"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"ALTER TABLE tbl1 REPLACE PARTITION (p1, p2) WITH TEMPORARY PARTITION (tp1);\n"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"use_temp_partition_name"})," defaults to false, but since the number of partitions to be replaced is different from the number of replacing partitions, this parameter is invalid. After replacement, the partition name is tp1, and p1 and p2 no longer exist."]}),"\n"]}),"\n",(0,a.jsxs)(t.admonition,{type:"tip",children:[(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Explanation of the replace operation:"})}),(0,a.jsx)(t.p,{children:"After the partition replacement is successful, the replaced partitions will be deleted and cannot be recovered."})]}),"\n",(0,a.jsx)(t.h2,{id:"import-temporary-partition",children:"Import Temporary Partition"}),"\n",(0,a.jsx)(t.p,{children:"The syntax for specifying the import of temporary partitions varies slightly depending on the import method. Examples are as follows:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'INSERT INTO tbl TEMPORARY PARTITION(tp1, tp2, ...) SELECT ....\ncurl --location-trusted -u root: -H "label:123" -H "temporary_partitions: tp1, tp2, ..." -T testData http://host:port/api/testDb/testTbl/_stream_load    \nLOAD LABEL example_db.label1\n(\nDATA INFILE("hdfs://hdfs_host:hdfs_port/user/palo/data/input/file")\nINTO TABLE my_table\nTEMPORARY PARTITION (tp1, tp2, ...)\n...\n)\nWITH BROKER hdfs ("username"="hdfs_user", "password"="hdfs_password");\nCREATE ROUTINE LOAD example_db.test1 ON example_tbl\nCOLUMNS(k1, k2, k3, v1, v2, v3 = k1 * 100),\nTEMPORARY PARTITIONS(tp1, tp2, ...),\nWHERE k1 > 100\nPROPERTIES\n(...)\nFROM KAFKA\n(...);\n'})}),"\n",(0,a.jsx)(t.h2,{id:"query-temporary-partition",children:"Query Temporary Partition"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"SELECT ... FROM\ntbl1 TEMPORARY PARTITION(tp1, tp2, ...)\nJOIN\ntbl2 TEMPORARY PARTITION(tp1, tp2, ...)\nON ...\nWHERE ...;\n"})}),"\n",(0,a.jsx)(t.h2,{id:"relationship-with-other-operations",children:"Relationship with Other Operations"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"DROP"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"After using the Drop operation to directly delete a database or table, the database or table can be recovered using the Recover command (within a limited time), but temporary partitions will not be recovered."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"After using the Alter command to delete a regular partition, the partition can be recovered using the Recover command (within a limited time). This operation is unrelated to temporary partitions."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"After using the Alter command to delete a temporary partition, the temporary partition cannot be recovered using the Recover command."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"TRUNCATE"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Using the Truncate command to empty a table will delete the table's temporary partitions, and they cannot be recovered."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Using the Truncate command to empty a regular partition does not affect temporary partitions."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"The Truncate command cannot be used to empty temporary partitions."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"ALTER"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"When a table has temporary partitions, the Alter command cannot be used to perform Schema Change, Rollup, or other change operations on the table."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"When a table is undergoing change operations, temporary partitions cannot be added to the table."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{})})]})}function c(e={}){let{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return s},a:function(){return o}});var r=n(667294);let a={},i=r.createContext(a);function o(e){let t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);