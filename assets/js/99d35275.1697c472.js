"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["627430"],{820895:function(n,e,s){s.r(e),s.d(e,{default:()=>d,frontMatter:()=>o,metadata:()=>a,assets:()=>c,toc:()=>r,contentTitle:()=>l});var a=JSON.parse('{"id":"sql-manual/sql-functions/scalar-functions/json-functions/json-hash","title":"JSON_HASH","description":"\x3c!--","source":"@site/docs/sql-manual/sql-functions/scalar-functions/json-functions/json-hash.md","sourceDirName":"sql-manual/sql-functions/scalar-functions/json-functions","slug":"/sql-manual/sql-functions/scalar-functions/json-functions/json-hash","permalink":"/docs/dev/sql-manual/sql-functions/scalar-functions/json-functions/json-hash","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"JSON_HASH","language":"en"},"sidebar":"docs","previous":{"title":"JSON_EXTRACT_STRING","permalink":"/docs/dev/sql-manual/sql-functions/scalar-functions/json-functions/json-extract-string"},"next":{"title":"JSON_INSERT","permalink":"/docs/dev/sql-manual/sql-functions/scalar-functions/json-functions/json-insert"}}'),t=s("785893"),i=s("250065");let o={title:"JSON_HASH",language:"en"},l=void 0,c={},r=[{value:"Description",id:"description",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Alias",id:"alias",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"Usage",id:"usage",level:2},{value:"Examples",id:"examples",level:2},{value:"Notes",id:"notes",level:2}];function h(n){let e={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"description",children:"Description"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"JSON_HASH"})," calculates a hash value for a JSON object. This function accepts a JSON type parameter and returns a BIGINT hash value."]}),"\n",(0,t.jsx)(e.p,{children:"When calculating the hash value of a JSON object, the function sorts the keys of the JSON object before calculation, ensuring that JSON objects with identical content but different key orders produce the same hash value."}),"\n",(0,t.jsx)(e.h2,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sql",children:"JSON_HASH(json_value)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"alias",children:"Alias"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:"JSONB_HASH"})}),"\n",(0,t.jsx)(e.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"json_value"})," - The JSON value for which to calculate a hash value. Must be of JSON type."]}),"\n",(0,t.jsx)(e.h2,{id:"return-value",children:"Return Value"}),"\n",(0,t.jsx)(e.p,{children:"Returns a BIGINT hash value."}),"\n",(0,t.jsx)(e.p,{children:"When the input is NULL, the function returns NULL."}),"\n",(0,t.jsx)(e.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(e.p,{children:["Since the JSON standard specifies that key-value pairs in JSON objects are unordered, to ensure consistent identification of JSON objects with the same content across different systems, the ",(0,t.jsx)(e.code,{children:"JSON_HASH"})," function sorts the key-value pairs before calculating the hash value, similar to calling the ",(0,t.jsx)(e.code,{children:"SORT_JSON_OBJECT_KEYS"})," function."]}),"\n",(0,t.jsx)(e.p,{children:"Additionally, for duplicate keys in JSON objects, although Doris allows them to exist, the hash calculation only considers the first occurring key-value pair, which better matches real-world application scenarios."}),"\n",(0,t.jsx)(e.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Basic hash calculation"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sql",children:"SELECT json_hash(cast('123' as json));\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-text",children:"+--------------------------------+\n| json_hash(cast('123' as json)) |\n+--------------------------------+\n|            5279066513252500087 |\n+--------------------------------+\n"})}),"\n",(0,t.jsxs)(e.ol,{start:"2",children:["\n",(0,t.jsx)(e.li,{children:"Verifying alias function"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sql",children:"SELECT json_hash(cast('123' as json)), jsonb_hash(cast('123' as json));\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-text",children:"+--------------------------------+---------------------------------+\n| json_hash(cast('123' as json)) | jsonb_hash(cast('123' as json)) |\n+--------------------------------+---------------------------------+\n|            5279066513252500087 |             5279066513252500087 |\n+--------------------------------+---------------------------------+\n"})}),"\n",(0,t.jsxs)(e.p,{children:["As shown, ",(0,t.jsx)(e.code,{children:"json_hash"})," and ",(0,t.jsx)(e.code,{children:"jsonb_hash"})," functions produce identical hash values for the same input, confirming they are equivalent alias functions."]}),"\n",(0,t.jsxs)(e.ol,{start:"3",children:["\n",(0,t.jsx)(e.li,{children:"Key sorting verification"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sql",children:'SELECT \n    json_hash(cast(\'{"a":123, "b":456}\' as json)), \n    json_hash(cast(\'{"b":456, "a":123}\' as json));\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-text",children:'+-----------------------------------------------+-----------------------------------------------+\n| json_hash(cast(\'{"a":123, "b":456}\' as json)) | json_hash(cast(\'{"b":456, "a":123}\' as json)) |\n+-----------------------------------------------+-----------------------------------------------+\n|                             82454694884268544 |                             82454694884268544 |\n+-----------------------------------------------+-----------------------------------------------+\n'})}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"json_hash"})," function generates the same hash value regardless of key order because it sorts the keys before calculating the hash value."]}),"\n",(0,t.jsxs)(e.ol,{start:"4",children:["\n",(0,t.jsx)(e.li,{children:"Handling duplicate keys"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sql",children:'SELECT \n    json_hash(cast(\'{"a":123}\' as json)), \n    json_hash(cast(\'{"a":456}\' as json)), \n    json_hash(cast(\'{"a":123, "a":456}\' as json));\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-text",children:'+--------------------------------------+--------------------------------------+-----------------------------------------------+\n| json_hash(cast(\'{"a":123}\' as json)) | json_hash(cast(\'{"a":456}\' as json)) | json_hash(cast(\'{"a":123, "a":456}\' as json)) |\n+--------------------------------------+--------------------------------------+-----------------------------------------------+\n|                 -7416836614234106918 |                 -3126362109586887012 |                          -7416836614234106918 |\n+--------------------------------------+--------------------------------------+-----------------------------------------------+\n'})}),"\n",(0,t.jsxs)(e.p,{children:["When a JSON object contains duplicate keys (",(0,t.jsx)(e.code,{children:'{"a":123, "a":456}'}),"), the ",(0,t.jsx)(e.code,{children:"json_hash"})," function only considers the first key-value pair for hash calculation. As shown, the hash value of the JSON object with duplicate keys matches that of the object containing only the first key-value pair ",(0,t.jsx)(e.code,{children:'{"a":123}'}),"."]}),"\n",(0,t.jsxs)(e.ol,{start:"5",children:["\n",(0,t.jsx)(e.li,{children:"Different number type handling"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sql",children:"SELECT \n    json_hash(to_json(cast('123' as int))), \n    json_hash(to_json(cast('123' as tinyint)));\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-text",children:"+----------------------------------------+--------------------------------------------+\n| json_hash(to_json(cast('123' as int))) | json_hash(to_json(cast('123' as tinyint))) |\n+----------------------------------------+--------------------------------------------+\n|                    7882559133986259892 |                        5279066513252500087 |\n+----------------------------------------+--------------------------------------------+\n"})}),"\n",(0,t.jsx)(e.p,{children:"The same numeric value 123, when stored in JSON with different types (int and tinyint), produces different hash values. This is because Doris's JSON implementation preserves type information, and the hash calculation considers these type differences."}),"\n",(0,t.jsxs)(e.ol,{start:"6",children:["\n",(0,t.jsx)(e.li,{children:"Using normalize_json_numbers_to_double for uniform type"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sql",children:"SELECT \n    json_hash(normalize_json_numbers_to_double(to_json(cast('123' as int)))), \n    json_hash(normalize_json_numbers_to_double(to_json(cast('123' as tinyint))));\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-text",children:"+--------------------------------------------------------------------------+------------------------------------------------------------------------------+\n| json_hash(normalize_json_numbers_to_double(to_json(cast('123' as int)))) | json_hash(normalize_json_numbers_to_double(to_json(cast('123' as tinyint)))) |\n+--------------------------------------------------------------------------+------------------------------------------------------------------------------+\n|                                                      4028523408277343359 |                                                          4028523408277343359 |\n+--------------------------------------------------------------------------+------------------------------------------------------------------------------+\n"})}),"\n",(0,t.jsxs)(e.p,{children:["This example demonstrates how to solve the above issue: use the ",(0,t.jsx)(e.code,{children:"normalize_json_numbers_to_double"})," function to first convert all numeric values to double precision floating-point type, then calculate the hash value. This ensures consistent hash values regardless of the original numeric type."]}),"\n",(0,t.jsxs)(e.ol,{start:"7",children:["\n",(0,t.jsx)(e.li,{children:"Handling NULL values"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sql",children:"SELECT json_hash(null);\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-text",children:"+-----------------+\n| json_hash(null) |\n+-----------------+\n|            NULL |\n+-----------------+\n"})}),"\n",(0,t.jsx)(e.h2,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"JSON_HASH"})," function has an alias ",(0,t.jsx)(e.code,{children:"JSONB_HASH"}),", both functions have identical functionality."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["This function sorts the keys of JSON objects before calculating hash values, similar to calling the ",(0,t.jsx)(e.code,{children:"SORT_JSON_OBJECT_KEYS"})," function."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"For duplicate keys in JSON objects, the function only considers the first occurring key-value pair for hash calculation."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Because Doris's JSON can store numbers in different types (int, tinyint, bigint, float, double, decimal), the same numeric value with different types may produce different hash values. If consistency is required, you can use the ",(0,t.jsx)(e.code,{children:"NORMALIZE_JSON_NUMBERS_TO_DOUBLE"})," function to convert all numeric values to a uniform type before calculating hash values."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["When JSON objects are created through text parsing (such as using ",(0,t.jsx)(e.code,{children:"CAST"})," to convert a string to JSON), Doris automatically selects the appropriate numeric type for storage, so typically you don't need to worry about numeric type inconsistency issues."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:['Note that if you don\'t manually convert "123" to a JSON object using ',(0,t.jsx)(e.code,{children:"cast/to_json"}),', but instead use text conversion (parsing JSON objects from strings), Doris will only store "123" as a tinyint type JSON object, and won\'t have a situation where "123" is stored as both int type and tinyint type.']}),"\n"]}),"\n"]})]})}function d(n={}){let{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},250065:function(n,e,s){s.d(e,{Z:function(){return l},a:function(){return o}});var a=s(667294);let t={},i=a.createContext(t);function o(n){let e=a.useContext(i);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);