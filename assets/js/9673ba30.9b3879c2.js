"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["523836"],{347353:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>i,assets:()=>d,toc:()=>l,contentTitle:()=>a});var i=JSON.parse('{"id":"table-design/data-model/overview","title":"Table Model Overview","description":"When creating a table in Doris, it is necessary to specify the table model to define how data is stored and managed. Doris provides three table models: the Duplicate Key Model, Unique Key Model and Aggregate Key Model, which cater to different application scenarios. Each model has corresponding mechanisms for data deduplication, aggregation, and updates. Choosing the appropriate table model helps achieve business objectives while ensuring flexibility and efficiency in data processing.","source":"@site/versioned_docs/version-2.0/table-design/data-model/overview.md","sourceDirName":"table-design/data-model","slug":"/table-design/data-model/overview","permalink":"/docs/2.0/table-design/data-model/overview","draft":false,"unlisted":false,"tags":[],"version":"2.0","frontMatter":{"title":"Table Model Overview","language":"en"},"sidebar":"docs","previous":{"title":"Data Types","permalink":"/docs/2.0/table-design/data-type"},"next":{"title":"Duplicate Key Model","permalink":"/docs/2.0/table-design/data-model/duplicate"}}'),s=t("785893"),r=t("250065");let o={title:"Table Model Overview",language:"en"},a=void 0,d={},l=[{value:"Table Model Classification",id:"table-model-classification",level:2},{value:"Sort Key",id:"sort-key",level:2},{value:"Table Model Comparison",id:"table-model-comparison",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["When creating a table in Doris, it is necessary to specify the table model to define how data is stored and managed. Doris provides three table models: the ",(0,s.jsx)(n.strong,{children:"Duplicate Key Model"}),", ",(0,s.jsx)(n.strong,{children:"Unique Key Model"})," and ",(0,s.jsx)(n.strong,{children:"Aggregate Key Model"}),", which cater to different application scenarios. Each model has corresponding mechanisms for data deduplication, aggregation, and updates. Choosing the appropriate table model helps achieve business objectives while ensuring flexibility and efficiency in data processing."]}),"\n",(0,s.jsx)(n.h2,{id:"table-model-classification",children:"Table Model Classification"}),"\n",(0,s.jsx)(n.p,{children:"Doris supports three types of table models:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"./duplicate",children:"Duplicate Key Model"}),": Allows the specified Key columns to be duplicated, and Doris's storage layer retains all written data. This model is suitable for situations where all original data records must be preserved."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"./unique",children:"Unique Key Model"}),": Ensures that each row has a unique Key value, and guarantees that there are no duplicate rows for a given Key column. The Doris storage layer retains only the latest written data for each key, making this model suitable for scenarios that involve data updates."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"./aggregate",children:"Aggregate Key Model"}),": Allows data to be aggregated based on the Key columns. The Doris storage layer retains aggregated data, reducing storage space and improving query performance. This model is typically used in situations where summary or aggregated information (such as totals or averages) is required."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"After creating the table, the properties of the table model are confirmed and cannot be modified. Choosing the right model for the business is crucial:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Duplicate Key Model"})," is suitable for ad-hoc queries with any dimensions. Although it cannot leverage the benefits of pre-aggregation, it is not constrained by aggregation models and can take advantage of the columnar storage model (only reading relevant columns without needing to read all key columns)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Unique Key Model"})," is designed for scenarios where a unique key constraint is needed, ensuring the uniqueness of the key. However, it cannot utilize the query benefits brought by pre-aggregations such as ROLLUP."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Aggregate Key Model"})," can greatly reduce the data and computation required for aggregation queries through pre-aggregation, making it ideal for fixed-schema reporting queries. However, this model is not friendly to ",(0,s.jsx)(n.code,{children:"count(*)"})," queries. Also, because the aggregation method for the Value columns is fixed, when performing other types of aggregation queries, semantic correctness must be considered."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Update partial columns"}),", please refer to the documentation for ",(0,s.jsx)(n.a,{href:"../../data-operate/update/update-of-aggregate-model",children:"Partial Column Updates in Unique Key Model"})," and ",(0,s.jsx)(n.a,{href:"../../data-operate/update/update-of-aggregate-model",children:"Partial Column Updates in Aggregate Model"})," for relevant usage advice."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"sort-key",children:"Sort Key"}),"\n",(0,s.jsx)(n.p,{children:"In Doris, data is stored in a columnar format, and a table can be divided into Key columns and Value columns. The Key columns are used for grouping and sorting, while the Value columns are used for aggregation. Key columns can consist of one or more fields, and when creating a table, data is sorted and stored according to the columns of Aggregate Key, Unique Key, and Duplicate Key models."}),"\n",(0,s.jsx)(n.p,{children:"Different table models require the specification of Key columns during table creation, each with a different significance: for the Duplicate Key model, the Key columns represent sorting, without any uniqueness constraints. In the Aggregate Key and Unique Key models, aggregation is performed based on the Key columns, which not only have sorting capabilities but also enforce uniqueness constraints."}),"\n",(0,s.jsx)(n.p,{children:"Proper use of the Sort Key can provide the following benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Accelerated Query Performance"}),": Sort keys help reduce the amount of data that needs to be scanned. For range queries or filtering queries, the sort key can directly locate the data. For queries that require sorting, the sort key can also accelerate the sorting process."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Data Compression Optimization"}),": Storing data in an ordered fashion based on the sort key improves compression efficiency, as similar data will be grouped together, significantly increasing the compression ratio and reducing storage space."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reduced Deduplication Costs"}),": When using the Unique Key Model, the sort key allows Doris to perform deduplication more efficiently, ensuring data uniqueness."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When selecting a sort key, the following recommendations can be followed:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The Key columns must come before all Value columns."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Preferably choose integer types. This is because integer types are much more efficient in computation and lookup than strings."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"For selecting different lengths of integer types, follow the principle of choosing what is sufficient."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["For the length of ",(0,s.jsx)(n.code,{children:"VARCHAR"})," and ",(0,s.jsx)(n.code,{children:"STRING"})," types, follow the principle of choosing enough..."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"table-model-comparison",children:"Table Model Comparison"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{}),(0,s.jsx)(n.th,{children:"Duplicate Key Model"}),(0,s.jsx)(n.th,{children:"Unique Key Model"}),(0,s.jsx)(n.th,{children:"Aggregate Key Model"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Key Column Uniqueness"}),(0,s.jsx)(n.td,{children:"Not Supported, Key columns can be duplicated"}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Supported"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Synchronous Materialized View"}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Supported"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Asynchronous Materialized View"}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Supported"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"UPDATE Statement"}),(0,s.jsx)(n.td,{children:"Not Supported"}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Not Supported"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"DELETE Statement"}),(0,s.jsx)(n.td,{children:"Partially Supported"}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Not Supported"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Full Row Update on Import"}),(0,s.jsx)(n.td,{children:"Not Supported"}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Not Supported"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Partial Column Update on Import"}),(0,s.jsx)(n.td,{children:"Not Supported"}),(0,s.jsx)(n.td,{children:"Supported"}),(0,s.jsx)(n.td,{children:"Partially Supported"})]})]})]})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return o}});var i=t(667294);let s={},r=i.createContext(s);function o(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);